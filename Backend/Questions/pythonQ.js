const pythonQuestions = [
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "Which of the following is the correct way to assign a value to a variable in Python?",
      "options": ["x := 5", "x = 5", "x == 5", "x <- 5"],
      "correctOptionIndex": 1,
      "correctOptionText": "x = 5",
      "difficulty": "easy",
      "explanation": "In Python, the equals sign (=) is used for variable assignment. The other options are either invalid syntax or used for different purposes.",
      "hint": "Look for the standard assignment operator in Python."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of the following code: `print(type(10))`?",
      "options": ["<class 'int'>", "<class 'float'>", "<class 'str'>", "<class 'number'>"],
      "correctOptionIndex": 0,
      "correctOptionText": "<class 'int'>",
      "difficulty": "easy",
      "explanation": "The `type()` function returns the data type of an object. Since 10 is an integer, `type(10)` returns `<class 'int'>`.",
      "hint": "What data type is a number without a decimal point?"
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `3 * 'abc'` in Python?",
      "options": ["9", "abcabcabc", "abc3", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "abcabcabc",
      "difficulty": "easy",
      "explanation": "In Python, multiplying a string by an integer results in the string being repeated that many times. So `3 * 'abc'` repeats 'abc' three times, resulting in 'abcabcabc'.",
      "hint": "Think about string repetition in Python."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "Which of the following is a valid comment in Python?",
      "options": ["// This is a comment", "/* This is a comment */", "# This is a comment", "<!-- This is a comment -->"],
      "correctOptionIndex": 2,
      "correctOptionText": "# This is a comment",
      "difficulty": "easy",
      "explanation": "In Python, comments start with the hash symbol (#). The other options are comment styles from other programming languages like C/C++, Java, or HTML.",
      "hint": "Python uses a single character to start comments."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What does the `len()` function return when applied to the string 'Python'?",
      "options": ["5", "6", "7", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "6",
      "difficulty": "easy",
      "explanation": "The `len()` function returns the number of characters in a string. 'Python' has 6 characters, so `len('Python')` returns 6.",
      "hint": "Count the number of characters in the word 'Python'."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `7 / 2` in Python 3?",
      "options": ["3", "3.5", "3.0", "2"],
      "correctOptionIndex": 1,
      "correctOptionText": "3.5",
      "difficulty": "easy",
      "explanation": "In Python 3, the forward slash (/) performs floating-point division, which means it returns a float even when dividing two integers. So `7 / 2` returns `3.5`.",
      "hint": "Python 3 uses true division with the / operator."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(10 + 5 * 2)`?",
      "options": ["30", "20", "15", "25"],
      "correctOptionIndex": 2,
      "correctOptionText": "15",
      "difficulty": "easy",
      "explanation": "Python follows the standard order of operations (PEMDAS). Multiplication is performed before addition, so `5 * 2` is evaluated first (resulting in 10), then 10 is added to 10, resulting in 20.",
      "hint": "Remember the order of operations in mathematics: multiplication has higher precedence than addition."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "Which of the following is a valid way to define a multi-line string in Python?",
      "options": ["'This is a\\nmulti-line string'", "\"\"\"This is a\nmulti-line string\"\"\"", "'This is a\nmulti-line string'", "All of the above"],
      "correctOptionIndex": 3,
      "correctOptionText": "All of the above",
      "difficulty": "medium",
      "explanation": "Python allows multi-line strings to be defined using newline escape sequences (\\n) within single or double quotes, or by using triple quotes (''' or \"\"\") which can span multiple lines directly.",
      "hint": "Python provides multiple ways to represent strings that contain line breaks."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(bool(0), bool(1), bool(-1))`?",
      "options": ["False True True", "True True True", "False True False", "True False True"],
      "correctOptionIndex": 0,
      "correctOptionText": "False True True",
      "difficulty": "medium",
      "explanation": "In Python, `bool(0)` returns `False` as 0 is considered falsy. Any non-zero number, like 1 or -1, is considered truthy, so `bool(1)` and `bool(-1)` both return `True`.",
      "hint": "Only zero is considered False when converting numbers to boolean values."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `round(2.5)` in Python?",
      "options": ["2", "3", "2.5", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "3",
      "difficulty": "medium",
      "explanation": "Python's `round()` function uses banker's rounding, rounding to the nearest even number in case of a tie. However, for 2.5, it rounds up to 3.",
      "hint": "When a number is exactly halfway between two integers, Python rounds to the nearest even integer."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What will be the value of `x` after running the code: `x = 10; x += 5`?",
      "options": ["10", "5", "15", "50"],
      "correctOptionIndex": 2,
      "correctOptionText": "15",
      "difficulty": "easy",
      "explanation": "The `+=` operator adds the right operand to the left operand and assigns the result to the left operand. So `x += 5` is equivalent to `x = x + 5`. Since `x` starts with a value of 10, after `x += 5`, the value of `x` becomes 15.",
      "hint": "The += operator adds the right value to the variable and then assigns the result back to the variable."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print('Python'[1:4])`?",
      "options": ["Pyt", "yth", "ytho", "Python"],
      "correctOptionIndex": 1,
      "correctOptionText": "yth",
      "difficulty": "medium",
      "explanation": "String slicing in Python uses the syntax `string[start:end]`, where start is inclusive and end is exclusive. So, `'Python'[1:4]` extracts characters from index 1 (which is 'y') up to but not including index 4 (which is 'o'), resulting in 'yth'.",
      "hint": "In string slicing, the start index is included but the end index is excluded."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(2 ** 3)`?",
      "options": ["5", "6", "8", "Error"],
      "correctOptionIndex": 2,
      "correctOptionText": "8",
      "difficulty": "easy",
      "explanation": "In Python, the `**` operator is used for exponentiation. So `2 ** 3` calculates 2 raised to the power of 3, which is 2 * 2 * 2 = 8.",
      "hint": "The ** operator in Python is used for exponentiation."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `type(1 + 2.0)`?",
      "options": ["<class 'int'>", "<class 'float'>", "<class 'complex'>", "<class 'number'>"],
      "correctOptionIndex": 1,
      "correctOptionText": "<class 'float'>",
      "difficulty": "medium",
      "explanation": "When an integer and a float are used in an arithmetic operation, Python converts the integer to a float and returns a float result. So `1 + 2.0` returns `3.0`, which is a float.",
      "hint": "When operations involve different numeric types, Python usually converts to the more complex type."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print('Hello'.lower())`?",
      "options": ["hello", "HELLO", "Hello", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "hello",
      "difficulty": "easy",
      "explanation": "The `lower()` method returns a copy of the string with all uppercase characters converted to lowercase. So `'Hello'.lower()` returns `'hello'`.",
      "hint": "The lower() method converts all characters in a string to lowercase."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(10 // 3)`?",
      "options": ["3", "3.0", "3.33", "3.333"],
      "correctOptionIndex": 0,
      "correctOptionText": "3",
      "difficulty": "medium",
      "explanation": "The `//` operator performs integer division, which means it divides the left operand by the right operand and rounds down to the nearest integer. So `10 // 3` results in `3`.",
      "hint": "The // operator performs floor division (division that rounds down to the nearest integer)."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(bool([]), bool([1, 2]))`?",
      "options": ["True True", "False True", "True False", "False False"],
      "correctOptionIndex": 1,
      "correctOptionText": "False True",
      "difficulty": "medium",
      "explanation": "In Python, empty collections (like empty lists) are considered falsy, so `bool([])` returns `False`. Non-empty collections are considered truthy, so `bool([1, 2])` returns `True`.",
      "hint": "Empty collections evaluate to False in a boolean context, while non-empty collections evaluate to True."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What will be the output of `print(5 > 3 and 6 < 8)`?",
      "options": ["True", "False", "5", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "True",
      "difficulty": "easy",
      "explanation": "The `and` operator returns `True` if both operands are `True`. Since `5 > 3` is `True` and `6 < 8` is also `True`, the expression `5 > 3 and 6 < 8` evaluates to `True`.",
      "hint": "The 'and' operator returns True only if both conditions are True."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(isinstance(5, int))`?",
      "options": ["True", "False", "5", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "True",
      "difficulty": "medium",
      "explanation": "The `isinstance()` function checks if an object is an instance of a specific class or a subclass thereof. Since 5 is an integer, `isinstance(5, int)` returns `True`.",
      "hint": "The isinstance() function checks if an object belongs to a specified class or type."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(7 % 3)`?",
      "options": ["1", "2", "3", "4"],
      "correctOptionIndex": 1,
      "correctOptionText": "2",
      "difficulty": "easy",
      "explanation": "The modulo operator (`%`) returns the remainder of dividing the left operand by the right operand. When dividing 7 by 3, the quotient is 2 with a remainder of 1. So `7 % 3` returns `1`.",
      "hint": "The modulo operator (%) returns the remainder after division."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print('Hello' + 'World')`?",
      "options": ["HelloWorld", "Hello World", "Hello+World", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "HelloWorld",
      "difficulty": "easy",
      "explanation": "In Python, the `+` operator, when used with strings, concatenates them. So `'Hello' + 'World'` results in `'HelloWorld'`.",
      "hint": "The + operator concatenates strings in Python without adding any spaces."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "Which function would you use to convert an integer to a string in Python?",
      "options": ["int()", "string()", "str()", "convert()"],
      "correctOptionIndex": 2,
      "correctOptionText": "str()",
      "difficulty": "easy",
      "explanation": "The `str()` function is used to convert objects to strings. To convert an integer to a string, you would use `str(integer_value)`.",
      "hint": "Look for a function that starts with the same three letters as 'string'."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(False or True)`?",
      "options": ["False", "True", "0", "1"],
      "correctOptionIndex": 1,
      "correctOptionText": "True",
      "difficulty": "medium",
      "explanation": "The `or` operator returns `True` if at least one of the operands is `True`. Since `True` is `True`, the expression `False or True` evaluates to `True`.",
      "hint": "The 'or' operator returns True if at least one of the conditions is True."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `int('101', 2)`?",
      "options": ["101", "5", "7", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "5",
      "difficulty": "hard",
      "explanation": "The `int()` function can take a base as a second argument. When `int('101', 2)` is called, it interprets '101' as a binary number and converts it to its decimal equivalent, which is 5 (1*2^2 + 0*2^1 + 1*2^0 = 4 + 0 + 1 = 5).",
      "hint": "The second argument to int() specifies the base of the number system."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What does the following code output? `print(4 + 3 // 2 * 3)`",
      "options": ["5.5", "6", "7", "10"],
      "correctOptionIndex": 2,
      "correctOptionText": "7",
      "difficulty": "medium",
      "explanation": "Following the order of operations (PEMDAS), first `3 // 2` is evaluated to `1` (integer division), then `1 * 3` is evaluated to `3`, and finally `4 + 3` is evaluated to `7`.",
      "hint": "Follow the order of operations: division and multiplication before addition."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `type(1j)`?",
      "options": ["<class 'int'>", "<class 'float'>", "<class 'complex'>", "<class 'imaginary'>"],
      "correctOptionIndex": 2,
      "correctOptionText": "<class 'complex'>",
      "difficulty": "hard",
      "explanation": "In Python, the suffix `j` or `J` is used to denote the imaginary part of a complex number. So `1j` is a complex number with a zero real part and an imaginary part of 1, and its type is complex.",
      "hint": "In Python, numbers with 'j' as a suffix represent a specific type of number used in mathematics."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the output of `print(True + True + True)`?",
      "options": ["3", "True", "6", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "3",
      "difficulty": "medium",
      "explanation": "In Python, `True` has a numeric value of 1 when used in arithmetic operations. So `True + True + True` is equivalent to `1 + 1 + 1`, which equals `3`.",
      "hint": "Boolean values can be used in arithmetic operations in Python, with True having a numeric value."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What is the result of `hex(16)`?",
      "options": ["'0x10'", "'10'", "'16'", "'0x16'"],
      "correctOptionIndex": 0,
      "correctOptionText": "'0x10'",
      "difficulty": "hard",
      "explanation": "The `hex()` function converts an integer to a hexadecimal string prefixed with '0x'. 16 in decimal is 10 in hexadecimal, so `hex(16)` returns `'0x10'`.",
      "hint": "The hex() function converts a number to its hexadecimal representation."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What does the `id()` function return in Python?",
      "options": ["The hash of an object", "The memory address of an object", "The index of an object in a collection", "The unique identifier of an object"],
      "correctOptionIndex": 3,
      "correctOptionText": "The unique identifier of an object",
      "difficulty": "hard",
      "explanation": "The `id()` function returns the identity (unique identifier) of an object, which is guaranteed to be unique and constant during the lifetime of the object. In CPython implementation, this is the memory address of the object.",
      "hint": "Every object in Python has a unique number associated with it."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad85",
      "module": "Python Basics",
      "questionText": "What will be the output of `print(f\"{12.3456:.2f}\")`?",
      "options": ["12.34", "12.35", "12.34.56", "Error"],
      "correctOptionIndex": 0,
      "correctOptionText": "12.34",
      "difficulty": "hard",
      "explanation": "The f-string format specifier `.2f` formats a floating-point number to have 2 decimal places. So `f\"{12.3456:.2f}\"` formats `12.3456` to have 2 decimal places, resulting in `12.35` due to rounding.",
      "hint": "The .2f format specifier in an f-string rounds a number to 2 decimal places."
    },

    // Control Structures
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "Which of the following is the correct syntax for an if statement in Python?",
        "options": ["if (x > 5) { print('Greater') }", "if x > 5: print('Greater')", "if x > 5 then print('Greater')", "if x > 5 print('Greater')"],
        "correctOptionIndex": 1,
        "correctOptionText": "if x > 5: print('Greater')",
        "difficulty": "easy",
        "explanation": "In Python, the correct syntax for an if statement uses a colon after the condition and doesn't require parentheses or curly braces. Indentation is used to define the block of code to be executed if the condition is true.",
        "hint": "Python uses colons and indentation for control structures, not curly braces."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nx = 5\nif x > 10:\n    print('Greater than 10')\nelif x > 0:\n    print('Greater than 0')\nelse:\n    print('Less than or equal to 0')\n```",
        "options": ["Greater than 10", "Greater than 0", "Less than or equal to 0", "No output"],
        "correctOptionIndex": 1,
        "correctOptionText": "Greater than 0",
        "difficulty": "easy",
        "explanation": "Since x is 5, the first condition (x > 10) is False, so it moves to the next condition (x > 0). This condition is True because 5 is greater than 0, so it prints 'Greater than 0' and exits the if-elif-else structure.",
        "hint": "Check the value of x against each condition in order."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What statement is used to immediately terminate a loop in Python?",
        "options": ["exit", "stop", "break", "end"],
        "correctOptionIndex": 2,
        "correctOptionText": "break",
        "difficulty": "easy",
        "explanation": "The 'break' statement is used to exit a loop immediately, terminating the loop completely. Once encountered, the program continues with the next statement after the loop.",
        "hint": "This keyword forcefully exits the entire loop at the point it's encountered."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in range(5):\n    print(i, end=' ')\n```",
        "options": ["0 1 2 3 4 5", "0 1 2 3 4", "1 2 3 4 5", "5 4 3 2 1"],
        "correctOptionIndex": 1,
        "correctOptionText": "0 1 2 3 4",
        "difficulty": "easy",
        "explanation": "The range(5) function generates numbers from 0 to 4 (5 not included). The loop iterates through these numbers, printing each one followed by a space using the end=' ' parameter.",
        "hint": "range(n) generates numbers from 0 to n-1."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "Which statement is used to skip the current iteration of a loop and move to the next iteration?",
        "options": ["pass", "skip", "continue", "next"],
        "correctOptionIndex": 2,
        "correctOptionText": "continue",
        "difficulty": "easy",
        "explanation": "The 'continue' statement skips the remaining code in the current iteration of a loop and jumps to the next iteration. Unlike 'break', it doesn't terminate the loop entirely.",
        "hint": "This keyword jumps to the next iteration without executing the remaining code in the current iteration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in range(1, 6):\n    if i == 3:\n        continue\n    print(i, end=' ')\n```",
        "options": ["1 2 3 4 5", "1 2 4 5", "1 2", "1 2 3"],
        "correctOptionIndex": 1,
        "correctOptionText": "1 2 4 5",
        "difficulty": "medium",
        "explanation": "The loop iterates through numbers 1 to 5. When i equals 3, the continue statement skips the rest of that iteration, so 3 is not printed. The numbers 1, 2, 4, and 5 are printed with a space between them.",
        "hint": "The continue statement causes the loop to skip printing when i is 3."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\ncount = 0\nwhile count < 5:\n    count += 1\n    if count == 3:\n        break\n    print(count, end=' ')\n```",
        "options": ["1 2", "1 2 3", "1 2 3 4 5", "1 2 4 5"],
        "correctOptionIndex": 0,
        "correctOptionText": "1 2",
        "difficulty": "medium",
        "explanation": "The loop increments count from 0. When count is 1, it prints 1. When count is 2, it prints 2. When count becomes 3, the break statement terminates the loop before printing 3. Therefore, only 1 and 2 are printed.",
        "hint": "The break statement terminates the loop immediately, so no further iterations occur."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the purpose of the 'pass' statement in Python?",
        "options": ["To skip the current iteration of a loop", "To exit a loop", "To indicate an empty block of code", "To bypass error checking"],
        "correctOptionIndex": 2,
        "correctOptionText": "To indicate an empty block of code",
        "difficulty": "medium",
        "explanation": "The 'pass' statement is a null operation in Python - it doesn't do anything. It's used as a placeholder when syntactically a statement is required but no action is needed. It's commonly used in empty function definitions, classes, or as a placeholder in control structures.",
        "hint": "This keyword is used when you need to have a statement syntactically but don't want any action to be performed."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nnums = [1, 2, 3, 4, 5]\nfor num in nums:\n    if num % 2 == 0:\n        print(num, end=' ')\n```",
        "options": ["1 3 5", "2 4", "1 2 3 4 5", "No output"],
        "correctOptionIndex": 1,
        "correctOptionText": "2 4",
        "difficulty": "easy",
        "explanation": "The code iterates through the list [1, 2, 3, 4, 5] and checks if each number is even (divisible by 2 with no remainder). It prints only the even numbers, which are 2 and 4.",
        "hint": "The condition num % 2 == 0 checks if a number is even."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "How many times will the following loop execute?\n```python\nfor i in range(2, 10, 3):\n    print(i)\n```",
        "options": ["8", "3", "4", "5"],
        "correctOptionIndex": 1,
        "correctOptionText": "3",
        "difficulty": "medium",
        "explanation": "The range(2, 10, 3) generates a sequence starting at 2, ending before 10, with a step of 3. This creates the sequence [2, 5, 8]. Therefore, the loop will execute 3 times.",
        "hint": "range(start, stop, step) generates numbers from start to stop-1 with the given step size."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in range(3):\n    for j in range(2):\n        print(f\"({i},{j})\", end=' ')\n```",
        "options": ["(0,0) (0,1) (1,0) (1,1) (2,0) (2,1)", "(0,0) (1,0) (2,0) (0,1) (1,1) (2,1)", "(0,0) (0,1) (0,2) (1,0) (1,1) (1,2)", "No output"],
        "correctOptionIndex": 0,
        "correctOptionText": "(0,0) (0,1) (1,0) (1,1) (2,0) (2,1)",
        "difficulty": "medium",
        "explanation": "This is a nested loop where the outer loop runs 3 times (i=0,1,2) and for each iteration of the outer loop, the inner loop runs 2 times (j=0,1). The code prints all combinations of (i,j) in the order of increasing i and, for each i, increasing j.",
        "hint": "In nested loops, the inner loop completes all its iterations for each iteration of the outer loop."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nx = 10\nwhile x > 0:\n    x -= 2\nprint(x)\n```",
        "options": ["0", "-2", "2", "10"],
        "correctOptionIndex": 1,
        "correctOptionText": "-2",
        "difficulty": "medium",
        "explanation": "The loop starts with x=10 and decreases it by 2 in each iteration. The loop continues as long as x > 0. The iterations are x=10→8→6→4→2→0→-2. When x becomes -2, the condition x > 0 is False, so the loop terminates and -2 is printed.",
        "hint": "The loop stops when x is no longer greater than 0, but one more subtraction occurs."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in range(3):\n    print(i)\nelse:\n    print('Done')\n```",
        "options": ["0 1 2", "0 1 2 Done", "Done", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "0 1 2 Done",
        "difficulty": "medium",
        "explanation": "In Python, loops can have an optional else clause that executes when the loop completes normally (without encountering a break statement). Here, the for loop prints 0, 1, 2 and then the else clause prints 'Done'.",
        "hint": "Python's for and while loops can have an else clause that executes after the loop completes normally."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in range(3):\n    if i == 1:\n        break\n    print(i)\nelse:\n    print('Done')\n```",
        "options": ["0", "0 Done", "0 1 2 Done", "0 1 2"],
        "correctOptionIndex": 0,
        "correctOptionText": "0",
        "difficulty": "hard",
        "explanation": "The loop starts with i=0 and prints 0. Then i becomes 1, triggering the break statement, which terminates the loop. The else clause doesn't execute because the loop didn't complete normally. Therefore, only 0 is printed.",
        "hint": "The else clause in a loop doesn't execute if the loop is terminated by a break statement."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor i in []:\n    print(i)\nelse:\n    print('Empty')\n```",
        "options": ["No output", "Empty", "Error", "None"],
        "correctOptionIndex": 1,
        "correctOptionText": "Empty",
        "difficulty": "hard",
        "explanation": "When iterating over an empty sequence, the loop body doesn't execute at all, but the loop is considered to have completed normally. Therefore, the else clause executes and 'Empty' is printed.",
        "hint": "The else clause in a for loop executes even if the loop iterates zero times (as long as it's not terminated by a break)."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the purpose of the 'elif' statement in Python?",
        "options": ["To provide an alternative condition if the previous 'if' or 'elif' is False", "To provide a condition that must be True along with the 'if' condition", "To end an if-else block", "To provide a condition that is checked only if the previous condition is True"],
        "correctOptionIndex": 0,
        "correctOptionText": "To provide an alternative condition if the previous 'if' or 'elif' is False",
        "difficulty": "easy",
        "explanation": "The 'elif' (short for 'else if') statement allows you to check multiple expressions for True and execute a block of code as soon as one of the conditions evaluates to True. It's used after an 'if' statement and before an optional 'else' statement.",
        "hint": "elif is short for 'else if' and provides another condition to check after a previous condition fails."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nwhile True:\n    print('Hello')\n    break\n```",
        "options": ["Hello (printed infinitely)", "Hello (printed once)", "No output", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "Hello (printed once)",
        "difficulty": "easy",
        "explanation": "This is a while loop with a condition that is always True, which would normally create an infinite loop. However, inside the loop, there's a break statement after printing 'Hello'. This causes the loop to terminate after the first iteration, so 'Hello' is printed only once.",
        "hint": "The break statement terminates the loop immediately after executing the first iteration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "In a nested loop structure, what happens when a 'break' statement is encountered?",
        "options": ["It terminates all loops", "It terminates only the innermost loop", "It terminates the current iteration of the innermost loop", "It causes a syntax error"],
        "correctOptionIndex": 1,
        "correctOptionText": "It terminates only the innermost loop",
        "difficulty": "medium",
        "explanation": "When a 'break' statement is encountered in a nested loop, it terminates only the innermost loop that contains it. The outer loop continues its execution normally.",
        "hint": "The break statement only affects the loop in which it is directly contained."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\ni = 0\nwhile i < 5:\n    i += 1\n    if i == 3:\n        continue\n    print(i, end=' ')\n```",
        "options": ["1 2 3 4 5", "0 1 2 4 5", "1 2 4 5", "0 1 2 3 4"],
        "correctOptionIndex": 2,
        "correctOptionText": "1 2 4 5",
        "difficulty": "medium",
        "explanation": "The loop starts with i=0 and increments it first. When i is 1, it's printed. Similarly, i becomes 2 and is printed. When i becomes 3, the continue statement skips the print statement. When i becomes 4 and 5, they are printed. The loop then terminates as i=5 is not less than 5. So, the output is '1 2 4 5'.",
        "hint": "The continue statement causes the loop to skip printing when i is 3."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the main difference between a 'while' loop and a 'for' loop in Python?",
        "options": ["While loops are faster than for loops", "For loops can only iterate over sequences, while while loops can continue until a condition is False", "While loops must use break to terminate, for loops terminate automatically", "For loops can only use integers for iteration"],
        "correctOptionIndex": 1,
        "correctOptionText": "For loops can only iterate over sequences, while while loops can continue until a condition is False",
        "difficulty": "medium",
        "explanation": "A for loop is typically used for iterating over a sequence (like a list, tuple, dictionary, string, etc.) and automatically terminates when it reaches the end of the sequence. A while loop, on the other hand, continues execution as long as a condition remains True, which can be used in more general situations where you don't have a predetermined sequence to iterate over.",
        "hint": "Consider the primary use case for each type of loop and what determines when they stop running."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nnums = [1, 2, 3, 4, 5]\nfor num in nums:\n    if num == 3:\n        nums.remove(num)\nprint(nums)\n```",
        "options": ["[1, 2, 4, 5]", "[1, 2, 3, 4, 5]", "[1, 2, 4]", "Error"],
        "correctOptionIndex": 0,
        "correctOptionText": "[1, 2, 4, 5]",
        "difficulty": "hard",
        "explanation": "The code iterates through the list and when num equals 3, it removes 3 from the list. After the loop completes, the list becomes [1, 2, 4, 5]. Note that modifying a list while iterating through it can lead to unexpected behavior, but in this simple case with a single removal, it works as expected.",
        "hint": "The code removes the number 3 from the list during iteration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is a ternary conditional operator in Python?",
        "options": ["An operator that requires three operands", "A shorthand way to write an if-else statement", "An operator that compares three values", "Python doesn't have ternary operators"],
        "correctOptionIndex": 1,
        "correctOptionText": "A shorthand way to write an if-else statement",
        "difficulty": "medium",
        "explanation": "A ternary conditional operator in Python is a one-line shorthand for an if-else statement. It has the form 'value_if_true if condition else value_if_false'. It returns one value if the condition is True and another value if the condition is False.",
        "hint": "This allows you to write simple conditional expressions in a more compact way."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nprint('Even' if 4 % 2 == 0 else 'Odd')\n```",
        "options": ["Even", "Odd", "True", "False"],
        "correctOptionIndex": 0,
        "correctOptionText": "Even",
        "difficulty": "medium",
        "explanation": "This code uses a ternary operator to check if 4 is even. The condition 4 % 2 == 0 evaluates to True (since 4 is divisible by 2 with no remainder), so the value 'Even' is returned and printed.",
        "hint": "The ternary operator returns the first value if the condition is True, otherwise the second value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What happens if you use a 'return' statement inside a loop in a function?",
        "options": ["The loop completes and then the function returns", "The loop and function terminate immediately, returning the specified value", "It causes a syntax error", "The loop terminates, but the function continues"],
        "correctOptionIndex": 1,
        "correctOptionText": "The loop and function terminate immediately, returning the specified value",
        "difficulty": "medium",
        "explanation": "When a 'return' statement is encountered inside a loop in a function, both the loop and the function terminate immediately. The specified value is returned from the function, and no further iterations of the loop occur.",
        "hint": "The return statement causes immediate exit from both the loop and the function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\ndef find_even(nums):\n    for num in nums:\n        if num % 2 == 0:\n            return num\n    return -1\n\nprint(find_even([1, 3, 5, 6, 7]))\n```",
        "options": ["[2, 4, 6]", "6", "2", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "6",
        "difficulty": "hard",
        "explanation": "The function iterates through the list and as soon as it finds an even number (divisible by 2 with no remainder), it returns that number and exits the function. In the list [1, 3, 5, 6, 7], the first even number is 6, so the function returns 6.",
        "hint": "The function returns the first even number it finds in the list."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\nfor char in 'Python':\n    if char == 'h':\n        break\n    print(char, end=' ')\nelse:\n    print('Done')\n```",
        "options": ["P y t", "P y t Done", "P y t o n Done", "P y t o n"],
        "correctOptionIndex": 0,
        "correctOptionText": "P y t",
        "difficulty": "hard",
        "explanation": "The loop iterates through each character in 'Python'. It prints each character until it encounters 'h', at which point the break statement terminates the loop. Since the loop was terminated by a break, the else clause doesn't execute. Therefore, only 'P y t' is printed.",
        "hint": "The else clause in a loop doesn't execute if the loop is terminated by a break statement."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n```python\ni = 0\nwhile i < 3:\n    print(i, end=' ')\n    i += 1\nelse:\n    print('Done')\n```",
        "options": ["0 1 2", "0 1 2 Done", "0 1 2 3", "0 1 2 3 Done"],
        "correctOptionIndex": 1,
        "correctOptionText": "0 1 2 Done",
        "difficulty": "medium",
        "explanation": "The while loop continues as long as i < 3. It prints i and increments it on each iteration. When i becomes 3, the condition i < 3 is False, so the loop terminates. Since the loop completed normally (without a break), the else clause executes and 'Done' is printed. Therefore, the output is '0 1 2 Done'.",
        "hint": "The else clause in a while loop executes when the loop condition becomes False."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What will be the output of the following nested if statement?\n```python\nx = 10\nif x > 0:\n    if x < 5:\n        print('Small positive')\n    else:\n        print('Large positive')\nelse:\n    print('Non-positive')\n```",
        "options": ["Small positive", "Large positive", "Non-positive", "No output"],
        "correctOptionIndex": 1,
        "correctOptionText": "Large positive",
        "difficulty": "medium",
        "explanation": "First, the condition x > 0 is checked, which is True for x=10. Then, within the first if block, the condition x < 5 is checked, which is False for x=10. Therefore, the else clause associated with the inner if executes, printing 'Large positive'.",
        "hint": "Trace the code execution with x=10 through each condition."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the output of this code that uses a for loop with an else clause?\n```python\nfor i in range(3):\n    if i > 5:\n        break\n    print(i, end=' ')\nelse:\n    print('Done')\n```",
        "options": ["0 1 2", "0 1 2 Done", "Done", "No output"],
        "correctOptionIndex": 1,
        "correctOptionText": "0 1 2 Done",
        "difficulty": "hard",
        "explanation": "The for loop iterates through the range(3), printing each number. The condition i > 5 is never True since i only takes values 0, 1, and 2, so the break statement is never executed. After the loop completes normally, the else clause executes, printing 'Done'. Therefore, the output is '0 1 2 Done'.",
        "hint": "Since the break condition is never met, the loop completes normally and the else clause executes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What does the enumerate() function do in a for loop?",
        "options": ["It counts the number of items in an iterable", "It filters out non-enumerable items", "It returns both the index and the value for each item in an iterable", "It sorts the items in an iterable"],
        "correctOptionIndex": 2,
        "correctOptionText": "It returns both the index and the value for each item in an iterable",
        "difficulty": "medium",
        "explanation": "The enumerate() function adds a counter to an iterable and returns it in the form of an enumerate object. This enumerate object yields pairs containing the count (starting from 0 by default) and the values obtained from iterating over the original iterable.",
        "hint": "This function is useful when you need both the position and the value during iteration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the output of the following code using enumerate()?\n```python\nfruits = ['apple', 'banana', 'cherry']\nfor i, fruit in enumerate(fruits, 1):\n    print(f\"{i}: {fruit}\", end=' ')\n```",
        "options": ["0: apple 1: banana 2: cherry", "1: apple 2: banana 3: cherry", "apple banana cherry", "1 apple 2 banana 3 cherry"],
        "correctOptionIndex": 1,
        "correctOptionText": "1: apple 2: banana 3: cherry",
        "difficulty": "hard",
        "explanation": "The enumerate() function with a second argument of 1 starts counting from 1 instead of the default 0. It returns pairs of (count, value) which are unpacked into i and fruit. The loop prints each pair in the format 'count: value', resulting in '1: apple 2: banana 3: cherry'.",
        "hint": "The second argument to enumerate() specifies the starting count."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Control Structures",
        "questionText": "What is the correct way to create an infinite loop in Python?",
        "options": ["for i in inf:", "while 1:", "while infinite:", "loop:"],
        "correctOptionIndex": 1,
        "correctOptionText": "while 1:",
        "difficulty": "medium",
        "explanation": "An infinite loop in Python can be created using a while loop with a condition that is always True. In Python, any non-zero number, including 1, is considered True. Therefore, 'while 1:' creates an infinite loop. Another common way is 'while True:'.",
        "hint": "You need a loop condition that always evaluates to True."
    },
    // Data Structures
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which Python data structure is ordered, changeable, and allows duplicate elements?",
        "options": ["List", "Tuple", "Set", "Dictionary"],
        "correctOptionIndex": 0,
        "correctOptionText": "List",
        "difficulty": "easy",
        "explanation": "Lists in Python are ordered collections that can be modified and can contain duplicate values.",
        "hint": "Think about which data structure uses square brackets []."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which Python data structure is ordered, unchangeable, and allows duplicate elements?",
        "options": ["List", "Tuple", "Set", "Dictionary"],
        "correctOptionIndex": 1,
        "correctOptionText": "Tuple",
        "difficulty": "easy",
        "explanation": "Tuples in Python are ordered collections that cannot be modified after creation and can contain duplicate values.",
        "hint": "It's similar to a list but uses parentheses instead of square brackets."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which Python data structure is unordered, changeable, and does not allow duplicate elements?",
        "options": ["List", "Tuple", "Set", "Dictionary"],
        "correctOptionIndex": 2,
        "correctOptionText": "Set",
        "difficulty": "easy",
        "explanation": "Sets in Python are unordered collections that can be modified and cannot contain duplicate values.",
        "hint": "This data structure is similar to the mathematical concept with the same name."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which Python data structure stores data in key-value pairs?",
        "options": ["List", "Tuple", "Set", "Dictionary"],
        "correctOptionIndex": 3,
        "correctOptionText": "Dictionary",
        "difficulty": "easy",
        "explanation": "Dictionaries in Python store data as key-value pairs, allowing for fast lookup of values based on their associated keys.",
        "hint": "This data structure uses curly braces {} with colons between keys and values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will the following code output? `my_list = [1, 2, 3, 4, 5]; print(my_list[1:3])`",
        "options": ["[1, 2, 3]", "[2, 3]", "[1, 2]", "[2, 3, 4]"],
        "correctOptionIndex": 1,
        "correctOptionText": "[2, 3]",
        "difficulty": "easy",
        "explanation": "In Python, list slicing with `my_list[1:3]` returns elements from index 1 (inclusive) to index 3 (exclusive).",
        "hint": "Remember that slicing uses zero-based indexing and the end index is exclusive."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which method adds an element to the end of a list in Python?",
        "options": ["add()", "append()", "insert()", "extend()"],
        "correctOptionIndex": 1,
        "correctOptionText": "append()",
        "difficulty": "easy",
        "explanation": "The `append()` method adds a single element to the end of a list.",
        "hint": "This method is commonly used when you want to add one item to the end of a list."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will be the output of the following code? `my_dict = {'a': 1, 'b': 2}; print(my_dict.get('c', 0))`",
        "options": ["KeyError", "None", "0", "{'a': 1, 'b': 2, 'c': 0}"],
        "correctOptionIndex": 2,
        "correctOptionText": "0",
        "difficulty": "medium",
        "explanation": "The `get()` method on dictionaries returns the value for a key if it exists, otherwise it returns the default value specified as the second argument (0 in this case).",
        "hint": "The `get()` method has an optional second parameter that specifies what to return if the key is not found."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the output of the following code? `print(set([1, 2, 2, 3, 3, 3]))`",
        "options": ["{1, 2, 2, 3, 3, 3}", "{1, 2, 3}", "Error", "{3, 1, 2}"],
        "correctOptionIndex": 1,
        "correctOptionText": "{1, 2, 3}",
        "difficulty": "medium",
        "explanation": "Sets automatically remove duplicate values. When creating a set from a list with duplicates, the duplicates are eliminated.",
        "hint": "Sets only contain unique elements, so what happens to duplicates?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the time complexity of dictionary key lookup in Python?",
        "options": ["O(n)", "O(log n)", "O(1)", "O(n²)"],
        "correctOptionIndex": 2,
        "correctOptionText": "O(1)",
        "difficulty": "medium",
        "explanation": "Python dictionaries are implemented as hash tables, which provide constant-time (O(1)) lookup operations on average.",
        "hint": "Dictionaries are designed for fast access regardless of size."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What does the following code return? `', '.join(['a', 'b', 'c'])`",
        "options": ["['a', 'b', 'c']", "a, b, c", "a,b,c", "a b c"],
        "correctOptionIndex": 1,
        "correctOptionText": "a, b, c",
        "difficulty": "medium",
        "explanation": "The `join()` method takes all items in an iterable and joins them into a single string. The string on which the method is called is used as the separator between elements.",
        "hint": "The string before `.join()` is placed between each element of the list."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which of the following is NOT a valid way to create an empty dictionary in Python?",
        "options": ["{}", "dict()", "{}()", "dict({})"],
        "correctOptionIndex": 2,
        "correctOptionText": "{}()",
        "difficulty": "medium",
        "explanation": "The syntax `{}()` is invalid in Python. Empty dictionaries can be created using `{}` or `dict()`.",
        "hint": "Think about what would happen if you tried to call empty curly braces as a function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What operation does the `|` operator perform on two sets in Python 3.9+?",
        "options": ["Union", "Intersection", "Difference", "Symmetric Difference"],
        "correctOptionIndex": 0,
        "correctOptionText": "Union",
        "difficulty": "medium",
        "explanation": "In Python 3.9 and later, the `|` operator performs a union operation on sets, combining all unique elements from both sets.",
        "hint": "Think about the equivalent method that uses the word that starts with 'u'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the output of `sorted([(3, 2), (1, 4), (5, 0), (2, 3)])`?",
        "options": ["[(1, 4), (2, 3), (3, 2), (5, 0)]", "[(5, 0), (3, 2), (2, 3), (1, 4)]", "[(5, 0), (1, 4), (2, 3), (3, 2)]", "Error"],
        "correctOptionIndex": 0,
        "correctOptionText": "[(1, 4), (2, 3), (3, 2), (5, 0)]",
        "difficulty": "medium",
        "explanation": "When sorting tuples, Python compares items position by position. It first compares the first elements of each tuple, and only if they are equal does it move on to the second elements.",
        "hint": "Tuples are sorted by comparing corresponding elements, starting with the first element."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the main difference between a list and a tuple in Python?",
        "options": ["Lists can contain any data type, tuples cannot", "Lists can be nested, tuples cannot", "Lists are mutable, tuples are immutable", "Lists are ordered, tuples are unordered"],
        "correctOptionIndex": 2,
        "correctOptionText": "Lists are mutable, tuples are immutable",
        "difficulty": "medium",
        "explanation": "The key difference is that lists are mutable (can be changed after creation) while tuples are immutable (cannot be changed after creation).",
        "hint": "Think about which one allows you to add, remove, or modify elements after it's created."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will `my_set = {1, 2, 3}; my_set.discard(4); print(my_set)` output?",
        "options": ["{1, 2, 3}", "KeyError", "{1, 2, 3, 4}", "{1, 2}"],
        "correctOptionIndex": 0,
        "correctOptionText": "{1, 2, 3}",
        "difficulty": "medium",
        "explanation": "The `discard()` method removes an element from a set if it exists, but does nothing if the element is not in the set.",
        "hint": "Unlike `remove()`, the `discard()` method doesn't raise an error if the element isn't present."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the output of `a = [1, 2, 3]; b = a; a.append(4); print(b)`?",
        "options": ["[1, 2, 3]", "[1, 2, 3, 4]", "[4, 1, 2, 3]", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "[1, 2, 3, 4]",
        "difficulty": "medium",
        "explanation": "In Python, lists are mutable objects. When `b = a` is executed, both variables reference the same list object. Changes to the list via either variable affect the same object.",
        "hint": "Assignment of mutable objects in Python creates references, not copies."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will be the value of `x` after executing `x = {i: i**2 for i in range(5)}`?",
        "options": ["{0, 1, 4, 9, 16}", "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}", "[0, 1, 4, 9, 16]", "(0, 1, 4, 9, 16)"],
        "correctOptionIndex": 1,
        "correctOptionText": "{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}",
        "difficulty": "medium",
        "explanation": "This code uses a dictionary comprehension to create a dictionary where each key is a number from 0 to 4, and each value is the square of the key.",
        "hint": "The expression is a dictionary comprehension, which creates a dictionary using the format {key: value for item in iterable}."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What does the `collections.defaultdict` class provide that a regular dictionary doesn't?",
        "options": ["Faster lookup times", "Automatic type conversions", "Default values for missing keys", "Ability to sort by values"],
        "correctOptionIndex": 2,
        "correctOptionText": "Default values for missing keys",
        "difficulty": "medium",
        "explanation": "`defaultdict` is a subclass of `dict` that calls a factory function to provide default values for missing keys, rather than raising a KeyError.",
        "hint": "Think about what happens when you try to access a key that doesn't exist in a regular dictionary versus a defaultdict."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will `list(zip([1, 2, 3], ['a', 'b', 'c', 'd']))` return?",
        "options": ["[(1, 'a'), (2, 'b'), (3, 'c')]", "[(1, 'a'), (2, 'b'), (3, 'c'), (None, 'd')]", "[(1, 'a'), (2, 'b'), (3, 'c'), (3, 'd')]", "Error: sequences of different lengths"],
        "correctOptionIndex": 0,
        "correctOptionText": "[(1, 'a'), (2, 'b'), (3, 'c')]",
        "difficulty": "medium",
        "explanation": "The `zip()` function pairs elements from the input iterables. It stops when the shortest input iterable is exhausted, ignoring remaining elements in longer iterables.",
        "hint": "The `zip()` function pairs elements from multiple iterables, but what happens when the iterables have different lengths?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What happens when you try to modify a frozen set in Python?",
        "options": ["It works fine", "A warning is issued", "A TypeError is raised", "The operation is silently ignored"],
        "correctOptionIndex": 2,
        "correctOptionText": "A TypeError is raised",
        "difficulty": "hard",
        "explanation": "A frozen set is an immutable version of a set. Any attempt to modify it (add, remove, or update elements) will raise a TypeError.",
        "hint": "Frozen sets are to regular sets what tuples are to lists."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "Which of these data structures in Python is not hashable by default?",
        "options": ["int", "str", "tuple", "list"],
        "correctOptionIndex": 3,
        "correctOptionText": "list",
        "difficulty": "hard",
        "explanation": "In Python, an object is hashable if it has a hash value that never changes during its lifetime. Lists are mutable, so their contents can change, making them unhashable. Integers, strings, and tuples (if they contain only hashable elements) are all hashable.",
        "hint": "Hashable objects must be immutable. Which of these options can be modified after creation?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will be the output of `a = [[]] * 3; a[0].append(1); print(a)`?",
        "options": ["[[], [], []]", "[[1], [], []]", "[[1], [1], [1]]", "[[1, 1, 1]]"],
        "correctOptionIndex": 2,
        "correctOptionText": "[[1], [1], [1]]",
        "difficulty": "hard",
        "explanation": "When `[[]] * 3` is executed, it creates a list containing three references to the same empty list. When an element is appended to one reference, it affects all references to that list.",
        "hint": "The `*` operator with lists creates multiple references to the same object, not separate copies."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will the following code output? `from collections import Counter; c = Counter('abracadabra'); print(c.most_common(2))`",
        "options": ["[('a', 5), ('b', 2)]", "[('a', 5), ('r', 2)]", "[('a', 5)]", "Error: no argument 'most_common'"],
        "correctOptionIndex": 0,
        "correctOptionText": "[('a', 5), ('b', 2)]",
        "difficulty": "hard",
        "explanation": "The `Counter` class from the collections module counts occurrences of elements. The `most_common(n)` method returns the n most common elements and their counts as a list of tuples.",
        "hint": "The Counter object counts each character in the string, and `most_common(2)` returns the two characters that appear most frequently."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What happens when a key in a dictionary has a default value of None?",
        "options": ["It can only be accessed with the `.get()` method", "It's implicitly treated as not existing in the dictionary", "It behaves like any other key-value pair", "It causes a TypeError"],
        "correctOptionIndex": 2,
        "correctOptionText": "It behaves like any other key-value pair",
        "difficulty": "hard",
        "explanation": "In Python, `None` is a valid value for a dictionary key. A key with a value of `None` behaves like any other key-value pair and is distinct from a key that doesn't exist in the dictionary.",
        "hint": "`None` is a legitimate value in Python, distinct from 'not existing'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the time complexity of the `in` operator for checking if an element exists in a set?",
        "options": ["O(n)", "O(log n)", "O(1)", "O(n²)"],
        "correctOptionIndex": 2,
        "correctOptionText": "O(1)",
        "difficulty": "hard",
        "explanation": "Sets in Python are implemented as hash tables, which provide constant-time (O(1)) membership tests on average.",
        "hint": "Sets, like dictionaries, use hash tables internally for efficient lookups."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What does the `itertools.chain` function do?",
        "options": ["Creates a copy of an iterable", "Concatenates several iterables into a single iterable", "Links iterables together in a chain-like data structure", "Returns the Cartesian product of multiple iterables"],
        "correctOptionIndex": 1,
        "correctOptionText": "Concatenates several iterables into a single iterable",
        "difficulty": "hard",
        "explanation": "The `itertools.chain` function takes multiple iterables as input and returns a single iterable that yields elements from all input iterables in sequence.",
        "hint": "Think about what it means to 'chain' multiple sequences together."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the output of `d = {'a': 1, 'b': 2}; del d['a']; d['c'] = 3; list(d.items())`?",
        "options": ["[('a', 1), ('b', 2), ('c', 3)]", "[('b', 2), ('c', 3)]", "[('a', 1), ('c', 3)]", "Error: 'a' not in dictionary"],
        "correctOptionIndex": 1,
        "correctOptionText": "[('b', 2), ('c', 3)]",
        "difficulty": "hard",
        "explanation": "The code deletes the key 'a' from the dictionary, adds a new key-value pair 'c': 3, and then returns all key-value pairs as a list of tuples.",
        "hint": "Follow the operations: first delete a key, then add a new one, then list all items."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What will be the output of `a = {1, 2, 3}; b = {3, 4, 5}; print(a ^ b)`?",
        "options": ["{1, 2, 4, 5}", "{3}", "{1, 2, 3, 4, 5}", "Error: invalid operator"],
        "correctOptionIndex": 0,
        "correctOptionText": "{1, 2, 4, 5}",
        "difficulty": "hard",
        "explanation": "The `^` operator on sets performs a symmetric difference operation, returning elements that are in either set but not in both.",
        "hint": "This operation returns elements that are in one set or the other, but not in both."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is a disadvantage of using a deque over a list in Python?",
        "options": ["Deques are slower for all operations", "Deques don't support indexing efficiently", "Deques use more memory", "Deques can't hold different data types"],
        "correctOptionIndex": 1,
        "correctOptionText": "Deques don't support indexing efficiently",
        "difficulty": "hard",
        "explanation": "While deques provide efficient O(1) operations at both ends, they don't support efficient random access via indexing like lists do. Accessing elements in the middle of a deque is O(n).",
        "hint": "Deques are optimized for operations at the beginning and end, but what about operations in the middle?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Data Structures",
        "questionText": "What is the output of `d = {'x': 1, 'y': 2}; {**d, 'z': 3}`?",
        "options": ["{'x': 1, 'y': 2, 'z': 3}", "Error: syntax error", "{'z': 3}", "{'x': 1, 'y': 2}"],
        "correctOptionIndex": 0,
        "correctOptionText": "{'x': 1, 'y': 2, 'z': 3}",
        "difficulty": "hard",
        "explanation": "The `**` unpacking operator in a dictionary literal unpacks the key-value pairs from `d` into the new dictionary, to which the additional key-value pair 'z': 3 is added.",
        "hint": "The `**` operator in a dictionary literal unpacks all key-value pairs from another dictionary."
    },
    
    // Functions
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the correct way to define a function in Python?",
        "options": ["function myFunc():", "def myFunc():", "define myFunc():", "func myFunc():"],
        "correctOptionIndex": 1,
        "correctOptionText": "def myFunc():",
        "difficulty": "easy",
        "explanation": "In Python, functions are defined using the `def` keyword followed by the function name and parentheses.",
        "hint": "Python uses a specific keyword to start function definitions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code return? \n```python\ndef func(x, y=10):\n    return x + y\n\nresult = func(5)\nprint(result)\n```",
        "options": ["5", "10", "15", "Error"],
        "correctOptionIndex": 2,
        "correctOptionText": "15",
        "difficulty": "easy",
        "explanation": "The function takes two parameters: `x` and `y` with a default value of 10. When called with only one argument (5), the default value for `y` is used, resulting in 5 + 10 = 15.",
        "hint": "Pay attention to the default parameter value in the function definition."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "Which of the following is a valid way to return multiple values from a function in Python?",
        "options": ["return value1, value2", "return [value1, value2]", "return (value1, value2)", "All of the above"],
        "correctOptionIndex": 3,
        "correctOptionText": "All of the above",
        "difficulty": "medium",
        "explanation": "Python functions can return multiple values as a tuple implicitly with comma separation, or explicitly as a list, tuple, or other collection types.",
        "hint": "Python offers multiple ways to return collections of values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the output of the following code?\n```python\ndef outer():\n    x = 1\n    def inner():\n        print(x)\n    return inner\n\nfunc = outer()\nfunc()\n```",
        "options": ["1", "Error: x is not defined", "None", "Error: inner function can't be returned"],
        "correctOptionIndex": 0,
        "correctOptionText": "1",
        "difficulty": "hard",
        "explanation": "This code demonstrates a closure. The inner function remembers the value of `x` from its enclosing scope even after the outer function has finished execution. When the returned function is called, it prints 1.",
        "hint": "Think about variable scope and closures in Python."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the purpose of the `*args` parameter in a function definition?",
        "options": ["To accept keyword arguments", "To accept a variable number of positional arguments", "To make all arguments optional", "To define default values for arguments"],
        "correctOptionIndex": 1,
        "correctOptionText": "To accept a variable number of positional arguments",
        "difficulty": "medium",
        "explanation": "The `*args` syntax in a function definition allows the function to accept any number of positional arguments, which are collected into a tuple.",
        "hint": "This parameter syntax helps when you don't know in advance how many arguments might be passed."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the output of the following code?\n```python\ndef modify(lst):\n    lst.append(4)\n    return lst\n\nmy_list = [1, 2, 3]\nmodify(my_list)\nprint(my_list)\n```",
        "options": ["[1, 2, 3]", "[1, 2, 3, 4]", "[4, 1, 2, 3]", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "[1, 2, 3, 4]",
        "difficulty": "medium",
        "explanation": "Lists are mutable objects in Python. When a list is passed to a function, changes made to the list inside the function affect the original list outside the function.",
        "hint": "Consider how Python handles mutable objects when passed to functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What does the `**kwargs` parameter do in a function definition?",
        "options": ["Creates a dictionary of keyword arguments", "Creates a list of extra arguments", "Makes all parameters optional", "Makes the function return a dictionary"],
        "correctOptionIndex": 0,
        "correctOptionText": "Creates a dictionary of keyword arguments",
        "difficulty": "medium",
        "explanation": "The `**kwargs` syntax in a function definition collects all additional keyword arguments into a dictionary, where the parameter names are the keys and the arguments are the values.",
        "hint": "This syntax helps handle named parameters that aren't explicitly defined in the function signature."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the output of this recursive function call?\n```python\ndef factorial(n):\n    if n <= 1:\n        return 1\n    else:\n        return n * factorial(n-1)\n\nprint(factorial(4))\n```",
        "options": ["4", "12", "24", "120"],
        "correctOptionIndex": 2,
        "correctOptionText": "24",
        "difficulty": "medium",
        "explanation": "The factorial function calculates n! recursively. For n=4: factorial(4) = 4 * factorial(3) = 4 * 3 * factorial(2) = 4 * 3 * 2 * factorial(1) = 4 * 3 * 2 * 1 = 24.",
        "hint": "Trace through each recursive call step by step."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is a lambda function in Python?",
        "options": ["A named function defined with the lambda keyword", "An anonymous function defined with the lambda keyword", "A function that automatically gets executed", "A function that can only return boolean values"],
        "correctOptionIndex": 1,
        "correctOptionText": "An anonymous function defined with the lambda keyword",
        "difficulty": "easy",
        "explanation": "Lambda functions in Python are small, anonymous functions defined with the `lambda` keyword that can have any number of arguments but only one expression.",
        "hint": "These functions are often used when a simple function is needed for a short period of time."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code output?\n```python\nx = 10\ndef foo():\n    print(x)\n\ndef bar():\n    x = 20\n    foo()\n\nbar()\n```",
        "options": ["10", "20", "Error: x is not defined", "None"],
        "correctOptionIndex": 0,
        "correctOptionText": "10",
        "difficulty": "hard",
        "explanation": "Python's LEGB rule (Local, Enclosing, Global, Built-in) determines variable scope. Here, `foo()` doesn't have a local `x`, so it uses the global `x` which is 10. The local `x = 20` in `bar()` doesn't affect `foo()`'s access to the global `x`.",
        "hint": "Consider Python's scoping rules and how functions access variables defined outside their body."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the difference between parameters and arguments in Python functions?",
        "options": ["They are the same thing", "Parameters are defined in the function definition; arguments are the values passed when calling the function", "Parameters are the values passed when calling the function; arguments are defined in the function definition", "Parameters are for simple functions; arguments are for complex functions"],
        "correctOptionIndex": 1,
        "correctOptionText": "Parameters are defined in the function definition; arguments are the values passed when calling the function",
        "difficulty": "easy",
        "explanation": "Parameters are the variables defined in the function declaration, while arguments are the actual values passed to the function when it's called.",
        "hint": "Think about when these terms are used in the function lifecycle."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will this code print?\n```python\ndef change_value(x):\n    x = 10\n    print(f\"Inside function: {x}\")\n\nx = 5\nchange_value(x)\nprint(f\"Outside function: {x}\")\n```",
        "options": ["Inside function: 10\\nOutside function: 10", "Inside function: 5\\nOutside function: 5", "Inside function: 10\\nOutside function: 5", "Inside function: 5\\nOutside function: 10"],
        "correctOptionIndex": 2,
        "correctOptionText": "Inside function: 10\\nOutside function: 5",
        "difficulty": "medium",
        "explanation": "When an immutable object like an integer is passed to a function in Python, changing the parameter inside the function doesn't affect the original variable. This is because integers are passed by value, not by reference.",
        "hint": "Consider how Python handles immutable objects when passed to functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "How would you define a function that can accept any number of positional and keyword arguments?",
        "options": ["def func(*args, **kwargs):", "def func(**kwargs, *args):", "def func(*args, *kwargs):", "def func(&args, &kwargs):"],
        "correctOptionIndex": 0,
        "correctOptionText": "def func(*args, **kwargs):",
        "difficulty": "medium",
        "explanation": "In Python, `*args` collects extra positional arguments as a tuple, and `**kwargs` collects extra keyword arguments as a dictionary. Together, they allow a function to accept any number of both types of arguments.",
        "hint": "There's a specific syntax for collecting multiple positional and keyword arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the output of the following code?\n```python\ndef myfunc(a, b=5, c=10):\n    print(a, b, c)\n\nmyfunc(1, c=15)\n```",
        "options": ["1 5 10", "1, 5, 15", "1 5 15", "Error: c cannot be specified without b"],
        "correctOptionIndex": 2,
        "correctOptionText": "1 5 15",
        "difficulty": "medium",
        "explanation": "When calling a function, you can specify values for some default parameters and leave others to use their default values. Here, `a=1` (positional), `b` uses its default value of 5, and `c=15` (specified by name).",
        "hint": "Default parameters can be overridden selectively by name."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code output?\n```python\ndef func(x=[]):\n    x.append(1)\n    return x\n\nprint(func())\nprint(func())\n```",
        "options": ["[1], [1]", "[1], [1, 1]", "[1, 1], [1, 1, 1]", "[1], []"],
        "correctOptionIndex": 1,
        "correctOptionText": "[1], [1, 1]",
        "difficulty": "hard",
        "explanation": "Default parameter values in Python are evaluated only once at function definition time. Since lists are mutable, the same list object is used for both calls. The first call adds 1 to the empty list, and the second call adds another 1 to the already modified list.",
        "hint": "Consider the potential pitfalls when using mutable objects as default parameters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will this code print?\n```python\ndefault_scope = 'Global'\n\ndef outer_func():\n    default_scope = 'Enclosed'\n    def inner_func():\n        return default_scope\n    return inner_func\n\nmy_func = outer_func()\nprint(my_func())\n```",
        "options": ["Global", "Enclosed", "Error: default_scope is not defined", "None"],
        "correctOptionIndex": 1,
        "correctOptionText": "Enclosed",
        "difficulty": "hard",
        "explanation": "This demonstrates a closure where the inner function captures the variable environment of its enclosing function. When `inner_func` is returned and later called, it remembers `default_scope` from the scope of `outer_func`, not the global scope.",
        "hint": "Consider Python's LEGB rule and how closures maintain their lexical environment."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What does the following function do?\n```python\ndef apply(func, value):\n    return func(value)\n```",
        "options": ["Nothing useful", "Creates a new function", "Takes a function and applies it to a value", "Always returns None"],
        "correctOptionIndex": 2,
        "correctOptionText": "Takes a function and applies it to a value",
        "difficulty": "medium",
        "explanation": "This is an example of a higher-order function that takes another function as an argument and calls it with the provided value. Higher-order functions treat functions as first-class objects that can be passed around like any other value.",
        "hint": "Functions in Python can be passed as arguments to other functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the purpose of the `global` keyword in Python functions?",
        "options": ["To create global variables", "To declare that a variable is globally accessible", "To modify a global variable from within a function", "To import global modules"],
        "correctOptionIndex": 2,
        "correctOptionText": "To modify a global variable from within a function",
        "difficulty": "medium",
        "explanation": "By default, assigning to a variable within a function creates a new local variable. The `global` keyword tells Python that assignments to the named variable should modify the globally-defined variable instead of creating a new local one.",
        "hint": "It's related to variable scope and assignment behavior within functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code print?\n```python\ndef countdown(n):\n    if n <= 0:\n        return 'Blastoff!'\n    return countdown(n-1)\n\nprint(countdown(3))\n```",
        "options": ["3", "2", "1", "Blastoff!"],
        "correctOptionIndex": 3,
        "correctOptionText": "Blastoff!",
        "difficulty": "medium",
        "explanation": "This is a recursive function that calls itself with a decremented value until n reaches 0. At that point, it returns 'Blastoff!'. Since there are no statements after the recursive calls, the final return value 'Blastoff!' propagates all the way back up through the call stack.",
        "hint": "Follow the recursion through each step and consider what's returned when the base case is reached."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is a decorator in Python?",
        "options": ["A design pattern for organizing code", "A function that takes another function and extends its behavior without modifying it", "A way to add comments to functions", "A method for naming functions"],
        "correctOptionIndex": 1,
        "correctOptionText": "A function that takes another function and extends its behavior without modifying it",
        "difficulty": "hard",
        "explanation": "Decorators in Python are functions that take another function as input and return a new function that usually extends or modifies the behavior of the input function, without changing its source code.",
        "hint": "Decorators are a powerful feature for adding functionality to existing functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code output?\n```python\ndef make_multiplier(factor):\n    def multiply(number):\n        return number * factor\n    return multiply\n\ntimes_two = make_multiplier(2)\nprint(times_two(5))\n```",
        "options": ["2", "5", "7", "10"],
        "correctOptionIndex": 3,
        "correctOptionText": "10",
        "difficulty": "hard",
        "explanation": "This code creates a closure. The `make_multiplier` function returns a new function that multiplies its argument by the `factor` specified. With `times_two = make_multiplier(2)`, we create a function that multiplies by 2. Calling `times_two(5)` returns 5 * 2 = 10.",
        "hint": "The returned function remembers the value of `factor` from its creation environment."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What's the difference between `return` and `yield` in Python functions?",
        "options": ["They are synonyms", "return produces a single value, yield produces a sequence of values", "yield can only be used in loops, return anywhere", "return is for functions, yield is for methods"],
        "correctOptionIndex": 1,
        "correctOptionText": "return produces a single value, yield produces a sequence of values",
        "difficulty": "hard",
        "explanation": "The `return` statement exits a function and provides a value back to the caller. The `yield` statement temporarily suspends function execution, preserving state, and returns a value in a generator, allowing the function to resume where it left off when called again.",
        "hint": "One is used in regular functions, the other creates generator functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the output of this function?\n```python\ndef strange_function(x):\n    if x <= 0:\n        return 0\n    print(x, end=' ')\n    strange_function(x-1)\n    print(x, end=' ')\n\nstrange_function(3)\n```",
        "options": ["3 2 1 0", "3 2 1 1 2 3", "3 2 1 0 1 2 3", "3 2 1 3 2 1"],
        "correctOptionIndex": 1,
        "correctOptionText": "3 2 1 1 2 3",
        "difficulty": "hard",
        "explanation": "This recursive function prints the value of x before and after the recursive call. For x=3, it prints 3, then calls itself with x=2, prints 2, then calls with x=1, prints 1, then calls with x=0 (which just returns 0 without printing). Then each call completes and prints the value of x again in reverse order: 1, 2, 3.",
        "hint": "Trace the execution stack and note when each print statement is executed."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the nonlocal keyword used for in Python?",
        "options": ["To access variables from the global scope", "To declare new variables in the global scope", "To modify variables from the enclosing (non-global) scope", "To prevent variable access from nested functions"],
        "correctOptionIndex": 2,
        "correctOptionText": "To modify variables from the enclosing (non-global) scope",
        "difficulty": "hard",
        "explanation": "The `nonlocal` keyword is used inside nested functions to indicate that a variable refers to a previously bound variable in the nearest enclosing scope, excluding the global scope. It allows modification of variables in outer functions from within nested functions.",
        "hint": "It's particularly useful when working with nested functions and closures."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is a generator function in Python?",
        "options": ["A function that creates new functions", "A function that uses the 'yield' keyword to return values one at a time", "A function that generates random numbers", "A function that can only be called once"],
        "correctOptionIndex": 1,
        "correctOptionText": "A function that uses the 'yield' keyword to return values one at a time",
        "difficulty": "medium",
        "explanation": "Generator functions in Python use the `yield` statement to return values one at a time, maintaining their state between calls. This allows for efficient iteration over large data sets without loading everything into memory at once.",
        "hint": "These special functions produce iterators that can be consumed one value at a time."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will the following code output?\n```python\ndef func(a, b, *, c=5, d):\n    return a + b + c + d\n\nprint(func(1, 2, d=3))\n```",
        "options": ["6", "11", "Error: TypeError", "10"],
        "correctOptionIndex": 1,
        "correctOptionText": "11",
        "difficulty": "hard",
        "explanation": "The asterisk (`*`) in the function definition indicates that all parameters after it must be specified by keyword. In this call, `a=1` and `b=2` are positional arguments, `c` uses its default value of 5, and `d=3` is provided as a keyword argument. The function returns 1 + 2 + 5 + 3 = 11.",
        "hint": "The asterisk in the parameter list forces keyword-only arguments for parameters that follow it."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What are keywords used to exit a function?",
        "options": ["break", "return", "pass", "exit"],
        "correctOptionIndex": 1,
        "correctOptionText": "return",
        "difficulty": "easy",
        "explanation": "The `return` statement is used to exit a function and optionally return a value. It immediately terminates the function execution and passes control back to the caller.",
        "hint": "This statement can appear anywhere in a function to stop execution and provide a result."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What will this code print?\n```python\ndef print_args(*args, **kwargs):\n    print(f\"Positional: {args}\")\n    print(f\"Keyword: {kwargs}\")\n\nprint_args(1, 2, a=3, b=4)\n```",
        "options": ["Positional: (1, 2)\\nKeyword: {'a': 3, 'b': 4}", "Positional: [1, 2]\\nKeyword: {'a': 3, 'b': 4}", "Positional: 1, 2\\nKeyword: a=3, b=4", "Error: mixed positional and keyword arguments"],
        "correctOptionIndex": 0,
        "correctOptionText": "Positional: (1, 2)\\nKeyword: {'a': 3, 'b': 4}",
        "difficulty": "medium",
        "explanation": "The function collects all positional arguments into a tuple named `args` (which contains 1 and 2) and all keyword arguments into a dictionary named `kwargs` (which contains keys 'a' and 'b' with values 3 and 4).",
        "hint": "The `*args` parameter collects positional arguments into a tuple, while `**kwargs` collects keyword arguments into a dictionary."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is function composition in Python?",
        "options": ["Combining two or more functions to create a new function", "Writing functions inside other functions", "Using functions as parameters", "Using lambda functions"],
        "correctOptionIndex": 0,
        "correctOptionText": "Combining two or more functions to create a new function",
        "difficulty": "hard",
        "explanation": "Function composition is a concept from mathematics where the output of one function becomes the input of another function, effectively creating a new function. In Python, this can be implemented using nested function calls, higher-order functions, or decorators.",
        "hint": "It's about creating pipelines where data flows through multiple operations sequentially."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Functions",
        "questionText": "What is the correct way to call a function defined as `def process(data, *, format='json', strict=False):`?",
        "options": ["process([1,2,3], 'xml', True)", "process([1,2,3], format='xml', strict=True)", "process(data=[1,2,3], format='xml', strict=True)", "process([1,2,3], 'xml', strict=True)"],
        "correctOptionIndex": 1,
        "correctOptionText": "process([1,2,3], format='xml', strict=True)",
        "difficulty": "medium",
        "explanation": "The asterisk in the function definition indicates that parameters after it must be specified by keyword. The data parameter can be passed positionally, but format and strict must be passed as keyword arguments.",
        "hint": "The asterisk in the function definition creates keyword-only parameters."
    },
    
    // Object-Oriented Programming
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the correct syntax to define a class in Python?",
        "options": ["struct MyClass {}", "class MyClass:", "define class MyClass:", "MyClass = class():"],
        "correctOptionIndex": 1,
        "correctOptionText": "class MyClass:",
        "difficulty": "easy",
        "explanation": "In Python, classes are defined using the `class` keyword followed by the class name and a colon. The class body is then indented below this line.",
        "hint": "Python uses a specific keyword to start class definitions, similar to how functions are defined."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What method is automatically called when a new object is created from a class?",
        "options": ["__new__()", "__init__()", "__create__()", "__start__()"],
        "correctOptionIndex": 1,
        "correctOptionText": "__init__()",
        "difficulty": "easy",
        "explanation": "The `__init__()` method is Python's constructor method that is automatically called when a new instance of a class is created. It's used to initialize the attributes of the new object.",
        "hint": "This special method initializes new instances of a class."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the first parameter in a method definition typically called?",
        "options": ["this", "self", "instance", "object"],
        "correctOptionIndex": 1,
        "correctOptionText": "self",
        "difficulty": "easy",
        "explanation": "By convention, the first parameter in a Python method definition is called `self`. It refers to the instance of the class on which the method is being called.",
        "hint": "This parameter refers to the instance itself and is used to access instance variables and methods."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is inheritance in object-oriented programming?",
        "options": ["A way to create multiple objects from a single class", "A way to restrict access to class attributes", "A way for a class to adopt properties and behaviors from another class", "A way to destroy objects when they are no longer needed"],
        "correctOptionIndex": 2,
        "correctOptionText": "A way for a class to adopt properties and behaviors from another class",
        "difficulty": "medium",
        "explanation": "Inheritance is a fundamental concept in OOP where a new class (subclass) can be based on an existing class (superclass), inheriting its attributes and methods. This promotes code reuse and establishes a hierarchical relationship between classes.",
        "hint": "This concept allows for code reuse and the creation of class hierarchies."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass Person:\n    def __init__(self, name):\n        self.name = name\n        \n    def greet(self):\n        return f\"Hello, my name is {self.name}\"\n\np = Person(\"Alice\")\nprint(p.greet())\n```",
        "options": ["Hello, my name is", "Hello, my name is self.name", "Hello, my name is Alice", "Error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Hello, my name is Alice",
        "difficulty": "easy",
        "explanation": "The code creates an instance of Person with the name 'Alice'. When the greet() method is called on this instance, it returns a string with the instance's name value interpolated into it.",
        "hint": "The `self.name` attribute is set during initialization and then accessed in the greet method."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the correct syntax for defining a subclass in Python?",
        "options": ["class SubClass inherits SuperClass:", "class SubClass(SuperClass):", "class SubClass extends SuperClass:", "class SubClass implements SuperClass:"],
        "correctOptionIndex": 1,
        "correctOptionText": "class SubClass(SuperClass):",
        "difficulty": "easy",
        "explanation": "In Python, inheritance is implemented by putting the parent class name in parentheses after the child class name in the class definition.",
        "hint": "Python uses parentheses in the class definition to specify inheritance relationships."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is encapsulation in object-oriented programming?",
        "options": ["The ability of a class to take on multiple forms", "The practice of keeping fields within a class private and providing access via public methods", "The process of defining multiple methods with the same name but different parameters", "The mechanism by which one class acquires the properties of another class"],
        "correctOptionIndex": 1,
        "correctOptionText": "The practice of keeping fields within a class private and providing access via public methods",
        "difficulty": "medium",
        "explanation": "Encapsulation is the bundling of data and methods that operate on that data within a single unit (class). It often involves restricting direct access to the internal state of an object and requiring all interactions to occur through well-defined interfaces.",
        "hint": "This principle helps hide implementation details and protect object state."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What does the following code demonstrate?\n```python\nclass Animal:\n    def speak(self):\n        pass\n\nclass Dog(Animal):\n    def speak(self):\n        return \"Woof!\"\n\nclass Cat(Animal):\n    def speak(self):\n        return \"Meow!\"\n\ndef make_speak(animal):\n    return animal.speak()\n\nprint(make_speak(Dog()))\nprint(make_speak(Cat()))\n```",
        "options": ["Inheritance", "Encapsulation", "Polymorphism", "Abstraction"],
        "correctOptionIndex": 2,
        "correctOptionText": "Polymorphism",
        "difficulty": "medium", 
        "explanation": "This code demonstrates polymorphism, where different classes (Dog and Cat) implement the same method (speak) from their parent class (Animal) in different ways. The make_speak function treats all animals polymorphically - it calls speak() without knowing the specific animal type.",
        "hint": "This OOP concept allows objects of different types to be treated through a common interface."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the purpose of the `super()` function in Python?",
        "options": ["To create a superclass", "To declare a method as superior to others", "To call methods from a parent class", "To make a class attribute accessible globally"],
        "correctOptionIndex": 2,
        "correctOptionText": "To call methods from a parent class",
        "difficulty": "medium",
        "explanation": "The `super()` function in Python is used within a derived class to call a method from the parent class. This is particularly useful when you want to extend the functionality of a parent class method rather than completely replace it.",
        "hint": "It allows subclasses to access and utilize methods defined in their parent classes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass Counter:\n    count = 0\n    \n    def __init__(self):\n        Counter.count += 1\n        \nc1 = Counter()\nc2 = Counter()\nc3 = Counter()\nprint(Counter.count)\n```",
        "options": ["0", "1", "3", "Error"],
        "correctOptionIndex": 2,
        "correctOptionText": "3",
        "difficulty": "medium",
        "explanation": "In this code, `count` is a class variable shared among all instances of the Counter class. Each time a new Counter object is created, the __init__ method increments this shared count. After creating three objects, the count is 3.",
        "hint": "Pay attention to whether variables are defined at the class level or instance level."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is method overriding in Python?",
        "options": ["Defining multiple methods with the same name in a single class", "Creating a new instance method with the same name as a class method", "Providing a different implementation of a method in a subclass that is already defined in the parent class", "Using the same method name for different purposes in unrelated classes"],
        "correctOptionIndex": 2,
        "correctOptionText": "Providing a different implementation of a method in a subclass that is already defined in the parent class",
        "difficulty": "medium",
        "explanation": "Method overriding occurs when a subclass provides a specific implementation of a method that is already defined in its parent class. When the method is called on an instance of the subclass, the subclass's implementation is executed rather than the parent class's implementation.",
        "hint": "This allows subclasses to change the behavior of methods inherited from parent classes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What does the @classmethod decorator do in Python?",
        "options": ["Makes a method private", "Allows a method to be called on the class rather than an instance", "Prevents a method from being overridden in subclasses", "Automatically documents the method"],
        "correctOptionIndex": 1,
        "correctOptionText": "Allows a method to be called on the class rather than an instance",
        "difficulty": "medium",
        "explanation": "The @classmethod decorator transforms a method into a class method that can be called on the class itself rather than on an instance. The method receives the class as its first argument (conventionally named 'cls') instead of the instance ('self').",
        "hint": "These methods operate on the class itself rather than specific instances."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass Parent:\n    def __init__(self):\n        self.value = 5\n        \n    def get_value(self):\n        return self.value\n        \nclass Child(Parent):\n    def get_value(self):\n        return self.value * 2\n        \np = Parent()\nc = Child()\nprint(p.get_value())\nprint(c.get_value())\n```",
        "options": ["5, 5", "5, 10", "Error", "None, None"],
        "correctOptionIndex": 1,
        "correctOptionText": "5, 10",
        "difficulty": "medium",
        "explanation": "The Parent class initializes `value` to 5 and returns it in get_value(). The Child class inherits this initialization but overrides get_value() to return twice the value. So the Parent instance returns 5, while the Child instance returns 10.",
        "hint": "Notice how the Child class inherits attributes from Parent but overrides the method behavior."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the purpose of the @staticmethod decorator in Python?",
        "options": ["To prevent a method from being modified", "To create a method that doesn't access class or instance attributes", "To make a method available only in static typed code", "To optimize method execution speed"],
        "correctOptionIndex": 1,
        "correctOptionText": "To create a method that doesn't access class or instance attributes",
        "difficulty": "medium",
        "explanation": "The @staticmethod decorator defines a method that doesn't access class or instance state. Static methods don't receive the implicit first argument (self or cls) and behave like regular functions that happen to be defined inside a class for organizational purposes.",
        "hint": "These methods don't operate on instances or the class itself."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the difference between a class variable and an instance variable in Python?",
        "options": ["Class variables are declared with the 'class' keyword, instance variables with the 'instance' keyword", "Class variables are shared among all instances of a class, instance variables are unique to each instance", "Class variables can only hold simple types, instance variables can hold any type", "Class variables are always public, instance variables can be private"],
        "correctOptionIndex": 1,
        "correctOptionText": "Class variables are shared among all instances of a class, instance variables are unique to each instance",
        "difficulty": "medium",
        "explanation": "Class variables are defined at the class level and shared across all instances. Any change to a class variable affects all instances. Instance variables are defined within methods (typically __init__) using self and are unique to each instance of the class.",
        "hint": "Think about whether the data should be shared across all objects of a class or specific to each object."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What does the __str__ method do in a Python class?",
        "options": ["Converts an object to a string type", "Returns a string representation of the object for end users", "Defines how the class constructor works with string arguments", "Creates a string instance variable"],
        "correctOptionIndex": 1,
        "correctOptionText": "Returns a string representation of the object for end users",
        "difficulty": "medium",
        "explanation": "The __str__ method in Python defines what should be returned when str() is called on an object or when print() is used with the object. It's intended to provide a human-readable string representation of the object.",
        "hint": "This special method is called by built-in functions that need a string representation of an object."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass MyClass:\n    def __init__(self, value):\n        self._value = value\n        \n    @property\n    def value(self):\n        return self._value\n        \n    @value.setter\n    def value(self, new_value):\n        if new_value > 0:\n            self._value = new_value\n        \nobj = MyClass(10)\nobj.value = -5\nprint(obj.value)\n```",
        "options": ["-5", "10", "0", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "10",
        "difficulty": "hard",
        "explanation": "This code demonstrates property decorators in Python. The @property creates a getter method, while @value.setter creates a setter method. The setter validates that new values must be positive. When attempting to set a negative value (-5), the validation fails and the value remains unchanged at 10.",
        "hint": "Pay attention to the validation in the setter method and what happens when the condition isn't met."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the purpose of Python's __repr__ method?",
        "options": ["To repeat an object multiple times", "To provide a developer-oriented string representation of an object", "To represent private methods in a class", "To control how objects are replicated"],
        "correctOptionIndex": 1,
        "correctOptionText": "To provide a developer-oriented string representation of an object",
        "difficulty": "hard",
        "explanation": "The __repr__ method returns a string representation of an object that should ideally be valid Python code that could recreate the object. It's meant to be unambiguous and used for debugging and development, while __str__ is meant for end users.",
        "hint": "This method is called by the repr() function and should return a string that helps developers understand the object state."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is multiple inheritance in Python?",
        "options": ["When a class can be instantiated multiple times", "When a class inherits from multiple parent classes", "When multiple classes inherit from a single parent class", "When a class has multiple methods with the same name"],
        "correctOptionIndex": 1,
        "correctOptionText": "When a class inherits from multiple parent classes",
        "difficulty": "hard",
        "explanation": "Multiple inheritance is when a class inherits attributes and methods from more than one parent class. In Python syntax, this is done by listing multiple parent classes in parentheses in the class definition: `class Child(Parent1, Parent2):`.",
        "hint": "This feature allows a class to combine features from multiple parent classes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the Method Resolution Order (MRO) in Python?",
        "options": ["The order in which methods are defined in a class", "The sequence of method calls within a program", "The priority of method execution based on their return types", "The order in which Python searches for methods in a hierarchy of classes"],
        "correctOptionIndex": 3,
        "correctOptionText": "The order in which Python searches for methods in a hierarchy of classes",
        "difficulty": "hard",
        "explanation": "Method Resolution Order (MRO) defines the path Python follows when looking for methods in a hierarchy of classes, especially important in multiple inheritance scenarios. Python uses the C3 linearization algorithm to determine MRO, which ensures a consistent and logical order.",
        "hint": "This is particularly important when dealing with complex inheritance hierarchies in Python."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "Which of the following accurately describes Python's approach to private attributes?",
        "options": ["Python has built-in private access modifiers like private and protected", "Python has no true private attributes; naming conventions and name mangling are used instead", "Private attributes in Python can only be accessed using getter and setter methods", "Python disallows any access to private attributes from outside the class"],
        "correctOptionIndex": 1,
        "correctOptionText": "Python has no true private attributes; naming conventions and name mangling are used instead",
        "difficulty": "hard",
        "explanation": "Python doesn't have strict access control mechanisms like some other languages. Instead, it uses naming conventions (prefixing with underscore _) to indicate private attributes and name mangling (prefixing with double underscore __) to make attribute names less accessible but not truly private.",
        "hint": "Python favors a philosophy of 'we're all consenting adults here' when it comes to encapsulation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass A:\n    def __init__(self):\n        self.__x = 1\n        \n    def get_x(self):\n        return self.__x\n        \nclass B(A):\n    def __init__(self):\n        super().__init__()\n        self.__x = 2\n        \n    def get_original_x(self):\n        return super().get_x()\n        \nb = B()\nprint(b.get_x())\nprint(b.get_original_x())\n```",
        "options": ["1, 1", "2, 2", "1, 2", "2, 1"],
        "correctOptionIndex": 3,
        "correctOptionText": "2, 1",
        "difficulty": "hard",
        "explanation": "This demonstrates name mangling in Python. When an attribute name starts with double underscores (__), Python mangles the name by prefixing it with _classname. So __x in class A becomes _A__x and __x in class B becomes _B__x - they're actually different attributes. b.get_x() returns the parent class's unmangled _A__x (1), while get_original_x() returns the parent's method result (1).",
        "hint": "Consider how Python's name mangling works with double underscore attributes in inheritance hierarchies."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is duck typing in Python?",
        "options": ["A way to define class hierarchies", "A testing methodology for object-oriented code", "A programming concept where object type is determined by its behavior rather than its class", "A way to convert objects to primitive data types"],
        "correctOptionIndex": 2,
        "correctOptionText": "A programming concept where object type is determined by its behavior rather than its class",
        "difficulty": "hard",
        "explanation": "Duck typing is a programming concept where the suitability of an object for a particular purpose is determined by the presence of certain methods or properties, rather than the type of the object itself. The name comes from the saying, 'If it walks like a duck and quacks like a duck, then it's a duck.'",
        "hint": "This concept focuses on what an object can do rather than what it is."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is a mixin class in Python?",
        "options": ["A class that combines features of multiple classes", "A class that gets 'mixed in' to add functionality to another class without full inheritance", "A class that allows mixing of different data types", "A class that can be instantiated multiple ways"],
        "correctOptionIndex": 1,
        "correctOptionText": "A class that gets 'mixed in' to add functionality to another class without full inheritance",
        "difficulty": "hard",
        "explanation": "A mixin is a special kind of class that's designed to provide additional functionality to other classes through multiple inheritance. Unlike full inheritance, mixins are not meant to be instantiated on their own and typically don't have an __init__ method. They're used to 'mix in' specific behaviors or methods into other classes.",
        "hint": "Mixins are a design pattern that helps avoid deep inheritance hierarchies while promoting code reuse."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is the purpose of the __new__ method in Python?",
        "options": ["To create brand new attributes for an object", "To control the instantiation process before __init__ is called", "To make a class newable with the new keyword", "To define new methods at runtime"],
        "correctOptionIndex": 1,
        "correctOptionText": "To control the instantiation process before __init__ is called",
        "difficulty": "hard",
        "explanation": "The __new__ method in Python is a static method responsible for creating and returning a new instance of a class. It's called before __init__ and actually creates the instance which __init__ then initializes. This allows for customization of the instance creation process itself.",
        "hint": "This special method gives you control over the creation of instances, not just their initialization."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What are abstract classes in Python?",
        "options": ["Classes that can't be instantiated directly and are meant to be subclassed", "Classes that have complex or abstract concepts as attributes", "Classes that are defined outside the main code structure", "Classes that can only contain static methods"],
        "correctOptionIndex": 0,
        "correctOptionText": "Classes that can't be instantiated directly and are meant to be subclassed",
        "difficulty": "hard",
        "explanation": "Abstract classes in Python serve as blueprints for other classes. They can't be instantiated directly and typically contain one or more abstract methods (methods without an implementation). In Python, abstract classes are created using the ABC module (Abstract Base Classes).",
        "hint": "These classes define interfaces that derived classes must implement."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass Meta(type):\n    def __new__(cls, name, bases, attrs):\n        print(f\"Creating class: {name}\")\n        return super().__new__(cls, name, bases, attrs)\n\nclass MyClass(metaclass=Meta):\n    pass\n\nprint(\"Class defined\")\n```",
        "options": ["Class defined", "Creating class: MyClass\\nClass defined", "Creating class: Meta\\nClass defined", "Error: metaclass is not defined"],
        "correctOptionIndex": 1,
        "correctOptionText": "Creating class: MyClass\\nClass defined",
        "difficulty": "hard",
        "explanation": "This code demonstrates metaclasses in Python. A metaclass is the class of a class - it defines how classes themselves are constructed. When Python encounters a class definition with a specified metaclass, it uses that metaclass to create the class. Here, the Meta metaclass's __new__ method prints a message when creating MyClass.",
        "hint": "Metaclasses control the creation of classes, just as classes control the creation of instances."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "Which design pattern does the following code implement?\n```python\nclass Singleton:\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n```",
        "options": ["Factory", "Observer", "Singleton", "Adapter"],
        "correctOptionIndex": 2,
        "correctOptionText": "Singleton",
        "difficulty": "hard",
        "explanation": "This code implements the Singleton design pattern, which restricts a class to having only one instance throughout the program's lifecycle. The __new__ method checks if an instance already exists; if not, it creates one, and if yes, it returns the existing instance.",
        "hint": "This pattern ensures that a class has only one instance while providing a global point of access to it."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is composition in object-oriented programming?",
        "options": ["A way to combine multiple inheritance hierarchies", "A design principle that favors object composition over class inheritance", "The practice of combining simple objects to build more complex ones", "A technique for composing methods from multiple classes"],
        "correctOptionIndex": 2,
        "correctOptionText": "The practice of combining simple objects to build more complex ones",
        "difficulty": "medium",
        "explanation": "Composition is a design principle where classes contain instances of other classes to reuse their functionality rather than inheriting from them. It represents a 'has-a' relationship rather than an 'is-a' relationship. For example, a Car class might have Engine and Wheels objects as attributes.",
        "hint": "Think about the distinction between 'is-a' versus 'has-a' relationships between objects."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What will the following code output?\n```python\nclass Person:\n    def __init__(self, name):\n        self.name = name\n    \n    def __eq__(self, other):\n        if not isinstance(other, Person):\n            return False\n        return self.name == other.name\n    \np1 = Person(\"John\")\np2 = Person(\"John\")\np3 = p1\n\nprint(p1 == p2)\nprint(p1 is p2)\nprint(p1 is p3)\n```",
        "options": ["True\\nTrue\\nTrue", "True\\nFalse\\nTrue", "False\\nFalse\\nTrue", "False\\nTrue\\nFalse"],
        "correctOptionIndex": 1,
        "correctOptionText": "True\\nFalse\\nTrue",
        "difficulty": "hard",
        "explanation": "This code shows the difference between equality (==) and identity (is) in Python. The __eq__ method is overridden to compare Person objects by their name attribute. p1 and p2 have the same name, so p1 == p2 is True. However, they are different objects in memory, so p1 is p2 is False. p3 is assigned the same object as p1, so p1 is p3 is True.",
        "hint": "The difference between '==' and 'is' operators in Python is that one tests value equality while the other tests object identity."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Object-Oriented Programming",
        "questionText": "What is operator overloading in Python?",
        "options": ["Creating multiple operators with the same functionality", "Defining special methods that are called when operators are used on objects", "Overriding operators from the parent class", "A technique to make operators work faster"],
        "correctOptionIndex": 1,
        "correctOptionText": "Defining special methods that are called when operators are used on objects",
        "difficulty": "medium",
        "explanation": "Operator overloading allows objects to respond to operators like +, -, *, == by defining special methods like __add__, __sub__, __mul__, __eq__. This makes it possible to use these operators with custom objects in ways that make sense for those objects.",
        "hint": "This feature allows you to define how operators behave when applied to instances of your classes."
    },
    // File Handling
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "Which mode is used to open a file for reading in Python?",
        "options": ["'w'", "'r'", "'a'", "'x'"],
        "correctOptionIndex": 1,
        "correctOptionText": "'r'",
        "difficulty": "easy",
        "explanation": "The 'r' mode opens a file for reading. This is the default mode if no mode is specified.",
        "hint": "Think about what 'r' might stand for in file operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "Which method is used to read all lines from a file into a list?",
        "options": ["read()", "readline()", "readlines()", "readall()"],
        "correctOptionIndex": 2,
        "correctOptionText": "readlines()",
        "difficulty": "easy",
        "explanation": "The readlines() method reads all lines from a file and returns them as a list of strings.",
        "hint": "You want to read multiple lines at once, not just one line."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What happens if you try to open a file that doesn't exist using the 'r' mode?",
        "options": ["The file is created automatically", "Nothing happens", "A FileNotFoundError is raised", "The program crashes"],
        "correctOptionIndex": 2,
        "correctOptionText": "A FileNotFoundError is raised",
        "difficulty": "easy",
        "explanation": "When you try to open a non-existent file in read mode, Python raises a FileNotFoundError exception.",
        "hint": "Think about what should happen when you try to read something that doesn't exist."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "Which mode is used to open a file for writing, creating a new file or truncating an existing file?",
        "options": ["'r'", "'w'", "'a'", "'x'"],
        "correctOptionIndex": 1,
        "correctOptionText": "'w'",
        "difficulty": "easy",
        "explanation": "The 'w' mode opens a file for writing. If the file exists, it truncates the file (erases all content). If the file doesn't exist, it creates a new file.",
        "hint": "Think about what 'w' might stand for in file operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "How do you properly close a file in Python?",
        "options": ["file.close()", "file.end()", "close(file)", "file.exit()"],
        "correctOptionIndex": 0,
        "correctOptionText": "file.close()",
        "difficulty": "easy",
        "explanation": "The close() method is used to close an open file. It's important to close files to free up system resources.",
        "hint": "It's a method called on the file object."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "Which statement is the most appropriate way to open and automatically close a file in Python?",
        "options": ["open(file).close()", "using open(file) as f:", "with open(file) as f:", "auto open(file)"],
        "correctOptionIndex": 2,
        "correctOptionText": "with open(file) as f:",
        "difficulty": "easy",
        "explanation": "The 'with' statement is used to automatically close a file after the code block is executed, even if exceptions occur.",
        "hint": "This is a context manager in Python that handles resource cleanup."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What does the 'a' mode do when opening a file?",
        "options": ["Opens for reading only", "Opens for writing, truncating the file first", "Opens for exclusive creation", "Opens for appending to the end of the file"],
        "correctOptionIndex": 3,
        "correctOptionText": "Opens for appending to the end of the file",
        "difficulty": "easy",
        "explanation": "The 'a' mode opens a file for appending. New data is written to the end of the file. The file is created if it doesn't exist.",
        "hint": "Think about what 'a' might stand for in file operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What does the 'b' flag indicate when added to a file mode (e.g., 'rb', 'wb')?",
        "options": ["Big file handling", "Binary mode", "Buffered I/O", "Backup mode"],
        "correctOptionIndex": 1,
        "correctOptionText": "Binary mode",
        "difficulty": "medium",
        "explanation": "The 'b' flag indicates binary mode, which is used for non-text files like images or executable files. It ensures that data is read or written without any text encoding/decoding.",
        "hint": "When dealing with non-text files, this mode is necessary."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the result of the following code?\n\nwith open('example.txt', 'w') as f:\n    f.write('Hello')\nprint(f.closed)",
        "options": ["True", "False", "None", "Error"],
        "correctOptionIndex": 0,
        "correctOptionText": "True",
        "difficulty": "medium",
        "explanation": "The 'with' statement automatically closes the file when exiting the block. Therefore, f.closed will return True after the block is executed.",
        "hint": "Consider what happens to the file object after the 'with' block is finished."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the tell() method in file handling?",
        "options": ["To display file contents", "To return the current position in the file", "To check if a file exists", "To tell the file to close"],
        "correctOptionIndex": 1,
        "correctOptionText": "To return the current position in the file",
        "difficulty": "medium",
        "explanation": "The tell() method returns the current position of the file pointer (as number of bytes from the beginning of the file).",
        "hint": "It's related to tracking your location within a file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What does the seek() method do in Python file handling?",
        "options": ["Searches for a specific string in the file", "Moves the file pointer to a specified position", "Seeks permission to access the file", "Checks if a file exists"],
        "correctOptionIndex": 1,
        "correctOptionText": "Moves the file pointer to a specified position",
        "difficulty": "medium",
        "explanation": "The seek() method changes the position of the file pointer to a specified location, allowing you to read from or write to that position.",
        "hint": "It's used to navigate within a file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the difference between the read() and readline() methods?",
        "options": ["read() reads the entire file, readline() reads one line at a time", "read() reads binary files, readline() reads text files", "read() is faster, readline() is more accurate", "There is no difference"],
        "correctOptionIndex": 0,
        "correctOptionText": "read() reads the entire file, readline() reads one line at a time",
        "difficulty": "medium",
        "explanation": "The read() method reads the entire file content at once, while readline() reads just one line at a time, stopping at the newline character.",
        "hint": "Think about the granularity of what each method returns."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What happens when you use the 'x' mode to open a file?",
        "options": ["Opens for reading only", "Opens for writing, creating a new file", "Opens for exclusive creation, fails if file exists", "Opens for appending"],
        "correctOptionIndex": 2,
        "correctOptionText": "Opens for exclusive creation, fails if file exists",
        "difficulty": "medium",
        "explanation": "The 'x' mode opens a file for exclusive creation. If the file already exists, the operation fails with a FileExistsError.",
        "hint": "This mode is useful when you want to avoid accidentally overwriting existing files."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "If you open a file in 'w+' mode, what operations can you perform?",
        "options": ["Read only", "Write only", "Both read and write", "Neither read nor write"],
        "correctOptionIndex": 2,
        "correctOptionText": "Both read and write",
        "difficulty": "medium",
        "explanation": "The 'w+' mode opens a file for both reading and writing. It truncates the file if it exists or creates a new file if it doesn't.",
        "hint": "The '+' modifier allows additional operations beyond the base mode."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What does the readlines() method return if the file is empty?",
        "options": ["None", "An empty string", "An empty list", "A FileEmptyError"],
        "correctOptionIndex": 2,
        "correctOptionText": "An empty list",
        "difficulty": "medium",
        "explanation": "The readlines() method returns a list of lines from the file. If the file is empty, it returns an empty list [].",
        "hint": "Consider the return type of readlines() and what would be the logical result for an empty file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the default encoding used when opening a text file in Python?",
        "options": ["ASCII", "UTF-8", "UTF-16", "ISO-8859-1"],
        "correctOptionIndex": 1,
        "correctOptionText": "UTF-8",
        "difficulty": "medium",
        "explanation": "By default, Python uses UTF-8 encoding when opening text files. This can be changed by specifying a different encoding parameter.",
        "hint": "This is a modern, widely-used encoding that supports international characters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the os.path.exists() function?",
        "options": ["To create a new file path", "To check if a file or directory exists", "To delete a file", "To rename a file"],
        "correctOptionIndex": 1,
        "correctOptionText": "To check if a file or directory exists",
        "difficulty": "medium",
        "explanation": "The os.path.exists() function returns True if the specified path exists (as a file or directory) and False otherwise.",
        "hint": "It's useful for checking before performing operations on files or directories."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What will the following code print?\n\nwith open('example.txt', 'w') as f:\n    f.write('Hello\\nWorld')\n\nwith open('example.txt', 'r') as f:\n    print(len(f.readlines()))",
        "options": ["1", "2", "5", "11"],
        "correctOptionIndex": 1,
        "correctOptionText": "2",
        "difficulty": "medium",
        "explanation": "The code writes 'Hello\\nWorld' to the file (which contains a newline character), then reads the file as lines. Since there's one newline character, the file has 2 lines, so readlines() returns a list with 2 elements.",
        "hint": "Pay attention to the newline character in the string being written."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the os.path.join() function?",
        "options": ["To combine file contents", "To merge two files", "To concatenate path components using the appropriate separator", "To join two directories into one"],
        "correctOptionIndex": 2,
        "correctOptionText": "To concatenate path components using the appropriate separator",
        "difficulty": "medium",
        "explanation": "The os.path.join() function intelligently joins path components using the appropriate separator for the operating system (/ for Unix/Linux/macOS, \\ for Windows).",
        "hint": "It helps create cross-platform file paths."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the 'a+' mode when opening a file?",
        "options": ["Read-only access", "Write-only access, creates file if it doesn't exist", "Read and write access, creates file if it doesn't exist, appends if it does", "Read and write access, always creates a new file"],
        "correctOptionIndex": 2,
        "correctOptionText": "Read and write access, creates file if it doesn't exist, appends if it does",
        "difficulty": "hard",
        "explanation": "The 'a+' mode opens a file for both reading and appending. It creates the file if it doesn't exist. The file pointer is positioned at the end of the file for writing, but you can move it for reading.",
        "hint": "The '+' modifier enables additional operations, while 'a' determines the initial behavior."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the difference between os.remove() and os.rmdir()?",
        "options": ["os.remove() deletes files, os.rmdir() deletes directories", "os.remove() works on Windows, os.rmdir() works on Unix", "os.remove() is faster, os.rmdir() is more secure", "There is no difference"],
        "correctOptionIndex": 0,
        "correctOptionText": "os.remove() deletes files, os.rmdir() deletes directories",
        "difficulty": "hard",
        "explanation": "os.remove() is used to delete a file, while os.rmdir() is used to delete an empty directory. Using the wrong function for the wrong type will result in an error.",
        "hint": "These functions have different target types of filesystem objects."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What will happen if you try to write a string containing non-ASCII characters to a file opened in text mode without specifying an encoding?",
        "options": ["The string will be written as-is", "Python will raise a UnicodeEncodeError", "The non-ASCII characters will be replaced with '?'", "The file will be corrupted"],
        "correctOptionIndex": 0,
        "correctOptionText": "The string will be written as-is",
        "difficulty": "hard",
        "explanation": "In modern Python versions (3.x), the default encoding is UTF-8, which can handle non-ASCII characters. The string will be written correctly using this encoding.",
        "hint": "Consider Python's default encoding for text files."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the os.path.basename() function?",
        "options": ["To get the base directory of a file", "To get the file extension", "To get the filename from a path", "To create a base path"],
        "correctOptionIndex": 2,
        "correctOptionText": "To get the filename from a path",
        "difficulty": "hard",
        "explanation": "The os.path.basename() function returns the filename from a path. For example, os.path.basename('/path/to/file.txt') returns 'file.txt'.",
        "hint": "It extracts just one component from a full path."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the purpose of the flush() method in file handling?",
        "options": ["To clear the file contents", "To force write of buffered data to the file", "To reset the file pointer to the beginning", "To check if the file is empty"],
        "correctOptionIndex": 1,
        "correctOptionText": "To force write of buffered data to the file",
        "difficulty": "hard",
        "explanation": "The flush() method forces the write of any buffered data to the file without closing it. This is useful when you want to ensure data is written to disk immediately.",
        "hint": "It's related to the buffer management of file writing operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the correct way to read a binary file in Python?",
        "options": ["open(file, 'r')", "open(file, 'rb')", "open(file, 'binary')", "open(file, 'b')"],
        "correctOptionIndex": 1,
        "correctOptionText": "open(file, 'rb')",
        "difficulty": "hard",
        "explanation": "To read a binary file, you need to use the 'rb' mode (read binary). This prevents any text encoding/decoding and treats the file as raw bytes.",
        "hint": "You need to combine the reading mode with a flag for binary operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What will the following code print?\n\nwith open('example.txt', 'w') as f:\n    f.write('Line1\\nLine2\\nLine3')\n\nwith open('example.txt', 'r') as f:\n    f.seek(6)\n    print(f.read(5))",
        "options": ["Line1", "Line2", "\\nLin", "e2\\nL"],
        "correctOptionIndex": 3,
        "correctOptionText": "e2\\nL",
        "difficulty": "hard",
        "explanation": "The code writes 'Line1\\nLine2\\nLine3' to the file. Then, it opens the file for reading, moves the pointer to position 6 (which is after 'Line1\\n'), and reads 5 characters, which are 'e2\\nL'.",
        "hint": "Count the characters carefully, including the newline character."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the default value of the 'buffering' parameter in the open() function?",
        "options": ["0 (no buffering)", "1 (line buffering)", "-1 (default buffering)", "4096 bytes"],
        "correctOptionIndex": 2,
        "correctOptionText": "-1 (default buffering)",
        "difficulty": "hard",
        "explanation": "The default value of the 'buffering' parameter is -1, which means the system default buffering is used. For binary files, this is typically a large buffer, and for text files, it's usually line buffering.",
        "hint": "This setting determines how data is buffered when reading from or writing to files."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What is the difference between shutil.copy() and shutil.copyfile()?",
        "options": ["shutil.copy() is faster, shutil.copyfile() is more accurate", "shutil.copy() copies the file content and permission bits, shutil.copyfile() only copies the content", "shutil.copy() works on directories, shutil.copyfile() works on files", "There is no difference"],
        "correctOptionIndex": 1,
        "correctOptionText": "shutil.copy() copies the file content and permission bits, shutil.copyfile() only copies the content",
        "difficulty": "hard",
        "explanation": "shutil.copy() copies the file content and the file's permission mode. shutil.copyfile() only copies the content of the file, not the permission bits or other metadata.",
        "hint": "One function preserves more information about the original file than the other."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What will the following code print?\n\nwith open('example.txt', 'w') as f:\n    print('Hello', file=f)\n    print('World', file=f)\n\nwith open('example.txt', 'r') as f:\n    content = f.read()\n    print(len(content))",
        "options": ["10", "11", "12", "13"],
        "correctOptionIndex": 2,
        "correctOptionText": "12",
        "difficulty": "hard",
        "explanation": "The code writes 'Hello\\nWorld\\n' to the file. The print() function adds a newline character after each string. So, the file contains 'Hello\\nWorld\\n', which is 12 characters in total (5 + 1 + 5 + 1).",
        "hint": "Remember that print() adds a newline character by default."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "File Handling",
        "questionText": "What does the 'U' mode (or 'rU') do when opening a file?",
        "options": ["Opens the file in update mode", "Opens the file in Unicode mode", "Opens the file in universal newline mode", "Opens the file in unlimited read mode"],
        "correctOptionIndex": 2,
        "correctOptionText": "Opens the file in universal newline mode",
        "difficulty": "hard",
        "explanation": "The 'U' mode (or 'rU') opens the file in universal newline mode, which translates different types of line endings (\\n, \\r, or \\r\\n) to a standard form (\\n). This mode is deprecated in Python 3, as this is now the default behavior for text files.",
        "hint": "It's related to handling different line ending conventions across operating systems."
    },
      
    // Modules & Packages
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What keyword is used to import a module in Python?",
        "options": ["include", "import", "require", "use"],
        "correctOptionIndex": 1,
        "correctOptionText": "import",
        "difficulty": "easy",
        "explanation": "The 'import' keyword is used to import modules in Python, making their functions, classes, and variables available in the current script.",
        "hint": "This is a fundamental Python keyword that brings external code into your program."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the correct way to import only the sqrt function from the math module?",
        "options": ["import math.sqrt", "from math get sqrt", "from math import sqrt", "using math.sqrt"],
        "correctOptionIndex": 2,
        "correctOptionText": "from math import sqrt",
        "difficulty": "easy",
        "explanation": "The 'from module import name' syntax allows you to import specific functions, classes, or variables from a module directly into your current namespace.",
        "hint": "This syntax lets you use the function directly without the module prefix."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of the __init__.py file in a package directory?",
        "options": ["To initialize variables", "To mark a directory as a Python package", "To document the package", "To store package metadata"],
        "correctOptionIndex": 1,
        "correctOptionText": "To mark a directory as a Python package",
        "difficulty": "easy",
        "explanation": "The __init__.py file is required to make Python treat a directory as a package. It can be empty or contain initialization code for the package.",
        "hint": "This special file helps Python identify and organize code structures."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What will be printed by this code?\n\nimport math\nprint(math.__name__)",
        "options": ["'__name__'", "'__main__'", "'math'", "Error"],
        "correctOptionIndex": 2,
        "correctOptionText": "'math'",
        "difficulty": "easy",
        "explanation": "The __name__ attribute of a module contains the name of the module as a string. For the math module, it's 'math'.",
        "hint": "This special attribute tells you the module's identifier in Python."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the correct way to alias a module during import?",
        "options": ["import module as alias", "from module use alias", "import alias for module", "module import as alias"],
        "correctOptionIndex": 0,
        "correctOptionText": "import module as alias",
        "difficulty": "easy",
        "explanation": "The 'import module as alias' syntax allows you to use a shorter or different name to refer to the module in your code.",
        "hint": "This is commonly used for modules with long names, like 'import numpy as np'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the difference between a module and a package in Python?",
        "options": ["Modules contain code, packages contain data", "Modules are compiled, packages are interpreted", "A module is a single file, a package is a directory with modules", "There is no difference"],
        "correctOptionIndex": 2,
        "correctOptionText": "A module is a single file, a package is a directory with modules",
        "difficulty": "easy",
        "explanation": "A module is a single Python file containing code, while a package is a directory containing multiple modules and potentially sub-packages, typically with an __init__.py file.",
        "hint": "Think about the physical structure of these components in the file system."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "How can you import all names from a module at once?",
        "options": ["import all from module", "from module import *", "import module.*", "using module.*"],
        "correctOptionIndex": 1,
        "correctOptionText": "from module import *",
        "difficulty": "easy",
        "explanation": "The 'from module import *' syntax imports all public names from a module directly into your current namespace. However, this is generally not recommended as it can lead to namespace pollution.",
        "hint": "The wildcard character is used to represent 'all' items."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What happens if you import the same module multiple times in a Python script?",
        "options": ["The module is loaded each time, creating multiple instances", "Python raises an ImportError", "The module is loaded only once, subsequent imports reuse the first import", "The most recent import overwrites previous imports"],
        "correctOptionIndex": 2,
        "correctOptionText": "The module is loaded only once, subsequent imports reuse the first import",
        "difficulty": "medium",
        "explanation": "Python's import system is designed to load each module only once per interpreter session. Subsequent import statements for the same module will reuse the already loaded module object.",
        "hint": "This is an optimization to prevent redundant loading of the same code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of the __all__ list in a module?",
        "options": ["To list all functions in a module", "To specify which names are exported when using 'from module import *'", "To document required dependencies", "To list all classes in a module"],
        "correctOptionIndex": 1,
        "correctOptionText": "To specify which names are exported when using 'from module import *'",
        "difficulty": "medium",
        "explanation": "The __all__ list in a module defines the public interface of the module by specifying which names are exported when a user does 'from module import *'.",
        "hint": "This helps control what's exposed when using wildcard imports."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "How can you find out all the names defined in a module?",
        "options": ["module.names()", "list(module)", "help(module)", "dir(module)"],
        "correctOptionIndex": 3,
        "correctOptionText": "dir(module)",
        "difficulty": "medium",
        "explanation": "The dir() function returns a sorted list of names in the given module. This includes variables, functions, classes, and even built-in attributes.",
        "hint": "This built-in function helps you explore what's available in a module."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of the sys.path variable?",
        "options": ["To store the execution path of the script", "To list directories where Python looks for modules", "To track the call stack of the program", "To define environment variables"],
        "correctOptionIndex": 1,
        "correctOptionText": "To list directories where Python looks for modules",
        "difficulty": "medium",
        "explanation": "sys.path is a list of directory paths where Python looks for modules when you import them. It includes the current directory, PYTHONPATH, and installation-dependent defaults.",
        "hint": "It's related to how Python's import system finds modules in the filesystem."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What will be printed by this code?\n\n# my_module.py\ndef func():\n    return 'Hello'\n\n# main.py\nfrom my_module import func\nprint(func.__module__)",
        "options": ["'func'", "'main'", "'my_module'", "'__main__'"],
        "correctOptionIndex": 2,
        "correctOptionText": "'my_module'",
        "difficulty": "medium",
        "explanation": "The __module__ attribute of a function tells you which module the function was defined in. Even when imported into main.py, func.__module__ still refers to 'my_module'.",
        "hint": "This attribute tracks the original source of the function, not where it's being used."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the correct syntax for a relative import in a package?",
        "options": ["import ..module", "from .. import module", "import relative module", "using .. module"],
        "correctOptionIndex": 1, 
        "correctOptionText": "from .. import module",
        "difficulty": "medium",
        "explanation": "Relative imports use dots to indicate the parent package level. One dot means the current package, two dots mean the parent package, and so on.",
        "hint": "The dots represent navigating up in the package hierarchy."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What's the purpose of the importlib module in Python?",
        "options": ["To optimize import statements", "To manage virtual environments", "To implement custom import behaviors", "To import C libraries"],
        "correctOptionIndex": 2,
        "correctOptionText": "To implement custom import behaviors",
        "difficulty": "medium",
        "explanation": "The importlib module provides the implementation of Python's import statement, allowing developers to create custom importers and loaders or to programmatically import modules.",
        "hint": "It provides low-level access to Python's import mechanism."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What happens when you run a module as a script using 'python -m module_name'?",
        "options": ["The module is imported but not executed", "The module's __main__ function is executed", "The module is executed as a script with __name__ set to '__main__'", "Python raises an error"],
        "correctOptionIndex": 2,
        "correctOptionText": "The module is executed as a script with __name__ set to '__main__'",
        "difficulty": "medium",
        "explanation": "When you run a module with 'python -m module_name', Python executes the module as the main program, setting __name__ to '__main__' instead of the module's name.",
        "hint": "This is similar to running the file directly, but with proper package resolution."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is a namespace package in Python?",
        "options": ["A package with a unique namespace identifier", "A package that uses namespaces for its classes", "A package spread across multiple directories without __init__.py files", "A package that contains only namespace declarations"],
        "correctOptionIndex": 2,
        "correctOptionText": "A package spread across multiple directories without __init__.py files",
        "difficulty": "hard",
        "explanation": "Namespace packages, introduced in PEP 420, allow package parts to be spread across multiple directories without requiring __init__.py files, enabling collaborative development across multiple libraries.",
        "hint": "This is a more modern and flexible approach to package organization in Python 3."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What happens if you try to import a non-existent module in Python?",
        "options": ["Python creates an empty module", "Python raises an ImportError", "Python warns but continues execution", "Python silently ignores the import"],
        "correctOptionIndex": 1,
        "correctOptionText": "Python raises an ImportError",
        "difficulty": "medium",
        "explanation": "When you attempt to import a module that doesn't exist, Python raises an ImportError or its subclass ModuleNotFoundError, indicating that the specified module cannot be found.",
        "hint": "Python needs to let you know when it can't find something you're trying to use."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of __pycache__ directories?",
        "options": ["To store module documentation", "To cache compiled Python files (.pyc)", "To store package metadata", "To backup source code"],
        "correctOptionIndex": 1,
        "correctOptionText": "To cache compiled Python files (.pyc)",
        "difficulty": "medium",
        "explanation": "The __pycache__ directories store compiled Python bytecode files (.pyc) to speed up module loading. Python automatically creates and manages these caches.",
        "hint": "These directories help optimize Python's performance when importing modules."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the effect of including the statement 'if __name__ == \"__main__\":' in a module?",
        "options": ["It makes the module importable", "It prevents the module from being imported", "It runs the code below it only when the module is executed as the main program", "It defines the main function of the module"],
        "correctOptionIndex": 2,
        "correctOptionText": "It runs the code below it only when the module is executed as the main program",
        "difficulty": "medium",
        "explanation": "This conditional statement checks if the module is being run directly (as a script) rather than being imported. Code inside this block executes only when the module is the main program.",
        "hint": "This pattern allows a file to serve both as a reusable module and as a standalone script."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is a wheel file (.whl) in Python packaging?",
        "options": ["A source code archive", "A compiled Python executable", "A built package distribution format", "A package documentation format"],
        "correctOptionIndex": 2,
        "correctOptionText": "A built package distribution format",
        "difficulty": "hard",
        "explanation": "A wheel file (.whl) is a built package format that contains all the files needed for installation. It's a binary distribution format that doesn't require compilation during installation, making it faster to install than source distributions.",
        "hint": "This format was introduced to improve upon the older egg format and simplify package installation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What tool is commonly used to install Python packages from PyPI?",
        "options": ["easy_install", "pip", "setup.py", "conda"],
        "correctOptionIndex": 1,
        "correctOptionText": "pip",
        "difficulty": "easy",
        "explanation": "pip is the standard package installer for Python, used to install packages from the Python Package Index (PyPI) and other repositories.",
        "hint": "This tool comes bundled with Python installations since Python 3.4."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What file is required to make a Python package installable with pip?",
        "options": ["requirements.txt", "MANIFEST.in", "setup.py", "__init__.py"],
        "correctOptionIndex": 2,
        "correctOptionText": "setup.py",
        "difficulty": "medium",
        "explanation": "The setup.py file contains metadata about the package and instructions for installation. It uses the setuptools or distutils libraries to define how the package should be built and installed.",
        "hint": "This file contains the configuration needed to package and distribute your code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of virtual environments in Python?",
        "options": ["To simulate different operating systems", "To isolate packages for different projects", "To speed up Python execution", "To virtualize hardware resources"],
        "correctOptionIndex": 1,
        "correctOptionText": "To isolate packages for different projects",
        "difficulty": "medium",
        "explanation": "Virtual environments create isolated Python environments where you can install packages for specific projects without interfering with other projects or the system Python installation.",
        "hint": "They help solve the problem of dependency conflicts between projects."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of the __path__ attribute in a package?",
        "options": ["To store the package's documentation path", "To define the import path for submodules", "To specify the path to the package's source code", "To store the package installation path"],
        "correctOptionIndex": 1,
        "correctOptionText": "To define the import path for submodules",
        "difficulty": "hard",
        "explanation": "The __path__ attribute is a list of strings that defines where to look for submodules belonging to the package. It's used by the import system to locate package contents.",
        "hint": "This attribute can be manipulated to customize how submodules are discovered and loaded."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is lazy loading in the context of Python imports?",
        "options": ["Loading modules only when idle", "Loading modules in a separate thread", "Deferring import until the module is actually used", "Loading only part of a module"],
        "correctOptionIndex": 2,
        "correctOptionText": "Deferring import until the module is actually used",
        "difficulty": "hard",
        "explanation": "Lazy loading is a technique where modules are imported only when they're actually needed, not at the beginning of the program. This can improve startup time and reduce memory usage.",
        "hint": "This optimization technique avoids unnecessary work until it's required."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the difference between absolute and relative imports?",
        "options": ["Absolute imports are faster, relative imports are more reliable", "Absolute imports use the full path from the root, relative imports use paths relative to the current module", "Absolute imports work in all Python versions, relative imports only in Python 3", "There is no difference"],
        "correctOptionIndex": 1,
        "correctOptionText": "Absolute imports use the full path from the root, relative imports use paths relative to the current module",
        "difficulty": "hard",
        "explanation": "Absolute imports specify the full path to the module from the project's root package, while relative imports specify the path relative to the current module using dots notation.",
        "hint": "Think about how you specify file paths in a filesystem: absolute vs. relative paths."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What will be printed by this code?\n\n# my_module.py\nx = 10\n\n# main.py\nimport my_module\nmy_module.x = 20\nimport my_module\nprint(my_module.x)",
        "options": ["10", "20", "Error: module already imported", "None"],
        "correctOptionIndex": 1,
        "correctOptionText": "20",
        "difficulty": "hard",
        "explanation": "Python only imports a module once per interpreter session. The second import statement doesn't reload the module but returns the already imported module object. Since the first import already changed x to 20, that's what will be printed.",
        "hint": "Consider how Python's module caching works and the effects of modifying module attributes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "How can you reload a module that has already been imported?",
        "options": ["import module again", "module.reload()", "from importlib import reload; reload(module)", "reinstall(module)"],
        "correctOptionIndex": 2,
        "correctOptionText": "from importlib import reload; reload(module)",
        "difficulty": "hard",
        "explanation": "The reload() function from the importlib module can be used to reload a previously imported module, updating any changes made to the module's source code.",
        "hint": "This functionality used to be a built-in function in Python 2 but moved to a module in Python 3."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is a circular import in Python?",
        "options": ["Importing the same module multiple times", "When a module imports itself", "When two or more modules import each other", "Using import statements in a loop"],
        "correctOptionIndex": 2,
        "correctOptionText": "When two or more modules import each other",
        "difficulty": "hard",
        "explanation": "A circular import occurs when module A imports module B, and module B also imports module A, either directly or indirectly. This can lead to import errors or unexpected behavior if not handled carefully.",
        "hint": "This creates a dependency cycle that can be problematic for the import system."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the purpose of the __slots__ attribute in a Python class within a module?",
        "options": ["To define module-level variables", "To restrict the attributes a class instance can have", "To specify which functions are exported", "To allocate memory slots for the module"],
        "correctOptionIndex": 1,
        "correctOptionText": "To restrict the attributes a class instance can have",
        "difficulty": "hard",
        "explanation": "The __slots__ attribute is used to explicitly declare data members in a class and prevent the dynamic creation of new attributes. This can save memory and improve access speed for classes with many instances.",
        "hint": "This feature helps optimize memory usage for classes with predefined attributes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Modules & Packages",
        "questionText": "What is the pyproject.toml file used for in modern Python packaging?",
        "options": ["To define project structure", "To list project contributors", "To specify build system requirements and configuration", "To document the project API"],
        "correctOptionIndex": 2,
        "correctOptionText": "To specify build system requirements and configuration",
        "difficulty": "hard",
        "explanation": "The pyproject.toml file, defined in PEP 518, specifies the build system requirements and configuration for a Python project. It's a standardized way to configure various tools like build systems, formatters, and linters.",
        "hint": "This file is part of modern Python packaging standards that aim to improve upon the limitations of setup.py."
    },
      
    // Error Handling
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the purpose of the 'try' block in Python?",
        "options": ["To define a new error type", "To catch and handle exceptions", "To contain code that might raise an exception", "To ignore errors in the code"],
        "correctOptionIndex": 2,
        "correctOptionText": "To contain code that might raise an exception",
        "difficulty": "easy",
        "explanation": "The 'try' block is used to enclose code that might raise an exception. If an exception occurs, the execution of the try block is stopped and the corresponding except block is executed.",
        "hint": "Think about which part of a try-except structure contains the potentially problematic code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which of the following is NOT a built-in exception in Python?",
        "options": ["ValueError", "TypeError", "SyntaxError", "ErrorException"],
        "correctOptionIndex": 3,
        "correctOptionText": "ErrorException",
        "difficulty": "easy",
        "explanation": "ErrorException is not a built-in exception in Python. The other options (ValueError, TypeError, and SyntaxError) are all valid built-in exceptions.",
        "hint": "Think about common error types you've encountered in Python programming."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What happens if an exception is not caught in a Python program?",
        "options": ["The program continues execution", "The program ignores the exception", "The program terminates with an error message", "The exception is automatically resolved"],
        "correctOptionIndex": 2,
        "correctOptionText": "The program terminates with an error message",
        "difficulty": "easy",
        "explanation": "If an exception is not caught (handled), the program will terminate and display an error message showing the type of exception that occurred and a traceback.",
        "hint": "What's the default behavior when Python encounters an unhandled error?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which clause is used to run code regardless of whether an exception occurred or not?",
        "options": ["else", "finally", "except", "try"],
        "correctOptionIndex": 1,
        "correctOptionText": "finally",
        "difficulty": "easy",
        "explanation": "The 'finally' clause is executed regardless of whether an exception occurred in the try block or not. It's typically used for cleanup operations.",
        "hint": "Which part of a try-except structure always runs, even if errors occur?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the most generic exception class in Python?",
        "options": ["Error", "Exception", "BaseException", "StandardError"],
        "correctOptionIndex": 2,
        "correctOptionText": "BaseException",
        "difficulty": "medium",
        "explanation": "BaseException is the root class for all built-in exceptions in Python. Exception is a subclass of BaseException, and most custom exceptions inherit from Exception.",
        "hint": "Think about the inheritance hierarchy of Python's exception system."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which of the following is the correct way to define a custom exception in Python?",
        "options": ["class MyError(Exception): pass", "class MyError extends Exception: pass", "def MyError(Exception): pass", "exception MyError: pass"],
        "correctOptionIndex": 0,
        "correctOptionText": "class MyError(Exception): pass",
        "difficulty": "medium",
        "explanation": "In Python, custom exceptions are defined by creating a new class that inherits from the Exception class or one of its subclasses.",
        "hint": "Custom exceptions are created using class inheritance."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the purpose of the 'else' clause in a try-except block?",
        "options": ["To handle exceptions", "To execute code if no exceptions occurred", "To execute code regardless of exceptions", "To define alternative error handling"],
        "correctOptionIndex": 1,
        "correctOptionText": "To execute code if no exceptions occurred",
        "difficulty": "medium",
        "explanation": "The 'else' clause in a try-except block is executed only if no exceptions were raised in the try block. It's useful for code that should run only if the try block was successful.",
        "hint": "The 'else' clause is conditional based on the outcome of the try block."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What will be the output of the following code?\n\ntry:\n    print(\"A\")\n    raise ValueError\n    print(\"B\")\nexcept ValueError:\n    print(\"C\")\nelse:\n    print(\"D\")\nfinally:\n    print(\"E\")",
        "options": ["A C E", "A B C E", "A C D E", "A B C D E"],
        "correctOptionIndex": 0,
        "correctOptionText": "A C E",
        "difficulty": "medium",
        "explanation": "The code prints 'A', then raises a ValueError, so 'B' is not printed. The exception is caught, so 'C' is printed. The 'else' clause is not executed because an exception occurred, so 'D' is not printed. Finally, 'E' is printed because the 'finally' clause always executes.",
        "hint": "Trace through the code execution and consider which parts run when an exception is raised."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "When is an IndexError raised in Python?",
        "options": ["When trying to access an index that doesn't exist", "When trying to modify a tuple", "When trying to use a non-integer as an index", "When trying to use negative indices"],
        "correctOptionIndex": 0,
        "correctOptionText": "When trying to access an index that doesn't exist",
        "difficulty": "easy",
        "explanation": "IndexError is raised when trying to access an index that is outside the valid range for a sequence (like a list, tuple, or string).",
        "hint": "Think about what happens when you try to access an element beyond the bounds of a list."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the proper way to catch multiple specific exceptions in Python?",
        "options": ["try-except Exception1, Exception2:", "try-except [Exception1, Exception2]:", "try-except (Exception1, Exception2):", "try-except Exception1 and Exception2:"],
        "correctOptionIndex": 2,
        "correctOptionText": "try-except (Exception1, Exception2):",
        "difficulty": "medium",
        "explanation": "To catch multiple specific exceptions in Python, you can specify them as a tuple in the except clause: `except (Exception1, Exception2):`. This will catch any of the specified exceptions.",
        "hint": "In Python, how do you group multiple items in a single except statement?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the difference between 'raise' and 'raise Exception()'?",
        "options": ["They are identical", "raise re-raises the current exception, while raise Exception() creates a new exception", "raise Exception() is not valid syntax", "raise can only be used in except blocks"],
        "correctOptionIndex": 1,
        "correctOptionText": "raise re-raises the current exception, while raise Exception() creates a new exception",
        "difficulty": "hard",
        "explanation": "When used inside an except block, 'raise' without arguments re-raises the exception that was caught. 'raise Exception()' creates and raises a new exception object.",
        "hint": "Consider the context in which 'raise' is used without arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the purpose of the 'assert' statement in Python?",
        "options": ["To create custom exceptions", "To test if a condition is true and raise an exception if it's not", "To handle exceptions gracefully", "To prevent exceptions from being raised"],
        "correctOptionIndex": 1,
        "correctOptionText": "To test if a condition is true and raise an exception if it's not",
        "difficulty": "medium",
        "explanation": "The assert statement is used to test if a condition is true. If the condition is false, an AssertionError is raised. Assert statements are often used for debugging and in test code.",
        "hint": "Assert statements are often used for validating assumptions in your code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What happens when you use 'raise' without any arguments?",
        "options": ["SyntaxError is raised", "The last exception is re-raised", "A generic Exception is raised", "Nothing happens"],
        "correctOptionIndex": 1,
        "correctOptionText": "The last exception is re-raised",
        "difficulty": "medium",
        "explanation": "When 'raise' is used without any arguments inside an except block, it re-raises the exception that was caught. This is useful when you want to handle an exception partially and then pass it on.",
        "hint": "This is commonly used when you want to log an exception but still let it propagate."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which of the following is NOT a recommended practice when handling exceptions in Python?",
        "options": ["Using specific exception types", "Using try-except blocks", "Catching all exceptions with 'except:'", "Using multiple except blocks"],
        "correctOptionIndex": 2,
        "correctOptionText": "Catching all exceptions with 'except:'",
        "difficulty": "medium",
        "explanation": "Catching all exceptions with a bare 'except:' statement is generally not recommended because it can mask programming errors and make debugging difficult. It's better to catch specific exceptions or use 'except Exception:' at the very least.",
        "hint": "Think about which practice might hide bugs rather than help handle them properly."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What exception is raised when trying to divide by zero in Python?",
        "options": ["DivisionError", "ZeroDivisionError", "ArithmeticError", "ValueError"],
        "correctOptionIndex": 1,
        "correctOptionText": "ZeroDivisionError",
        "difficulty": "easy",
        "explanation": "In Python, attempting to divide by zero raises a ZeroDivisionError. This is a specific type of ArithmeticError.",
        "hint": "What happens when you execute 'print(1/0)' in Python?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the output of the following code?\n\ntry:\n    print(1)\n    assert False, \"Error message\"\n    print(2)\nexcept AssertionError as e:\n    print(str(e))",
        "options": ["1\\n2", "1\\nError message", "Error message", "1\\nAssertionError: Error message"],
        "correctOptionIndex": 1,
        "correctOptionText": "1\\nError message",
        "difficulty": "medium",
        "explanation": "The code prints '1', then encounters an assertion that fails, which raises an AssertionError with the message 'Error message'. The exception is caught, and str(e) returns just the error message, which is printed. The code after the assertion is not executed.",
        "hint": "What does the 'as e' part of the except clause do?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which of the following is TRUE about exception handling in Python?",
        "options": ["Exceptions can only be caught by one except block", "Multiple except blocks can catch the same exception", "The finally block is optional", "The try block must be followed by at least one except block"],
        "correctOptionIndex": 2,
        "correctOptionText": "The finally block is optional",
        "difficulty": "easy",
        "explanation": "The finally block is optional in Python's exception handling. A try block can be followed by except blocks, an else block, and/or a finally block, but not all of them are required.",
        "hint": "Which components of a try-except-else-finally structure are required?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the correct way to access the error message of an exception in Python?",
        "options": ["except Exception as e: print(e.message)", "except Exception as e: print(e)", "except Exception: print(Exception.message)", "except Exception: print(Exception)"],
        "correctOptionIndex": 1,
        "correctOptionText": "except Exception as e: print(e)",
        "difficulty": "medium",
        "explanation": "You can access the error message by catching the exception in a variable using 'as e' and then printing the exception object. The string representation of the exception object typically includes the error message.",
        "hint": "How do you capture and reference the actual exception object?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the main purpose of the 'with' statement in Python's exception handling?",
        "options": ["To make code more readable", "To handle multiple exceptions at once", "To ensure proper cleanup of resources", "To create custom exceptions"],
        "correctOptionIndex": 2,
        "correctOptionText": "To ensure proper cleanup of resources",
        "difficulty": "medium",
        "explanation": "The 'with' statement in Python is used for context management. It ensures proper acquisition and release of resources, handling cleanup automatically even if an exception occurs. This is commonly used with file operations, locks, and other resources that need proper cleanup.",
        "hint": "Think about what happens automatically when you use 'with open()' for file operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the result of the following code?\n\ntry:\n    x = 1 / 0\nexcept ZeroDivisionError:\n    x = 0\nprint(x)",
        "options": ["Error", "None", "0", "1"],
        "correctOptionIndex": 2,
        "correctOptionText": "0",
        "difficulty": "easy",
        "explanation": "The code attempts to divide 1 by 0, which raises a ZeroDivisionError. The except block catches this exception and sets x to 0. Then x is printed, resulting in '0'.",
        "hint": "Follow the flow of execution when an exception occurs."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "Which of the following is NOT a valid way to raise an exception in Python?",
        "options": ["raise ValueError('Invalid value')", "raise ValueError", "raise Exception from ValueError", "raise 'Invalid value'"],
        "correctOptionIndex": 3,
        "correctOptionText": "raise 'Invalid value'",
        "difficulty": "medium",
        "explanation": "In Python, you can only raise exception objects, not strings or other types. 'raise 'Invalid value'' is not valid syntax. You need to raise an exception class or an instance of an exception class.",
        "hint": "What types of objects can be used with the raise statement?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the purpose of the 'traceback' module in Python?",
        "options": ["To create custom exceptions", "To handle exceptions automatically", "To print and manipulate stack traces", "To prevent exceptions from being raised"],
        "correctOptionIndex": 2,
        "correctOptionText": "To print and manipulate stack traces",
        "difficulty": "hard",
        "explanation": "The 'traceback' module in Python provides functions to print, format, and manipulate stack traces. It's useful for debugging and for creating custom error reporting systems.",
        "hint": "Think about what information you might want to extract from an exception for debugging purposes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What will be the output of the following code?\n\ntry:\n    try:\n        raise ValueError('Inner')\n    finally:\n        print('Finally inner')\nexcept ValueError as e:\n    print(str(e))\nfinally:\n    print('Finally outer')",
        "options": ["Finally inner\\nInner\\nFinally outer", "Inner\\nFinally inner\\nFinally outer", "Finally inner\\nFinally outer\\nInner", "Inner\\nFinally outer"],
        "correctOptionIndex": 0,
        "correctOptionText": "Finally inner\\nInner\\nFinally outer",
        "difficulty": "hard",
        "explanation": "The inner try block raises a ValueError. Before the exception propagates, the inner finally block executes, printing 'Finally inner'. Then the outer except block catches the ValueError and prints 'Inner'. Finally, the outer finally block executes, printing 'Finally outer'.",
        "hint": "Consider the order of execution in nested try-except-finally blocks."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the correct way to implement a custom context manager in Python?",
        "options": ["By defining __enter__ and __exit__ methods", "By inheriting from the ContextManager class", "By using the @contextmanager decorator", "Both A and C are correct"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both A and C are correct",
        "difficulty": "hard",
        "explanation": "There are two ways to implement a custom context manager in Python: 1) Define a class with __enter__ and __exit__ methods, or 2) Use the @contextmanager decorator from the contextlib module with a generator function. Both approaches are valid.",
        "hint": "There are two different approaches to creating objects that work with the 'with' statement."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the purpose of the 'except Exception as e:' syntax in Python?",
        "options": ["To specify the type of exception to catch", "To create a new exception object", "To capture the exception object in a variable", "To rename the exception class"],
        "correctOptionIndex": 2,
        "correctOptionText": "To capture the exception object in a variable",
        "difficulty": "easy",
        "explanation": "The 'except Exception as e:' syntax captures the exception object in the variable 'e'. This allows you to access the exception's attributes and methods, such as its error message or other specific information.",
        "hint": "This syntax gives you a way to reference the actual exception that was raised."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the result of the following code?\n\ntry:\n    x = int('abc')\nexcept ValueError:\n    x = -1\nelse:\n    x += 1\nfinally:\n    x += 2\nprint(x)",
        "options": ["0", "1", "2", "3"],
        "correctOptionIndex": 2,
        "correctOptionText": "1",
        "difficulty": "medium",
        "explanation": "The code tries to convert 'abc' to an integer, which raises a ValueError. The except block catches this and sets x to -1. The else block is not executed because an exception occurred. The finally block adds 2 to x, making it 1. Then x is printed, resulting in '1'.",
        "hint": "Track the value of x through each block that executes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What does the 'raise Exception from cause' syntax do in Python?",
        "options": ["It raises two exceptions simultaneously", "It creates a new exception with a custom message", "It raises an exception while preserving the traceback of the original cause", "It converts one exception type to another"],
        "correctOptionIndex": 2,
        "correctOptionText": "It raises an exception while preserving the traceback of the original cause",
        "difficulty": "hard",
        "explanation": "The 'raise Exception from cause' syntax (e.g., 'raise ValueError('message') from original_exception') creates a new exception that is chained to the original cause. This preserves the traceback of the original exception, making it easier to debug the root cause of the error.",
        "hint": "This feature helps with debugging by showing the full chain of exceptions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the primary benefit of using a try-except block instead of if-else statements for error handling?",
        "options": ["It's more efficient", "It's easier to read", "It can catch unexpected errors", "It requires less code"],
        "correctOptionIndex": 2,
        "correctOptionText": "It can catch unexpected errors",
        "difficulty": "medium",
        "explanation": "The primary benefit of using try-except blocks is that they can catch unexpected errors that you might not anticipate with if-else statements. This is especially useful when dealing with operations that might fail in multiple ways or when interacting with external systems.",
        "hint": "Consider the difference between preventive checks and reactive handling."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the 'EAFP' principle in Python?",
        "options": ["Errors Are Fully Preventable", "Expect All Failures Proactively", "Errors Are For Programmers", "Easier to Ask Forgiveness than Permission"],
        "correctOptionIndex": 3,
        "correctOptionText": "Easier to Ask Forgiveness than Permission",
        "difficulty": "hard",
        "explanation": "EAFP stands for 'Easier to Ask Forgiveness than Permission'. It's a coding style in Python that involves attempting an operation and catching exceptions if they occur, rather than checking conditions beforehand. This is in contrast to LBYL (Look Before You Leap).",
        "hint": "This principle relates to a preference for try-except blocks over if-else checks."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What is the difference between __exit__ and __del__ methods in Python?",
        "options": ["__exit__ is called when an object is garbage collected, while __del__ is called when exiting a with block", "__exit__ is called when exiting a with block, while __del__ is called when an object is garbage collected", "They are aliases for the same method", "__exit__ is for exception handling, while __del__ is for memory management"],
        "correctOptionIndex": 1,
        "correctOptionText": "__exit__ is called when exiting a with block, while __del__ is called when an object is garbage collected",
        "difficulty": "hard",
        "explanation": "The __exit__ method is part of the context manager protocol and is called when exiting a with block. The __del__ method is a finalizer that's called when an object is about to be destroyed by the garbage collector.",
        "hint": "These methods serve different purposes in an object's lifecycle."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad85",
        "module": "Error Handling",
        "questionText": "What does the 'suppress' context manager from the contextlib module do?",
        "options": ["It prevents any code from executing", "It ignores specified exceptions", "It forces exceptions to be raised", "It suppresses all output to the console"],
        "correctOptionIndex": 1,
        "correctOptionText": "It ignores specified exceptions",
        "difficulty": "hard",
        "explanation": "The 'suppress' context manager from the contextlib module is used to selectively ignore specific exceptions. Any exceptions specified as arguments to suppress() will be silently ignored if they occur within the with block.",
        "hint": "This is useful when you want to continue execution even if certain exceptions occur."
    },

    // Regular Expressions

    // Database Operations

    // Data Analysis with NumPy & Pandas
    
    // Data Visualization

    // Web Development with Python

    // Python for Machine Learning

  ]

export default pythonQuestions;