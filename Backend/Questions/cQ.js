const CQuestions = [
    // Data Types & Variables
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the size of an int data type in C (on most modern systems)?",
      "options": ["2 bytes", "4 bytes", "8 bytes", "Varies by compiler"],
      "correctOptionIndex": 1,
      "correctOptionText": "4 bytes",
      "difficulty": "easy",
      "explanation": "On most modern systems, an int in C is 4 bytes (32 bits). However, the C standard only guarantees that an int is at least 2 bytes. The actual size can vary by implementation, but 4 bytes is the most common size on contemporary platforms.",
      "hint": "Think about the typical size that can hold values between approximately -2 billion and +2 billion."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following is NOT a basic data type in C?",
      "options": ["int", "float", "string", "char"],
      "correctOptionIndex": 2,
      "correctOptionText": "string",
      "difficulty": "easy",
      "explanation": "C does not have a built-in string data type. In C, strings are represented as arrays of characters, typically terminated by a null character ('\\0'). The other options (int, float, and char) are all basic data types in C.",
      "hint": "C handles text data differently than many modern languages."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the result of the expression 5/2 in C?",
      "options": ["2.5", "2", "2.0", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "2",
      "difficulty": "easy",
      "explanation": "In C, when both operands of the division operator are integers, the result is an integer division. The fractional part is truncated (not rounded). So 5/2 results in 2, not 2.5, because both 5 and 2 are integer literals.",
      "hint": "Consider the type of the operands and how C handles division between different types."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which modifier is used to declare an unsigned integer variable in C?",
      "options": ["unsigned", "signed", "short", "long"],
      "correctOptionIndex": 0,
      "correctOptionText": "unsigned",
      "difficulty": "easy",
      "explanation": "The 'unsigned' modifier is used to declare integer variables that can only store non-negative values (zero and positive numbers). This increases the maximum positive value the variable can hold, at the cost of not being able to represent negative values.",
      "hint": "Which keyword indicates a variable can only hold positive values or zero?"
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the correct way to declare a constant in C?",
      "options": ["const int MAX = 100;", "constant int MAX = 100;", "int const MAX = 100;", "Both A and C"],
      "correctOptionIndex": 3,
      "correctOptionText": "Both A and C",
      "difficulty": "easy",
      "explanation": "In C, constants can be declared using the 'const' keyword. Both 'const int MAX = 100;' and 'int const MAX = 100;' are valid and equivalent declarations. The placement of 'const' before or after the type name doesn't change the meaning in this case.",
      "hint": "C allows flexibility in where you place the qualifier that prevents modification."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the output of the following code snippet?\n\nint main() {\n    char c = 255;\n    printf(\"%d\", c);\n    return 0;\n}",
      "options": ["255", "-1", "0", "Undefined behavior"],
      "correctOptionIndex": 1,
      "correctOptionText": "-1",
      "difficulty": "medium",
      "explanation": "On most systems, char is a signed 8-bit value with a range from -128 to 127. When we assign 255 to a signed char, it overflows and wraps around to -1. This is because 255 in binary (11111111) is interpreted as -1 in two's complement representation when stored in a signed char.",
      "hint": "Consider the typical size of a char and what happens when you assign a value outside its range."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the output of the following code?\n\nint main() {\n    float x = 0.1;\n    if(x == 0.1)\n        printf(\"Equal\");\n    else\n        printf(\"Not Equal\");\n    return 0;\n}",
      "options": ["Equal", "Not Equal", "Compiler Error", "Runtime Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "Not Equal",
      "difficulty": "medium",
      "explanation": "This will typically print 'Not Equal'. In C, floating-point numbers are stored in binary, and many decimal fractions (like 0.1) cannot be exactly represented in binary floating-point. The literal 0.1 is a double, while x is a float, so they have different precision and are not exactly equal when compared.",
      "hint": "Consider how floating-point numbers are represented in binary and the precision differences between float and double."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following correctly declares a float variable with an initial value of 3.14?",
      "options": ["float pi = 3.14;", "float pi = 3.14f;", "Both A and B", "Neither A nor B"],
      "correctOptionIndex": 2,
      "correctOptionText": "Both A and B",
      "difficulty": "medium",
      "explanation": "Both declarations are valid in C. When you write 'float pi = 3.14;', the literal 3.14 is a double, which is then converted to float when assigned. When you write 'float pi = 3.14f;', the 'f' suffix explicitly makes it a float literal. Both achieve the same result, though the second form is more precise in its intent.",
      "hint": "Consider implicit type conversions and the purpose of the 'f' suffix in floating-point literals."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the range of values that can be stored in a variable of type 'unsigned char'?",
      "options": ["-128 to 127", "0 to 255", "-256 to 255", "0 to 65535"],
      "correctOptionIndex": 1,
      "correctOptionText": "0 to 255",
      "difficulty": "medium",
      "explanation": "An 'unsigned char' in C is typically 8 bits (1 byte) and can represent values from 0 to 2^8-1, which is 0 to 255. Unlike a signed char, which can represent both negative and positive values, an unsigned char can only represent non-negative values but has a larger maximum value.",
      "hint": "An unsigned 8-bit value can represent 2^8 different values starting from 0."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the value of 'c' after the following code executes?\n\nint a = 10, b = 20, c;\nc = a++ + ++b;",
      "options": ["30", "31", "32", "Undefined behavior"],
      "correctOptionIndex": 1,
      "correctOptionText": "31",
      "difficulty": "medium",
      "explanation": "In this expression, a++ means use the current value of 'a' (10) and then increment it. ++b means increment 'b' first (to 21) and then use the value. So the calculation is 10 + 21 = 31. After this statement, a will be 11 and b will be 21.",
      "hint": "Pay attention to the difference between prefix (++b) and postfix (a++) increment operators."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following is the correct way to declare a one-dimensional array of 10 integers in C?",
      "options": ["int array[10];", "array int[10];", "int[10] array;", "array[10] int;"],
      "correctOptionIndex": 0,
      "correctOptionText": "int array[10];",
      "difficulty": "easy",
      "explanation": "In C, an array is declared by specifying the data type, followed by the array name, and then the size in square brackets. So 'int array[10];' correctly declares an array named 'array' that can hold 10 integers.",
      "hint": "The syntax follows the pattern: type name[size];"
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the output of the following code?\n\nint main() {\n    int x = 10;\n    int y = 20;\n    int z = x < y ? x : y;\n    printf(\"%d\", z);\n    return 0;\n}",
      "options": ["10", "20", "30", "Compilation error"],
      "correctOptionIndex": 0,
      "correctOptionText": "10",
      "difficulty": "medium",
      "explanation": "This code uses the ternary conditional operator (condition ? value_if_true : value_if_false). Since x (10) is less than y (20), the condition x < y is true, so the value of x (10) is assigned to z. Therefore, the output is 10.",
      "hint": "The ternary operator returns the first value after the ? if the condition is true, and the second value after the : if the condition is false."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the output of the following code?\n\nint main() {\n    printf(\"%d\", sizeof(3.14));\n    return 0;\n}",
      "options": ["4", "8", "Depends on the compiler", "Compilation error"],
      "correctOptionIndex": 1,
      "correctOptionText": "8",
      "difficulty": "medium",
      "explanation": "In C, by default, floating-point literals like 3.14 are of type double, which is typically 8 bytes in size. The sizeof operator returns the size of its operand in bytes. So sizeof(3.14) returns 8 on most modern systems.",
      "hint": "Consider the default type of floating-point literals in C."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following is NOT a valid variable name in C?",
      "options": ["_variable", "variable123", "123variable", "variable_123"],
      "correctOptionIndex": 2,
      "correctOptionText": "123variable",
      "difficulty": "easy",
      "explanation": "In C, variable names must start with a letter or underscore, followed by any number of letters, digits, or underscores. The name '123variable' is invalid because it starts with a digit. The other options are all valid variable names in C.",
      "hint": "Variable names in C have specific rules about what characters can appear at the beginning."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the value of the expression 'sizeof(char)' in C?",
      "options": ["1", "2", "4", "Depends on the compiler"],
      "correctOptionIndex": 0,
      "correctOptionText": "1",
      "difficulty": "easy",
      "explanation": "In C, the sizeof operator returns the size of its operand in bytes. The C standard guarantees that sizeof(char) is always 1, regardless of the actual number of bits in a byte on the system. This is a fundamental property of C, making char the basic addressable unit of storage.",
      "hint": "The size of char is used as the reference unit in C's memory model."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What happens when an unsigned integer overflows in C?",
      "options": ["Program crashes", "Wraps around to the minimum value", "Compiler error", "Undefined behavior"],
      "correctOptionIndex": 1,
      "correctOptionText": "Wraps around to the minimum value",
      "difficulty": "medium",
      "explanation": "When an unsigned integer overflows in C, it wraps around to zero and continues from there. This is defined behavior in C. For example, if you increment an 8-bit unsigned integer (range: 0-255) from 255, it will wrap around to 0.",
      "hint": "Think about modular arithmetic and how values cycle when they exceed the maximum representable value."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the output of the following code?\n\nint main() {\n    int x = 10;\n    printf(\"%d %d %d\", x, x++, ++x);\n    return 0;\n}",
      "options": ["10 10 12", "10 11 12", "12 10 12", "Undefined behavior"],
      "correctOptionIndex": 3,
      "correctOptionText": "Undefined behavior",
      "difficulty": "hard",
      "explanation": "This code invokes undefined behavior because the same variable 'x' is modified multiple times between sequence points (in this case, between the commas in the printf function call). The C standard does not specify the order in which function arguments are evaluated, so different compilers may produce different results.",
      "hint": "Consider the concept of sequence points in C and when it's safe to modify variables multiple times."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the value of the expression 3.0 / 0.0 in C?",
      "options": ["Infinity", "0", "Not a Number (NaN)", "Runtime error"],
      "correctOptionIndex": 0,
      "correctOptionText": "Infinity",
      "difficulty": "medium",
      "explanation": "In IEEE 754 floating-point arithmetic, which is used by most C implementations, dividing a non-zero floating-point number by 0.0 results in positive or negative infinity (depending on the sign of the numerator). So 3.0 / 0.0 results in positive infinity. This does not cause a runtime error, unlike integer division by zero.",
      "hint": "Floating-point division by zero has a defined behavior in IEEE 754, unlike integer division by zero."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the output of the following code?\n\nint main() {\n    int a = 1, b = 1, c = 1;\n    printf(\"%d\", a || b && c);\n    return 0;\n}",
      "options": ["0", "1", "2", "3"],
      "correctOptionIndex": 1,
      "correctOptionText": "1",
      "difficulty": "medium",
      "explanation": "In C, the && (logical AND) operator has higher precedence than the || (logical OR) operator. So the expression a || b && c is evaluated as a || (b && c). Since a, b, and c are all 1 (which is considered true in C), the expression evaluates to true, which is printed as 1.",
      "hint": "Consider operator precedence and how logical operators evaluate non-zero values as true."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which data type would you use to store a single character in C?",
      "options": ["int", "char", "float", "string"],
      "correctOptionIndex": 1,
      "correctOptionText": "char",
      "difficulty": "easy",
      "explanation": "The 'char' data type in C is specifically designed to store single characters. It typically occupies 1 byte of memory and can represent ASCII or UTF-8 encoded characters. While an int could technically store a character code, char is the appropriate type for character data.",
      "hint": "Which type is specifically designed for holding individual text symbols?"
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the result of the bitwise operation 5 & 3 in C?",
      "options": ["8", "2", "1", "15"],
      "correctOptionIndex": 1,
      "correctOptionText": "1",
      "difficulty": "medium",
      "explanation": "The & operator performs a bitwise AND operation. In binary, 5 is 101 and 3 is 011. When we perform the bitwise AND operation:\n101 & 011 = 001\nWhich equals 1 in decimal. The result has a 1 bit only where both operands have a 1 bit.",
      "hint": "Convert both numbers to binary and perform the AND operation bit by bit."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the output of the following code?\n\nint main() {\n    int i = 5;\n    printf(\"%d %d\", i, i << 1);\n    return 0;\n}",
      "options": ["5 6", "5 10", "5 4", "5 25"],
      "correctOptionIndex": 1,
      "correctOptionText": "5 10",
      "difficulty": "medium",
      "explanation": "The << operator performs a left shift. i << 1 shifts all bits in i one position to the left, which is equivalent to multiplying i by 2. So 5 << 1 equals 10. The code prints the original value of i (5) followed by the result of the shift operation (10).",
      "hint": "Left shifting by 1 position doubles the value, similar to multiplying by 2."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the size of a 'long double' data type in C?",
      "options": ["Same as double", "8 bytes", "16 bytes", "Implementation-dependent"],
      "correctOptionIndex": 3,
      "correctOptionText": "Implementation-dependent",
      "difficulty": "hard",
      "explanation": "The size of 'long double' in C is implementation-dependent. It must be at least as large as double, but its actual size varies by compiler and platform. On some systems it might be 8 bytes (same as double), on others 10, 12, or 16 bytes. This variation is allowed by the C standard to accommodate different hardware floating-point formats.",
      "hint": "The C standard allows flexibility for this type to match platform-specific extended precision capabilities."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the correct way to declare an enumeration in C?",
      "options": ["enum {RED, GREEN, BLUE};", "enumeration {RED, GREEN, BLUE};", "enum colors {RED, GREEN, BLUE};", "Both A and C"],
      "correctOptionIndex": 3,
      "correctOptionText": "Both A and C",
      "difficulty": "medium",
      "explanation": "In C, enumerations can be declared with or without a tag name. Both 'enum {RED, GREEN, BLUE};' and 'enum colors {RED, GREEN, BLUE};' are valid. The first creates an anonymous enum, while the second creates a named enum (colors). Both define the same enumeration constants (RED=0, GREEN=1, BLUE=2).",
      "hint": "C allows enumerations to be declared with or without a type name following the 'enum' keyword."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be printed by the following code?\n\nint main() {\n    int a = 10;\n    int *p = &a;\n    printf(\"%d\", *p + 1);\n    return 0;\n}",
      "options": ["10", "11", "Address of a", "Error"],
      "correctOptionIndex": 1,
      "correctOptionText": "11",
      "difficulty": "medium",
      "explanation": "In this code, p is a pointer that stores the address of variable a. The expression *p dereferences the pointer, accessing the value at that address (which is 10). So *p + 1 equals 10 + 1, which is 11. The code prints 11.",
      "hint": "The asterisk (*) before a pointer variable is the dereference operator, which accesses the value stored at the address in the pointer."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following correctly declares a variable that can store the memory address of an integer?",
      "options": ["int address;", "address int;", "int *address;", "int &address;"],
      "correctOptionIndex": 2,
      "correctOptionText": "int *address;",
      "difficulty": "medium",
      "explanation": "In C, a pointer variable is declared using the asterisk (*) symbol. The declaration 'int *address;' creates a pointer variable named 'address' that can store the memory address of an integer. This allows the program to indirectly access or modify that integer through the pointer.",
      "hint": "A variable that stores an address is called a pointer, which has special syntax in its declaration."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the default value of a global variable in C?",
      "options": ["0", "Garbage value", "NULL", "Depends on its type"],
      "correctOptionIndex": 0,
      "correctOptionText": "0",
      "difficulty": "easy",
      "explanation": "In C, global variables (variables declared outside of any function) are automatically initialized to zero if no explicit initializer is provided. This applies to numeric types (which get 0), pointers (which get NULL, equivalent to 0), and aggregate types like arrays and structs (which get all elements initialized to 0).",
      "hint": "C has different initialization rules for global variables compared to local variables."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What will be the output of the following code?\n\nint main() {\n    int a = 1;\n    int b = 2;\n    int c = a+++b;\n    printf(\"%d %d %d\", a, b, c);\n    return 0;\n}",
      "options": ["1 2 3", "2 2 3", "2 2 4", "Compilation error"],
      "correctOptionIndex": 1,
      "correctOptionText": "2 2 3",
      "difficulty": "hard",
      "explanation": "The expression a+++b is parsed as (a++) + b due to the maximal munch rule. It increments a (after using its current value) and adds the result to b. So c gets (1) + 2 = 3, and a is incremented to 2. The values printed are a=2, b=2, c=3.",
      "hint": "The compiler parses the longest valid token, so a+++ is treated as a++ followed by +."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the output of the following code?\n\nint main() {\n    int x = 5;\n    int y = 2;\n    double z = x / y;\n    printf(\"%f\", z);\n    return 0;\n}",
      "options": ["2.000000", "2.500000", "1.000000", "0.000000"],
      "correctOptionIndex": 0,
      "correctOptionText": "2.000000",
      "difficulty": "medium",
      "explanation": "In the expression x / y, both x and y are integers, so integer division is performed, resulting in 2 (the fractional part is truncated). This integer result (2) is then converted to a double when assigned to z. When printed with %f, it appears as 2.000000.",
      "hint": "The data types of the operands determine the type of division performed, regardless of the destination variable's type."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "Which of the following correctly declares a constant pointer to an integer in C?",
      "options": ["const int* ptr;", "int const* ptr;", "int* const ptr;", "const int const* ptr;"],
      "correctOptionIndex": 2,
      "correctOptionText": "int* const ptr;",
      "difficulty": "hard",
      "explanation": "A constant pointer (a pointer that cannot be changed to point to a different address) is declared with the 'const' keyword after the asterisk. So 'int* const ptr;' declares a constant pointer to an integer. Options A and B declare pointers to constant integers (the pointer can change, but the integer it points to cannot be modified through this pointer).",
      "hint": "The position of 'const' relative to the asterisk determines whether the pointer itself or the value it points to is constant."
    },
    {
      "topic": "67d6b45a953bd3a26da2ad82",
      "module": "Data Types & Variables",
      "questionText": "What is the result of the expression -1u in C?",
      "options": ["-1", "0", "4294967295", "Compiler-dependent"],
      "correctOptionIndex": 2,
      "correctOptionText": "4294967295",
      "difficulty": "hard",
      "explanation": "The expression -1u is interpreted as the negation of an unsigned int with value 1. On a system with 32-bit unsigned integers, 1u is 1, and -1u is 4294967295 (which is 2^32 - 1). This is because the 'u' suffix makes the literal unsigned, and negating an unsigned value is defined as 2^n - val, where n is the number of bits in the representation.",
      "hint": "When negating an unsigned value, the result wraps around to the maximum value for that unsigned type."
    },

    // Control Structures
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "Which of the following is NOT a looping structure in C?",
        "options": ["for", "while", "do-while", "unless"],
        "correctOptionIndex": 3,
        "correctOptionText": "unless",
        "difficulty": "easy",
        "explanation": "C has three main looping structures: 'for', 'while', and 'do-while'. The 'unless' structure does not exist in C. It is found in some other programming languages like Perl and Ruby as an alternative to 'if-not' logic.",
        "hint": "Think about the standard loop keywords in C programming."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int i = 10;\n    if (i = 5)\n        printf(\"True\");\n    else\n        printf(\"False\");\n    return 0;\n}",
        "options": ["True", "False", "Compilation error", "Runtime error"],
        "correctOptionIndex": 0,
        "correctOptionText": "True",
        "difficulty": "medium",
        "explanation": "The code has a common mistake: using assignment (=) instead of comparison (==) in the if condition. The expression 'i = 5' assigns 5 to i and returns 5, which is non-zero and thus considered true in C. Therefore, the if condition evaluates to true, and \"True\" is printed.",
        "hint": "Pay attention to the operator in the if statement. Is it comparing values or assigning a value?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "How many times will the following loop execute?\n\nfor(int i = 0; i < 10; i += 2) {\n    printf(\"%d \", i);\n}",
        "options": ["5", "6", "10", "Infinite times"],
        "correctOptionIndex": 0,
        "correctOptionText": "5",
        "difficulty": "easy",
        "explanation": "The loop initializes i to 0, continues while i is less than 10, and increments i by 2 each iteration. The values of i will be 0, 2, 4, 6, 8, and then i becomes 10, which fails the condition i < 10. So the printf statement executes 5 times, printing 0, 2, 4, 6, and 8.",
        "hint": "List the values of i for each iteration and count how many there are before the loop condition becomes false."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the output of the following code?\n\nint main() {\n    int x = 0;\n    while (x < 10) {\n        if (x == 5)\n            break;\n        printf(\"%d \", x);\n        x++;\n    }\n    return 0;\n}",
        "options": ["0 1 2 3 4", "0 1 2 3 4 5", "0 1 2 3 4 5 6 7 8 9", "Infinite loop"],
        "correctOptionIndex": 0,
        "correctOptionText": "0 1 2 3 4",
        "difficulty": "easy",
        "explanation": "The while loop prints the values of x from 0 to 4. When x equals 5, the break statement is executed, which immediately terminates the loop. Since the printf statement comes before the increment, the value 5 is never printed. Therefore, the output is \"0 1 2 3 4\".",
        "hint": "The break statement causes immediate exit from the loop when x equals 5."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int i = 0;\n    do {\n        printf(\"%d \", i);\n        i++;\n    } while (i < 0);\n    return 0;\n}",
        "options": ["No output", "0", "0 1 2 3 ...", "Compilation error"],
        "correctOptionIndex": 1,
        "correctOptionText": "0",
        "difficulty": "medium",
        "explanation": "In a do-while loop, the body of the loop is executed at least once before the condition is checked. Here, i is initialized to 0, and \"0\" is printed. Then i is incremented to 1. The condition i < 0 is then checked, which is false, so the loop terminates. Therefore, \"0\" is printed once.",
        "hint": "Unlike while loops, do-while loops always execute their body at least once."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "Which statement is used to exit a function in C?",
        "options": ["exit", "break", "continue", "return"],
        "correctOptionIndex": 3,
        "correctOptionText": "return",
        "difficulty": "easy",
        "explanation": "The 'return' statement is used to exit a function in C. It can optionally provide a value back to the caller. The 'break' statement exits a loop or switch, 'continue' skips to the next iteration of a loop, and 'exit' terminates the entire program, not just the current function.",
        "hint": "Which keyword allows you to exit the current function scope and possibly send a value back to the caller?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int i;\n    for (i = 0; i < 5; i++) {\n        if (i == 2)\n            continue;\n        printf(\"%d \", i);\n    }\n    return 0;\n}",
        "options": ["0 1 2 3 4", "0 1 3 4", "0 1 2", "0 1"],
        "correctOptionIndex": 1,
        "correctOptionText": "0 1 3 4",
        "difficulty": "easy",
        "explanation": "The for loop iterates from 0 to 4. The 'continue' statement skips the rest of the current iteration when i equals 2, moving directly to the next iteration. This means that when i is 2, the printf statement is not executed. Therefore, the output is \"0 1 3 4\".",
        "hint": "The continue statement skips the remaining code in the loop body for the current iteration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "In a switch statement, what happens if no case matches the expression and there is no default case?",
        "options": ["The program crashes", "The program terminates", "Nothing, execution continues after the switch statement", "Compilation error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Nothing, execution continues after the switch statement",
        "difficulty": "medium",
        "explanation": "If no case matches the switch expression and there is no default case, control simply passes to the statement following the switch block. This doesn't cause an error; it's a normal flow control situation where none of the specified conditions were met.",
        "hint": "Think about what happens when an if-else if-else chain has no matching condition and no else clause."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the result of the following code?\n\nint main() {\n    int sum = 0;\n    for (int i = 1; i <= 10; i++) {\n        if (i % 2 == 0)\n            continue;\n        sum += i;\n    }\n    printf(\"%d\", sum);\n    return 0;\n}",
        "options": ["25", "30", "55", "Error"],
        "correctOptionIndex": 0,
        "correctOptionText": "25",
        "difficulty": "medium",
        "explanation": "The code calculates the sum of odd numbers from 1 to 10. When i is even (i % 2 == 0), the continue statement skips to the next iteration, bypassing the sum += i statement. Therefore, only the odd numbers (1, 3, 5, 7, 9) are added to sum, resulting in 1 + 3 + 5 + 7 + 9 = 25.",
        "hint": "Track which iterations are skipped by the continue statement and which values are added to sum."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is missing in the following code to properly print numbers from 1 to 10?\n\nint main() {\n    int i = 1;\n    while (i <= 10) {\n        printf(\"%d \", i);\n    }\n    return 0;\n}",
        "options": ["i = i + 1;", "i++;", "Either A or B", "Nothing, the code is correct"],
        "correctOptionIndex": 2,
        "correctOptionText": "Either A or B",
        "difficulty": "easy",
        "explanation": "The code is missing an increment statement for the variable i inside the while loop. Without incrementing i, the condition i <= 10 will always be true (since i remains 1), resulting in an infinite loop. Either i = i + 1; or i++; would fix this by incrementing i each iteration.",
        "hint": "For a while loop to terminate, something inside the loop must eventually make the condition false."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int n = 10;\n    switch (n) {\n        case 5:\n            printf(\"Five\");\n        case 10:\n            printf(\"Ten\");\n        case 15:\n            printf(\"Fifteen\");\n        default:\n            printf(\"Default\");\n    }\n    return 0;\n}",
        "options": ["Ten", "TenFifteenDefault", "Five", "FiveTenFifteenDefault"],
        "correctOptionIndex": 1,
        "correctOptionText": "TenFifteenDefault",
        "difficulty": "medium",
        "explanation": "Since n is 10, the case 10 matches. In C, switch cases fall through to the next case unless explicitly terminated with a break statement. Since there are no break statements, execution continues through case 10, case 15, and default, printing \"TenFifteenDefault\" without spaces.",
        "hint": "Without break statements, switch cases fall through to the next case in sequence."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What's wrong with the following loop?\n\nfor (int i = 0; i < 10; i--);\n    printf(\"%d\", i);",
        "options": ["The loop will run infinitely", "i is not declared properly", "The semicolon after the for loop", "Nothing, the code is correct"],
        "correctOptionIndex": 0,
        "correctOptionText": "The loop will run infinitely",
        "difficulty": "medium",
        "explanation": "The loop decrements i (i--) instead of incrementing it. Since i starts at 0 and the condition is i < 10, decrementing i will make it increasingly negative, so the condition i < 10 will always be true. This creates an infinite loop. Additionally, the semicolon after the for loop is a problem (it creates an empty loop body), but that's not the main issue identified in the options.",
        "hint": "Follow the loop execution: what happens to i in each iteration, and will the condition ever become false?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the purpose of the break statement in a loop?",
        "options": ["To skip the current iteration and proceed to the next iteration", "To terminate the entire program", "To immediately exit the loop", "To pause the loop execution"],
        "correctOptionIndex": 2,
        "correctOptionText": "To immediately exit the loop",
        "difficulty": "easy",
        "explanation": "The break statement is used to immediately terminate the execution of a loop (or a switch statement). When encountered inside a loop, it causes control to exit the loop completely, regardless of the loop's condition. Execution then continues with the statement following the loop.",
        "hint": "Think about what happens when you 'break' out of something - you leave it entirely."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the final value of sum after this code executes?\n\nint main() {\n    int sum = 0;\n    for (int i = 1; i <= 100; i++) {\n        if (i % 3 == 0 || i % 5 == 0)\n            sum += i;\n    }\n    return 0;\n}",
        "options": ["2333", "2418", "2518", "3367"],
        "correctOptionIndex": 0,
        "correctOptionText": "2333",
        "difficulty": "hard",
        "explanation": "This code calculates the sum of all numbers from 1 to 100 that are divisible by either 3 or 5. These numbers are 3, 5, 6, 9, 10, 12, 15, etc. The sum of all these numbers is 2333. (This is actually a variation of a classic programming problem, similar to one found in Project Euler.)",
        "hint": "List all numbers from 1 to 100 that are multiples of 3 or 5, then calculate their sum."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "Which of the following is NOT a valid condition in an if statement?",
        "options": ["x == 5", "x = 5", "x != 5", "x <= 5"],
        "correctOptionIndex": 1,
        "correctOptionText": "x = 5",
        "difficulty": "easy",
        "explanation": "In C, 'x = 5' is an assignment, not a comparison. While this can be used in an if statement (it evaluates to the assigned value, which is then checked for truthiness), it's almost always a logical error, as the programmer typically intended to use the equality comparison operator '==' instead. The other options are all valid comparison expressions.",
        "hint": "Which option represents an assignment rather than a comparison?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int x = 10;\n    if (x > 5)\n        if (x < 15)\n            printf(\"A\");\n    else\n        printf(\"B\");\n    return 0;\n}",
        "options": ["A", "B", "AB", "No output"],
        "correctOptionIndex": 0,
        "correctOptionText": "A",
        "difficulty": "medium",
        "explanation": "This demonstrates the 'dangling else' problem in C. The else clause is associated with the nearest if statement that doesn't already have an else, which is the inner if (x < 15). Since x is 10, both conditions (x > 5 and x < 15) are true, so \"A\" is printed. The else clause would only execute if x < 15 were false, not if x > 5 were false.",
        "hint": "In C, an else is paired with the closest if that doesn't already have an else, regardless of indentation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "How many times is \"Hello\" printed in the following code?\n\nint main() {\n    int i = 0;\n    while (i++ < 5)\n        printf(\"Hello\\n\");\n    return 0;\n}",
        "options": ["4", "5", "6", "Infinite times"],
        "correctOptionIndex": 1,
        "correctOptionText": "5",
        "difficulty": "medium",
        "explanation": "The loop condition i++ < 5 first checks if i < 5, and then increments i. The values of i during the checks are 0, 1, 2, 3, and 4, all of which are less than 5, so the loop body executes 5 times. The loop terminates when i becomes 5 and the condition becomes false. Therefore, \"Hello\" is printed 5 times.",
        "hint": "The post-increment operator (i++) means i is compared to 5 before it's incremented."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the output of the following code?\n\nint main() {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 2; j++) {\n            if (i == j)\n                break;\n            printf(\"%d%d \", i, j);\n        }\n    }\n    return 0;\n}",
        "options": ["00 01 10 11 20 21", "01 10 20 21", "00 10 11 20 21", "None of the above"],
        "correctOptionIndex": 1,
        "correctOptionText": "01 10 20 21",
        "difficulty": "hard",
        "explanation": "In the nested loops, when i equals j, the inner loop is terminated by the break statement.\nWhen i=0, j=0: break (no output)\nWhen i=0, j=1: output \"01\"\nWhen i=1, j=0: output \"10\"\nWhen i=1, j=1: break (no output)\nWhen i=2, j=0: output \"20\"\nWhen i=2, j=1: output \"21\"\nSo the output is \"01 10 20 21\".",
        "hint": "Trace through the execution by hand, tracking when the break statement is executed and prevents printing."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int a = 5, b = 2;\n    printf(\"%d\", a > b ? a : b);\n    return 0;\n}",
        "options": ["5", "2", "1", "0"],
        "correctOptionIndex": 0,
        "correctOptionText": "5",
        "difficulty": "easy",
        "explanation": "The code uses the ternary conditional operator (? :), which has the form 'condition ? value_if_true : value_if_false'. Here, the condition a > b is true (5 > 2), so the expression evaluates to a, which is 5. Therefore, 5 is printed.",
        "hint": "The ternary operator returns one of two values based on whether the condition is true or false."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will happen if a break statement is omitted from a case in a switch statement?",
        "options": ["Compilation error", "Runtime error", "Execution will fall through to the next case", "Nothing, the switch will work normally"],
        "correctOptionIndex": 2,
        "correctOptionText": "Execution will fall through to the next case",
        "difficulty": "medium",
        "explanation": "If a break statement is omitted from a case in a switch statement, execution will 'fall through' to the next case. This means that after executing the statements in the matching case, execution will continue with the statements in the next case, regardless of whether that case's value matches the switch expression. This behavior can be useful in some situations but often leads to bugs when unintended.",
        "hint": "Without an explicit exit point, code execution continues sequentially through the switch block."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is wrong with the following code?\n\nint main() {\n    int n = 5;\n    switch (n) {\n        case n > 0: printf(\"Positive\"); break;\n        case n < 0: printf(\"Negative\"); break;\n        default: printf(\"Zero\"); break;\n    }\n    return 0;\n}",
        "options": ["The switch condition must be an integer", "Case expressions must be constant integer expressions", "The code should use if-else statements instead", "Both B and C"],
        "correctOptionIndex": 1,
        "correctOptionText": "Case expressions must be constant integer expressions",
        "difficulty": "hard",
        "explanation": "In C, the expressions in case labels must be constant integer expressions known at compile time. Variables or expressions like n > 0 are not allowed. This code would cause a compilation error. The correct approach would be to use if-else statements for this type of condition checking.",
        "hint": "Switch-case in C has specific requirements for what can appear after the 'case' keyword."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    for (int i = 0; i < 5; printf(\"%d \", i++)) {\n        // Empty loop body\n    }\n    return 0;\n}",
        "options": ["0 1 2 3 4", "0 1 2 3 4 5", "1 2 3 4 5", "No output"],
        "correctOptionIndex": 0,
        "correctOptionText": "0 1 2 3 4",
        "difficulty": "medium",
        "explanation": "This for loop has an empty body ({}), but the third expression in the for statement (printf(\"%d \", i++)) is executed after each iteration. The loop runs while i < 5, and i is incremented in the printf statement. The values printed are 0, 1, 2, 3, and 4, with i becoming 5 after the last printf, which then fails the condition check.",
        "hint": "In a for loop, the third expression is executed after each iteration, even if the loop body is empty."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the purpose of the continue statement in a loop?",
        "options": ["To skip the rest of the current iteration and proceed to the next iteration", "To terminate the loop", "To pause the loop execution", "To exit the entire function"],
        "correctOptionIndex": 0,
        "correctOptionText": "To skip the rest of the current iteration and proceed to the next iteration",
        "difficulty": "easy",
        "explanation": "The continue statement in C skips the remaining code in the current iteration of a loop and jumps directly to the next iteration. In a for loop, control passes to the update expression and then to the condition check. In while and do-while loops, control passes directly to the condition check. This is useful for bypassing certain iterations based on specified conditions.",
        "hint": "Think about what it means to 'continue' in the context of a repeating process."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int i;\n    for (i = 1; i < 10; i++) {\n        if (i % 3 == 0)\n            continue;\n        printf(\"%d \", i);\n        if (i == 8)\n            break;\n    }\n    return 0;\n}",
        "options": ["1 2 4 5 7 8", "1 2 4 5 7 8 9", "1 2 3 4 5 6 7 8", "1 2 4 5 6 7 8"],
        "correctOptionIndex": 0,
        "correctOptionText": "1 2 4 5 7 8",
        "difficulty": "medium",
        "explanation": "The code prints numbers from 1 to 9, but with two modifications: numbers divisible by 3 (3, 6, 9) are skipped due to the continue statement, and the loop terminates when i equals 8 due to the break statement. Therefore, the output is \"1 2 4 5 7 8\".",
        "hint": "Track which numbers are skipped by the continue statement and when the break statement is triggered."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What does the following code calculate?\n\nint main() {\n    int n = 5;\n    int result = 1;\n    for (int i = 1; i <= n; i++) {\n        result *= i;\n    }\n    printf(\"%d\", result);\n    return 0;\n}",
        "options": ["5", "15", "120", "The sum of numbers from 1 to 5"],
        "correctOptionIndex": 2,
        "correctOptionText": "120",
        "difficulty": "easy",
        "explanation": "This code calculates the factorial of 5 (denoted as 5!). The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. So 5! = 5 × 4 × 3 × 2 × 1 = 120. The loop multiplies result by each number from 1 to 5.",
        "hint": "The code is multiplying numbers from 1 to n. What mathematical operation is this?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "Which of the following correctly implements a for loop that prints 10, 8, 6, 4, 2?",
        "options": [
        "for(int i = 10; i >= 2; i -= 2) printf(\"%d \", i);",
        "for(int i = 10; i > 0; i -= 2) printf(\"%d \", i);",
        "for(int i = 10; i >= 0; i -= 2) printf(\"%d \", i);",
        "for(int i = 10; i > 1; i -= 2) printf(\"%d \", i);"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "for(int i = 10; i >= 2; i -= 2) printf(\"%d \", i);",
        "difficulty": "medium",
        "explanation": "To print 10, 8, 6, 4, 2, we need a loop that starts at 10, decrements by 2 each time, and stops once it reaches (or goes below) 2. The condition i >= 2 ensures that the loop includes 2 and stops after that. The other options either exclude 2 or include 0, which aren't part of the desired sequence.",
        "hint": "The loop needs to include the value 2 but stop before reaching 0."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What is the issue with the following if statement?\n\nif (x > 10);\n    printf(\"x is greater than 10\");",
        "options": [
        "Semicolon after the if condition", 
        "Missing curly braces", 
        "The printf statement should have parentheses", 
        "None of the above"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "Semicolon after the if condition",
        "difficulty": "medium",
        "explanation": "The semicolon immediately after the if condition creates a null statement as the body of the if statement. This means that the if statement does nothing, and the printf statement will always execute regardless of the value of x. This is a common logic error in C programming.",
        "hint": "Look for syntax that might make the printf statement execute unconditionally."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following code?\n\nint main() {\n    int a = 10, b = 20;\n    if (a = b)\n        printf(\"%d\", a);\n    else\n        printf(\"%d\", b);\n    return 0;\n}",
        "options": ["10", "20", "0", "Compilation error"],
        "correctOptionIndex": 1,
        "correctOptionText": "20",
        "difficulty": "medium",
        "explanation": "The expression a = b is an assignment, not a comparison. It assigns the value of b (20) to a and returns this value. Since 20 is non-zero, it's considered true in C, so the if branch is executed. Therefore, the value of a (which is now 20) is printed.",
        "hint": "Pay attention to the operator in the if condition. Is it comparing values or assigning a value?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Control Structures",
        "questionText": "What will be the output of the following nested loop?\n\nint main() {\n    int count = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            count++;\n        }\n    }\n    printf(\"%d\", count);\n    return 0;\n}",
        "options": ["3", "6", "9", "27"],
        "correctOptionIndex": 2,
        "correctOptionText": "9",
        "difficulty": "easy",
        "explanation": "The outer loop runs 3 times (i from 0 to 2). For each iteration of the outer loop, the inner loop also runs 3 times (j from 0 to 2). This means the statement count++ is executed 3 × 3 = 9 times in total. Therefore, the final value of count is 9.",
        "hint": "Calculate the total number of times the inner loop body executes by multiplying the number of iterations of each loop."
    },
    
    // Functions
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which of the following correctly declares a function that takes two integers as parameters and returns an integer?",
        "options": ["void function(int a, int b);", "int function(int a, b);", "int function(int a, int b);", "function(int a, int b);"],
        "correctOptionIndex": 2,
        "correctOptionText": "int function(int a, int b);",
        "difficulty": "easy",
        "explanation": "In C, a function declaration must specify the return type, function name, and parameter types. The correct syntax for a function that returns an integer and takes two integer parameters is 'int function(int a, int b);'.",
        "hint": "A function declaration needs a return type, name, and properly typed parameters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the output of the following code?\n```c\n#include <stdio.h>\nint func(int a) {\n  a = a + 1;\n  return a;\n}\n\nint main() {\n  int a = 5;\n  func(a);\n  printf(\"%d\", a);\n  return 0;\n}\n```",
        "options": ["5", "6", "0", "Compilation error"],
        "correctOptionIndex": 0,
        "correctOptionText": "5",
        "difficulty": "easy",
        "explanation": "In this code, the value of 'a' is passed by value to the function 'func'. Any changes made to 'a' inside the function don't affect the original variable in the main function. Although 'func' increments its parameter and returns it, the return value isn't being used, so the original value of 'a' in main (5) remains unchanged.",
        "hint": "Consider whether the function's return value is being used and how parameters are passed in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which storage class specifier is used to make a function visible only to the current file?",
        "options": ["extern", "register", "static", "auto"],
        "correctOptionIndex": 2,
        "correctOptionText": "static",
        "difficulty": "medium",
        "explanation": "The 'static' keyword, when applied to a function, restricts its visibility to the file where it is defined. This means the function cannot be called from other files, effectively making it private to the current translation unit.",
        "hint": "This specifier limits the scope of functions to the file they're defined in."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is a function prototype in C?",
        "options": ["A function definition without a body", "A comment describing what the function does", "A preprocessor directive that creates a function", "The first call to a function"],
        "correctOptionIndex": 0,
        "correctOptionText": "A function definition without a body",
        "difficulty": "easy",
        "explanation": "A function prototype in C is a declaration of a function that specifies the function's name, return type, and parameters without providing the function body. It ends with a semicolon instead of a function body and is typically placed at the beginning of a program to inform the compiler about functions that will be used later.",
        "hint": "It tells the compiler about a function's interface before the full definition."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the purpose of the 'return' statement in a function?",
        "options": ["To exit the function and return control to the calling function", "To print a value to the console", "To declare a new variable", "To include a header file"],
        "correctOptionIndex": 0,
        "correctOptionText": "To exit the function and return control to the calling function",
        "difficulty": "easy",
        "explanation": "The 'return' statement in a function serves two purposes: it immediately terminates the execution of the function and returns control to the calling function, and it can optionally provide a value back to the caller. For functions with a non-void return type, the return statement must include a value of the appropriate type.",
        "hint": "It terminates function execution and can provide data back to the caller."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the output of the following code?\n```c\n#include <stdio.h>\nint factorial(int n) {\n  if (n <= 1)\n    return 1;\n  else\n    return n * factorial(n-1);\n}\n\nint main() {\n  printf(\"%d\", factorial(4));\n  return 0;\n}\n```",
        "options": ["4", "24", "12", "8"],
        "correctOptionIndex": 1,
        "correctOptionText": "24",
        "difficulty": "medium",
        "explanation": "This code calculates the factorial of 4 using recursion. The factorial function calls itself with decreasing values until n <= 1. The calculation is: 4 * factorial(3) = 4 * (3 * factorial(2)) = 4 * (3 * (2 * factorial(1))) = 4 * 3 * 2 * 1 = 24.",
        "hint": "Factorial of a number n is n*(n-1)*(n-2)*...*1."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What happens if a function with a non-void return type doesn't have a return statement?",
        "options": ["Compilation error", "The function returns 0", "The function returns a garbage value", "The program crashes at runtime"],
        "correctOptionIndex": 2,
        "correctOptionText": "The function returns a garbage value",
        "difficulty": "medium",
        "explanation": "In C, if a function with a non-void return type doesn't have a return statement, it will return whatever value happens to be in the return register when the function completes. This is undefined behavior according to the C standard and typically results in a garbage value. Modern compilers will usually generate a warning for this, but the code may still compile.",
        "hint": "C doesn't automatically provide a default return value for functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is a variadic function in C?",
        "options": ["A function with a variable scope", "A function that returns multiple values", "A function that can take a variable number of arguments", "A function defined with the 'variable' keyword"],
        "correctOptionIndex": 2,
        "correctOptionText": "A function that can take a variable number of arguments",
        "difficulty": "medium",
        "explanation": "A variadic function in C is a function that can accept a variable number of arguments. Examples include printf() and scanf() from the standard library. To create a variadic function, you use the ellipsis (...) in the parameter list and typically use macros from <stdarg.h> like va_start, va_arg, and va_end to access the arguments.",
        "hint": "These functions use ellipsis (...) in their parameter lists."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which of the following is true about the 'void' return type for a function?",
        "options": ["The function must return NULL", "The function cannot have parameters", "The function doesn't return any value", "The function can only be called from main()"],
        "correctOptionIndex": 2,
        "correctOptionText": "The function doesn't return any value",
        "difficulty": "easy",
        "explanation": "When a function is declared with a 'void' return type in C, it means the function doesn't return any value. It performs some operations but doesn't provide a result back to the caller. In void functions, the return statement without a value is optional at the end of the function, but a return statement with a value would cause a compilation error.",
        "hint": "This return type indicates the function performs actions without giving back a value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the difference between call-by-value and call-by-reference?",
        "options": ["Call-by-value is faster than call-by-reference", "In call-by-value, a copy of the actual parameter is passed to the function; in call-by-reference, the address of the actual parameter is passed", "Call-by-reference is not possible in C", "Call-by-value uses stack memory while call-by-reference uses heap memory"],
        "correctOptionIndex": 1,
        "correctOptionText": "In call-by-value, a copy of the actual parameter is passed to the function; in call-by-reference, the address of the actual parameter is passed",
        "difficulty": "medium",
        "explanation": "In call-by-value, which is C's default parameter passing mechanism, a copy of the argument's value is passed to the function. Any changes made to the parameter inside the function don't affect the original argument. In call-by-reference, achieved in C by passing pointers, the address of the argument is passed, allowing the function to directly modify the original variable.",
        "hint": "Think about whether the function receives a copy of the data or access to the original data."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\n\nvoid swap(int a, int b) {\n  int temp = a;\n  a = b;\n  b = temp;\n}\n\nint main() {\n  int x = 5, y = 10;\n  swap(x, y);\n  printf(\"%d %d\", x, y);\n  return 0;\n}\n```",
        "options": ["10 5", "5 10", "5 5", "10 10"],
        "correctOptionIndex": 1,
        "correctOptionText": "5 10",
        "difficulty": "medium",
        "explanation": "This code attempts to swap two integers using a function, but it doesn't work as expected because C uses call-by-value by default. In the swap function, local copies of x and y are created as a and b, and these copies are swapped. The original variables x and y in main remain unchanged, so the output is still '5 10'.",
        "hint": "Consider how parameters are passed to functions by default in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is a pure function in C?",
        "options": ["A function that only uses global variables", "A function that produces the same output for the same input and has no side effects", "A function declared with the 'pure' keyword", "A function with empty parameter list"],
        "correctOptionIndex": 1,
        "correctOptionText": "A function that produces the same output for the same input and has no side effects",
        "difficulty": "medium",
        "explanation": "A pure function in programming, including C, is one that always produces the same output for the same input and has no side effects. This means it doesn't modify global variables, doesn't modify its parameters (if they're pointers), doesn't perform I/O operations, and doesn't call other non-pure functions. Pure functions are generally easier to test, debug, and reason about.",
        "hint": "These functions are deterministic and don't cause changes outside their scope."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which of the following correctly implements a function that swaps two integers in C?",
        "options": [
        "void swap(int a, int b) {\n  int temp = a;\n  a = b;\n  b = temp;\n}",
        "void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}",
        "void swap(int &a, int &b) {\n  int temp = a;\n  a = b;\n  b = temp;\n}",
        "int swap(int a, int b) {\n  return b, a;\n}"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "void swap(int *a, int *b) {\n  int temp = *a;\n  *a = *b;\n  *b = temp;\n}",
        "difficulty": "medium",
        "explanation": "To swap two integers in C, you need to use pointers to modify the original variables. The correct implementation takes two integer pointers, dereferences them to access the actual values, and swaps those values using a temporary variable. Option A won't work because it only swaps local copies. Option C uses C++ reference syntax which isn't valid in C. Option D incorrectly attempts to return two values and the comma operator doesn't work as expected here.",
        "hint": "To modify variables from another scope, you need to use their memory addresses."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What will be the output of this recursive function for n=4?\n```c\n#include <stdio.h>\nint mystery(int n) {\n  if (n == 0)\n    return 0;\n  else\n    return n + mystery(n-1);\n}\n\nint main() {\n  printf(\"%d\", mystery(4));\n  return 0;\n}\n```",
        "options": ["4", "10", "6", "24"],
        "correctOptionIndex": 1,
        "correctOptionText": "10",
        "difficulty": "medium",
        "explanation": "This recursive function calculates the sum of numbers from 1 to n. For n=4, the calculation is: 4 + mystery(3) = 4 + (3 + mystery(2)) = 4 + 3 + (2 + mystery(1)) = 4 + 3 + 2 + (1 + mystery(0)) = 4 + 3 + 2 + 1 + 0 = 10.",
        "hint": "Trace the recursive calls and add up the values returned at each step."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is a callback function in C?",
        "options": ["A function that calls back the main function", "A function called automatically at program exit", "A function that is passed as an argument to another function", "A function that returns to its caller"],
        "correctOptionIndex": 2,
        "correctOptionText": "A function that is passed as an argument to another function",
        "difficulty": "medium",
        "explanation": "A callback function in C is a function that is passed as an argument to another function and is invoked or 'called back' at some point during the execution of the receiving function. This is typically implemented using function pointers. Callbacks are useful for implementing event handlers, customizing algorithms, and allowing higher-order functions that can operate on various types of data.",
        "hint": "It's a form of function that enables another function to call it during execution."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is function overloading?",
        "options": ["Defining a function inside another function", "Creating multiple functions with the same name but different parameters", "Calling a function too many times", "Redefining a standard library function"],
        "correctOptionIndex": 1,
        "correctOptionText": "Creating multiple functions with the same name but different parameters",
        "difficulty": "medium",
        "explanation": "Function overloading is creating multiple functions with the same name but different parameters (either different types or different number of parameters). However, it's important to note that C does not support function overloading directly - it's a feature of C++ and other object-oriented languages. In C, each function must have a unique name.",
        "hint": "This feature allows using the same function name for different parameter sets, but is it supported in C?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the purpose of the 'inline' keyword when used with functions in C99?",
        "options": ["To make the function execute faster", "To suggest to the compiler that it should insert the function's code at each call site", "To declare a function without a body", "To make the function visible only within the current file"],
        "correctOptionIndex": 1,
        "correctOptionText": "To suggest to the compiler that it should insert the function's code at each call site",
        "difficulty": "medium",
        "explanation": "The 'inline' keyword in C99 is a hint to the compiler that it should consider replacing calls to the function with the actual function code (inlining) rather than performing a regular function call. This can improve performance by eliminating function call overhead, particularly for small, frequently called functions. However, it's only a suggestion; the compiler may choose to ignore it based on optimization settings and other factors.",
        "hint": "It's a performance optimization hint related to how the function's code is incorporated at call sites."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which of the following is NOT a valid way to declare a function pointer in C?",
        "options": ["int (*func_ptr)(int, int);", "int *func_ptr(int, int);", "typedef int (*func_type)(int, int);", "int (**func_ptr)(int, int);"],
        "correctOptionIndex": 1,
        "correctOptionText": "int *func_ptr(int, int);",
        "difficulty": "hard",
        "explanation": "Option B (int *func_ptr(int, int);) is not a function pointer declaration; it's a declaration of a function that returns an int pointer and takes two int parameters. A correct function pointer declaration requires parentheses around the pointer name (*func_ptr) to indicate it's a pointer to a function, not a function returning a pointer.",
        "hint": "Look at the placement of parentheses and asterisks in the declaration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\n\nint counter() {\n  static int count = 0;\n  return ++count;\n}\n\nint main() {\n  printf(\"%d \", counter());\n  printf(\"%d \", counter());\n  printf(\"%d\", counter());\n  return 0;\n}\n```",
        "options": ["1 1 1", "1 2 3", "0 1 2", "3 2 1"],
        "correctOptionIndex": 1,
        "correctOptionText": "1 2 3",
        "difficulty": "medium",
        "explanation": "The counter() function uses a static variable 'count'. Static variables retain their values between function calls. The count is initialized to 0 only once, and each call to counter() increments it by 1 and returns the new value. So the three calls to counter() return 1, 2, and 3 respectively.",
        "hint": "Static variables are initialized only once and maintain their values between function calls."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\n\nvoid fun(int x, int y, int *z) {\n  *z = x + y;\n}\n\nint main() {\n  int a = 5, b = 7, c = 0;\n  fun(a, b, &c);\n  printf(\"%d\", c);\n  return 0;\n}\n```",
        "options": ["0", "5", "7", "12"],
        "correctOptionIndex": 3,
        "correctOptionText": "12",
        "difficulty": "medium",
        "explanation": "In this code, the function 'fun' takes two integers x and y, and a pointer to an integer z. It calculates the sum of x and y and stores the result in the memory location pointed to by z. In main(), we call fun(a, b, &c), passing the values of a and b and the address of c. The function computes 5 + 7 = 12 and stores this value in c, which is then printed.",
        "hint": "The function modifies a variable in the calling scope through a pointer parameter."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is tail recursion in C?",
        "options": ["A recursion that never terminates", "A recursive call that is the last operation in a function", "A recursion that allocates memory on the heap", "A recursion with multiple base cases"],
        "correctOptionIndex": 1,
        "correctOptionText": "A recursive call that is the last operation in a function",
        "difficulty": "hard",
        "explanation": "Tail recursion is a specific form of recursion where the recursive call is the last operation in the function (i.e., nothing happens after the recursive call returns). This is significant because many compilers can optimize tail-recursive functions to use constant stack space, effectively converting the recursion into iteration. This optimization is called tail call optimization or tail call elimination.",
        "hint": "It's a special case of recursion that can be optimized by some compilers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "Which of the following is a valid recursive implementation of the Fibonacci sequence in C?",
        "options": [
        "int fib(int n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);\n}",
        "int fib(int n) {\n  if (n <= 1) return n;\n  return fib(n+1) + fib(n+2);\n}",
        "int fib(int n) {\n  if (n >= 2) return n;\n  return fib(n-1) * fib(n-2);\n}",
        "int fib(int n) {\n  if (n == 0) return 0;\n  return fib(n-1) - fib(n-2);\n}"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "int fib(int n) {\n  if (n <= 1) return n;\n  return fib(n-1) + fib(n-2);\n}",
        "difficulty": "medium",
        "explanation": "The correct recursive implementation of the Fibonacci sequence has a base case for n <= 1 (where F(0) = 0 and F(1) = 1) and recursively computes F(n) = F(n-1) + F(n-2) for n > 1. Option A correctly implements this formula. Option B would lead to infinite recursion as it calls with larger values. Option C has an incorrect base case and uses multiplication instead of addition. Option D has an incomplete base case and uses subtraction instead of addition.",
        "hint": "The Fibonacci sequence is defined as F(n) = F(n-1) + F(n-2) with F(0) = 0 and F(1) = 1."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the problem with the following recursive function?\n```c\nint factorial(int n) {\n  return n * factorial(n-1);\n}\n```",
        "options": ["It calculates the wrong result", "It has no base case, leading to infinite recursion", "It only works for positive integers", "The return type should be unsigned int"],
        "correctOptionIndex": 1,
        "correctOptionText": "It has no base case, leading to infinite recursion",
        "difficulty": "medium",
        "explanation": "The factorial function shown lacks a base case (such as 'if (n <= 1) return 1;'). Without a base case, the recursion will continue indefinitely, with each call generating another call with a decremented value of n. This will eventually cause a stack overflow when the program runs out of stack space for function calls.",
        "hint": "Every recursive function needs a condition to stop the recursion."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What does this function do?\n```c\nint func(int arr[], int n) {\n  if (n <= 0) return 0;\n  if (arr[n-1] % 2 == 0)\n    return arr[n-1] + func(arr, n-1);\n  else\n    return func(arr, n-1);\n}\n```",
        "options": ["Counts the number of even elements in the array", "Returns the sum of all elements in the array", "Returns the sum of even-indexed elements in the array", "Returns the sum of even-valued elements in the array"],
        "correctOptionIndex": 3,
        "correctOptionText": "Returns the sum of even-valued elements in the array",
        "difficulty": "hard",
        "explanation": "This recursive function calculates the sum of even-valued elements in the array. It checks each element starting from the end of the array (arr[n-1]). If the element is even (divisible by 2), it adds the element to the sum and continues the recursion with the remaining elements. If the element is odd, it ignores it and continues the recursion. The base case is when n <= 0, where it returns 0.",
        "hint": "The function checks a condition on each array element and includes it in a calculation based on that condition."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is the output of this code?\n```c\n#include <stdio.h>\n\nint f(int *a, int *b) {\n  *a = *a + *b;\n  *b = *a - *b;\n  *a = *a - *b;\n  return *a + *b;\n}\n\nint main() {\n  int x = 5, y = 10;\n  printf(\"%d\", f(&x, &y));\n  return 0;\n}\n```",
        "options": ["15", "5", "10", "0"],
        "correctOptionIndex": 0,
        "correctOptionText": "15",
        "difficulty": "hard",
        "explanation": "This function swaps the values of a and b using pointer arithmetic (without a temporary variable) and then returns their sum. Starting with x=5, y=10:\n1. *a = *a + *b: *a becomes 5 + 10 = 15, *b remains 10\n2. *b = *a - *b: *b becomes 15 - 10 = 5, *a remains 15\n3. *a = *a - *b: *a becomes 15 - 5 = 10, *b remains 5\nSo x is now 10 and y is 5 (they've been swapped).\nThe function returns *a + *b = 10 + 5 = 15.",
        "hint": "The function manipulates the values and performs a common operation without using a temporary variable."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "In C, what is the purpose of the 'noreturn' function attribute introduced in C11?",
        "options": ["To create a function that never returns any value", "To indicate that a function never returns control to the caller", "To prevent a function from being called recursively", "To specify that a function doesn't need to be compiled"],
        "correctOptionIndex": 1,
        "correctOptionText": "To indicate that a function never returns control to the caller",
        "difficulty": "hard",
        "explanation": "The 'noreturn' function attribute in C11 (specified as _Noreturn or via <stdnoreturn.h>) is used to indicate that a function never returns control to the caller. This happens with functions that always terminate the program (like exit()), enter an infinite loop, or throw an exception (in C++ contexts). This attribute helps the compiler optimize code and provide better warnings, as it knows the control flow won't continue after such a function call.",
        "hint": "This attribute provides information about control flow after the function is called."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is a function pointer array in C?",
        "options": ["An array that stores function return values", "An array that stores the addresses of functions", "An array passed as a parameter to a function", "A function that returns an array of pointers"],
        "correctOptionIndex": 1,
        "correctOptionText": "An array that stores the addresses of functions",
        "difficulty": "hard",
        "explanation": "A function pointer array in C is an array that stores the addresses of functions with compatible signatures. It allows for programmatic selection of functions to call at runtime, which is useful for implementing callback systems, state machines, command processors, and polymorphic behavior. The syntax for declaring such an array is something like 'return_type (*array_name[array_size])(parameter_types);'.",
        "hint": "It's a data structure that enables selecting different functions to call at runtime."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What is wrong with this recursive solution to calculate power (x^n)?\n```c\ndouble power(double x, int n) {\n  if (n == 0)\n    return 1;\n  else\n    return x * power(x, n-1);\n}\n```",
        "options": ["It doesn't handle negative exponents", "It will overflow the stack for large values of n", "It uses floating-point which is imprecise", "It doesn't have a proper base case"],
        "correctOptionIndex": 1,
        "correctOptionText": "It will overflow the stack for large values of n",
        "difficulty": "hard",
        "explanation": "While this recursive function correctly computes x^n for non-negative n, it has a time and space complexity of O(n), making n recursive calls. For large values of n, this will cause a stack overflow as each recursive call consumes stack space. A more efficient approach would use the exponentiation by squaring algorithm with O(log n) complexity: if n is even, compute (x^(n/2))^2; if n is odd, compute x * (x^(n/2))^2.",
        "hint": "Consider the efficiency and resource usage of the algorithm for large inputs."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Functions",
        "questionText": "What does the 'volatile' qualifier do when used with a function parameter in C?",
        "options": [
        "Makes the parameter read-only",
        "Ensures the parameter won't be optimized away by the compiler",
        "Forces the compiler to pass the parameter via the stack",
        "Indicates the parameter might change between function calls"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Ensures the parameter won't be optimized away by the compiler",
        "difficulty": "hard",
        "explanation": "The volatile qualifier applied to a function parameter prevents compiler optimizations that might otherwise remove or simplify accesses to that parameter. This is critical for scenarios where the parameter's storage might be modified externally (e.g., memory-mapped hardware registers) or in low-level systems programming where every explicit read/write must be preserved.",
        "hint": "Think about how compilers handle variables they consider 'unnecessary' and what forces them to retain such variables."
    },
    
    // Arrays
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "In C, what is the correct way to declare an integer array of size 5?",
        "options": ["int array[5];", "array int[5];", "int[5] array;", "array[5] int;"],
        "correctOptionIndex": 0,
        "correctOptionText": "int array[5];",
        "difficulty": "easy",
        "explanation": "In C, an array is declared by specifying the data type of its elements, followed by the array name and the size of the array in square brackets. The correct syntax to declare an integer array of size 5 is 'int array[5];'.",
        "hint": "Remember the basic syntax: type name[size];"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How are array elements accessed in C?",
        "options": ["Using the array name followed by the element index in parentheses", "Using the array name followed by the element index in square brackets", "Using the element index followed by the array name in parentheses", "Using the element index followed by the array name in square brackets"],
        "correctOptionIndex": 1,
        "correctOptionText": "Using the array name followed by the element index in square brackets",
        "difficulty": "easy",
        "explanation": "In C, array elements are accessed using the array name followed by the element's index in square brackets. For example, to access the third element of an array named 'arr', you would use 'arr[2]' (remembering that array indices start at 0 in C).",
        "hint": "The syntax is similar to how arrays are declared."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is the index of the first element in a C array?",
        "options": ["1", "0", "-1", "Depends on the array declaration"],
        "correctOptionIndex": 1,
        "correctOptionText": "0",
        "difficulty": "easy",
        "explanation": "In C, array indices start at 0. This means the first element of an array is at index 0, the second element is at index 1, and so on. This zero-based indexing is standard in most programming languages and is related to how array addressing is calculated (base address + index * element size).",
        "hint": "C uses zero-based indexing for arrays."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\nint main() {\n  int arr[5] = {1, 2, 3, 4, 5};\n  printf(\"%d\", arr[3]);\n  return 0;\n}\n```",
        "options": ["1", "3", "4", "5"],
        "correctOptionIndex": 2,
        "correctOptionText": "4",
        "difficulty": "easy",
        "explanation": "The array 'arr' is initialized with values {1, 2, 3, 4, 5}. When we access arr[3], we're getting the element at index 3, which is the fourth element of the array (because indices start at 0). Therefore, arr[3] equals 4, which is what gets printed.",
        "hint": "Remember that array indices start at 0, so the element at index 3 is actually the fourth element."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What happens when you try to access an array element outside its bounds in C?",
        "options": ["The program will not compile", "The program will throw an ArrayIndexOutOfBoundsException", "The program will likely access unintended memory, leading to undefined behavior", "The program will return null"],
        "correctOptionIndex": 2,
        "correctOptionText": "The program will likely access unintended memory, leading to undefined behavior",
        "difficulty": "medium",
        "explanation": "C does not perform bounds checking on array accesses at runtime. When you access an array element outside its defined bounds, the program will access whatever memory happens to be at that location. This can lead to unpredictable results, program crashes, security vulnerabilities, or silent data corruption - collectively known as 'undefined behavior'. Modern compilers might warn about out-of-bounds accesses if they can be detected at compile-time.",
        "hint": "C prioritizes performance over safety when it comes to array access."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "Which of the following correctly initializes an integer array with values 10, 20, 30, 40, and 50?",
        "options": ["int arr[5] = 10, 20, 30, 40, 50;", "int arr[5] = {10, 20, 30, 40, 50};", "int arr[5]; arr = {10, 20, 30, 40, 50};", "int arr = {10, 20, 30, 40, 50}[5];"],
        "correctOptionIndex": 1,
        "correctOptionText": "int arr[5] = {10, 20, 30, 40, 50};",
        "difficulty": "easy",
        "explanation": "In C, you can initialize an array at declaration time by providing a list of values enclosed in curly braces. The correct syntax is 'int arr[5] = {10, 20, 30, 40, 50};'. Option A is missing the curly braces. Option C tries to assign to the array after declaration, which is not allowed (you must assign elements individually). Option D has incorrect syntax with the size after the initializer list.",
        "hint": "Array initialization in C requires curly braces around the values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the values in the array after this code executes?\n```c\nint arr[5] = {1, 2};\n```",
        "options": ["1, 2, garbage values, garbage values, garbage values", "1, 2, 0, 0, 0", "1, 2, 1, 2, 1", "Error: not enough initializers"],
        "correctOptionIndex": 1,
        "correctOptionText": "1, 2, 0, 0, 0",
        "difficulty": "medium",
        "explanation": "When an array is partially initialized in C, the remaining elements are automatically initialized to zero. In this case, arr[0] is set to 1 and arr[1] is set to 2 as specified in the initializer list. The remaining elements arr[2], arr[3], and arr[4] are implicitly initialized to 0.",
        "hint": "C automatically initializes unspecified array elements to a specific value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is the relationship between arrays and pointers in C?",
        "options": ["Arrays and pointers are completely different and unrelated", "Arrays are a type of pointer with special syntax", "The name of an array in C is a pointer to its first element", "An array can only be accessed through a pointer"],
        "correctOptionIndex": 2,
        "correctOptionText": "The name of an array in C is a pointer to its first element",
        "difficulty": "medium",
        "explanation": "In C, when an array name is used in most contexts, it 'decays' to a pointer to the first element of the array. This is why arrays and pointers can often be used interchangeably. For example, if 'arr' is an array, then 'arr' is equivalent to '&arr[0]' (the address of the first element) in most expressions. However, arrays and pointers are not identical - an array name represents a fixed location in memory and cannot be reassigned, while a pointer variable can be changed to point to different locations.",
        "hint": "Consider how arrays can be passed to functions and accessed using pointer notation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "Which of these statements about array sizes in C is true?",
        "options": ["Array sizes must always be compile-time constants", "Array sizes can be determined at runtime using dynamic allocation", "Array sizes can be changed after declaration", "Arrays in C don't need a specified size"],
        "correctOptionIndex": 1,
        "correctOptionText": "Array sizes can be determined at runtime using dynamic allocation",
        "difficulty": "medium",
        "explanation": "In C, there are two main ways to create arrays: static arrays and dynamically allocated arrays. For static arrays (declared like 'int arr[size]'), the size must be a compile-time constant. However, using dynamic memory allocation functions like malloc(), you can create arrays whose size is determined at runtime (like 'int *arr = malloc(size * sizeof(int))'). This provides flexibility when the array size depends on user input or other runtime conditions.",
        "hint": "Think about the difference between stack-allocated and heap-allocated arrays."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What happens if you initialize an array with more elements than its declared size in C?",
        "options": ["The extra elements are ignored", "The array size is automatically increased", "Compile-time error", "Runtime error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Compile-time error",
        "difficulty": "medium",
        "explanation": "In C, if you try to initialize an array with more elements than its declared size, the compiler will generate an error. For example, 'int arr[3] = {1, 2, 3, 4};' would cause a compilation error because there are 4 initializers for an array of size 3. This is a safety feature to prevent initializing memory beyond the allocated array space.",
        "hint": "The compiler checks the number of initializers against the declared array size."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How do you calculate the number of elements in a statically allocated array in C?",
        "options": ["Use the length property of the array", "Use the sizeof operator: sizeof(array) / sizeof(array[0])", "Use the count() function", "Use array.size()"],
        "correctOptionIndex": 1,
        "correctOptionText": "Use the sizeof operator: sizeof(array) / sizeof(array[0])",
        "difficulty": "medium",
        "explanation": "In C, you can calculate the number of elements in a statically allocated array by dividing the total size of the array by the size of a single element. The expression 'sizeof(array) / sizeof(array[0])' gives the number of elements because sizeof(array) returns the total bytes occupied by the array, and sizeof(array[0]) returns the bytes for one element. Note that this only works for arrays in the current scope, not for arrays passed to functions (which decay to pointers).",
        "hint": "You need to find the total bytes of the array and divide by the bytes per element."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\nint main() {\n  int arr[] = {10, 20, 30, 40, 50};\n  printf(\"%d\", sizeof(arr) / sizeof(int));\n  return 0;\n}\n```",
        "options": ["10", "5", "20", "Undefined"],
        "correctOptionIndex": 1,
        "correctOptionText": "5",
        "difficulty": "medium",
        "explanation": "This code calculates the number of elements in the array 'arr'. The array is initialized with 5 integers: 10, 20, 30, 40, and 50. sizeof(arr) returns the total size of the array in bytes (on most systems, 5 integers × 4 bytes per integer = 20 bytes). sizeof(int) returns the size of a single integer (typically 4 bytes). So sizeof(arr) / sizeof(int) = 20 / 4 = 5, which is the number of elements in the array.",
        "hint": "This is a common idiom to find the length of a statically allocated array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is a multidimensional array in C?",
        "options": ["An array that can hold different data types", "An array of arrays", "An array that can change size dynamically", "An array with a non-zero starting index"],
        "correctOptionIndex": 1,
        "correctOptionText": "An array of arrays",
        "difficulty": "medium",
        "explanation": "A multidimensional array in C is conceptually an array of arrays. It allows data to be organized in a tabular form (or higher dimensions). For example, a 2D array can be thought of as a table with rows and columns. The declaration 'int matrix[3][4];' creates a 2D array with 3 rows and 4 columns, which can be visualized as an array of 3 elements, where each element is itself an array of 4 integers.",
        "hint": "Think about how you would represent a table or matrix in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How is a 2D array stored in memory in C?",
        "options": ["As a linked list of arrays", "In a tree-like structure", "In row-major order (contiguous rows)", "In column-major order (contiguous columns)"],
        "correctOptionIndex": 2,
        "correctOptionText": "In row-major order (contiguous rows)",
        "difficulty": "medium",
        "explanation": "In C, a 2D array is stored in memory in row-major order. This means that all elements of the first row are stored contiguously, followed by all elements of the second row, and so on. For a 2D array declared as int arr[3][4], the memory layout would be: arr[0][0], arr[0][1], arr[0][2], arr[0][3], arr[1][0], arr[1][1], ..., arr[2][3]. This organization affects performance when accessing elements, as accessing consecutive elements in a row is generally more cache-friendly than accessing elements in the same column.",
        "hint": "Consider how you would sequentially arrange a matrix in a one-dimensional array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\nint main() {\n  int arr[3][2] = {{1, 2}, {3, 4}, {5, 6}};\n  printf(\"%d\", arr[1][1]);\n  return 0;\n}\n```",
        "options": ["1", "2", "3", "4"],
        "correctOptionIndex": 3,
        "correctOptionText": "4",
        "difficulty": "medium",
        "explanation": "This code initializes a 2D array 'arr' with 3 rows and 2 columns. The values are initialized row by row: row 0 has {1, 2}, row 1 has {3, 4}, and row 2 has {5, 6}. The expression arr[1][1] accesses the element in the second row (index 1) and second column (index 1), which is 4.",
        "hint": "Remember that array indices start at 0, so [1][1] refers to the element in the second row and second column."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How do you pass a 1D array to a function in C?",
        "options": ["void func(int[] arr)", "void func(int arr[])", "void func(arr int[])", "void func(array int)"],
        "correctOptionIndex": 1,
        "correctOptionText": "void func(int arr[])",
        "difficulty": "medium",
        "explanation": "In C, when passing a 1D array to a function, you can use the syntax 'void func(int arr[])' or equivalently 'void func(int *arr)' because arrays decay to pointers when passed to functions. The function receives a pointer to the first element of the array, not a copy of the entire array. This means changes to array elements inside the function affect the original array, but the function doesn't know the array's size unless it's passed as an additional parameter.",
        "hint": "Remember the relationship between arrays and pointers in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How do you pass a 2D array to a function in C?",
        "options": ["void func(int arr[][])", "void func(int **arr)", "void func(int arr[][COLS])", "All of the above are valid"],
        "correctOptionIndex": 2,
        "correctOptionText": "void func(int arr[][COLS])",
        "difficulty": "hard",
        "explanation": "When passing a 2D array to a function in C, you must specify the size of all dimensions except the first one. So, for a 2D array, you must specify the number of columns (COLS), which must be a compile-time constant. The correct syntax is 'void func(int arr[][COLS])'. The options 'void func(int arr[][])' (missing column size) and 'void func(int **arr)' (pointer to pointer, which is not equivalent to a 2D array) are not valid for passing standard 2D arrays.",
        "hint": "The compiler needs to know how to calculate the memory offset for arr[i][j]."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is a variable-length array (VLA) in C?",
        "options": ["An array that can change size after it's created", "An array whose size is determined at runtime", "An array that stores variables of different types", "An array that uses linked list internally"],
        "correctOptionIndex": 1,
        "correctOptionText": "An array whose size is determined at runtime",
        "difficulty": "medium",
        "explanation": "A variable-length array (VLA) in C is an array whose size is determined at runtime rather than compile-time. This feature was introduced in C99. For example, 'int n; scanf(\"%d\", &n); int arr[n];' creates an array whose size depends on user input. VLAs must be local variables (they can't be global or static) and cannot have initializers at declaration. It's important to note that VLAs were made optional in C11, so not all compilers support them.",
        "hint": "This feature from C99 allows stack-allocated arrays with sizes determined during program execution."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What does the following code snippet do?\n```c\nint arr[10];\nmemset(arr, 0, sizeof(arr));\n```",
        "options": ["Allocates memory for an array of 10 integers", "Sets all elements of the array to 0", "Deletes the array from memory", "Copies the array to another location"],
        "correctOptionIndex": 1,
        "correctOptionText": "Sets all elements of the array to 0",
        "difficulty": "medium",
        "explanation": "The memset() function in C is used to fill a block of memory with a particular value. In this code, memset(arr, 0, sizeof(arr)) sets all bytes in the array 'arr' to zero. Since sizeof(arr) gives the total size of the array in bytes, and the second argument (0) specifies the value to set each byte to, this effectively initializes all elements of the integer array to zero. Note that memset works at the byte level, so it should be used with caution for non-byte values other than 0.",
        "hint": "The memset function fills memory with a specified byte value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is wrong with the following code?\n```c\n#include <stdio.h>\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  int arr[n] = {0};\n  return 0;\n}\n```",
        "options": ["Variable-length arrays cannot be initialized at declaration", "The syntax for scanf is incorrect", "Array sizes must be constants", "Nothing is wrong with the code"],
        "correctOptionIndex": 0,
        "correctOptionText": "Variable-length arrays cannot be initialized at declaration",
        "difficulty": "hard",
        "explanation": "In C99, which introduced variable-length arrays (VLAs), you cannot initialize a VLA at its declaration. The line 'int arr[n] = {0};' is therefore invalid. If you need to initialize a VLA, you must do so after declaration, typically with a loop or a function like memset(). For example: 'int arr[n]; for(int i = 0; i < n; i++) arr[i] = 0;' or 'int arr[n]; memset(arr, 0, n * sizeof(int));'.",
        "hint": "There's a specific limitation on what you can do with variable-length arrays compared to fixed-size arrays."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the output of this code?\n```c\n#include <stdio.h>\nint main() {\n  int arr[5] = {1, 2, 3, 4, 5};\n  int *ptr = arr;\n  printf(\"%d %d\", *(ptr+2), ptr[2]);\n  return 0;\n}\n```",
        "options": ["1 1", "2 2", "3 3", "5 5"],
        "correctOptionIndex": 2,
        "correctOptionText": "3 3",
        "difficulty": "medium",
        "explanation": "When 'ptr' is assigned the array 'arr', it points to the first element of the array. The expression '*(ptr+2)' adds 2 to the pointer (moving it 2 elements forward) and then dereferences it, accessing the element at index 2 (the third element), which is 3. Similarly, 'ptr[2]' is equivalent to '*(ptr+2)' and also accesses the element at index 2, which is 3. This demonstrates that pointer arithmetic and array indexing are closely related in C.",
        "hint": "Both notations are accessing the same array element."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "Which of the following statements about jagged arrays in C is true?",
        "options": ["Jagged arrays are a native data type in C", "Jagged arrays can be created using an array of pointers", "Jagged arrays cannot be implemented in C", "Jagged arrays use less memory than rectangular arrays"],
        "correctOptionIndex": 1,
        "correctOptionText": "Jagged arrays can be created using an array of pointers",
        "difficulty": "hard",
        "explanation": "A jagged array (also called ragged array) is an array of arrays where each sub-array can have a different length. While C doesn't have built-in support for jagged arrays as a native type, they can be implemented using an array of pointers, where each pointer points to an array of different length. For example: 'int *jagged[3]; jagged[0] = malloc(5 * sizeof(int)); jagged[1] = malloc(3 * sizeof(int)); jagged[2] = malloc(7 * sizeof(int));'. This creates a jagged array with rows of lengths 5, 3, and 7.",
        "hint": "Think about how to create rows of different lengths in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is the difference between arr and &arr when arr is an array in C?",
        "options": ["They are exactly the same", "arr is a pointer to the first element, &arr is a pointer to the entire array", "arr is the array's value, &arr is the array's address", "There is no valid way to use &arr in C"],
        "correctOptionIndex": 1,
        "correctOptionText": "arr is a pointer to the first element, &arr is a pointer to the entire array",
        "difficulty": "hard",
        "explanation": "When 'arr' is an array in C, 'arr' (in most contexts) decays to a pointer to the first element of the array, equivalent to '&arr[0]', and has type 'pointer to element type'. In contrast, '&arr' is a pointer to the entire array and has type 'pointer to array of N elements of element type'. While they may have the same numeric value (the address of the first element), they have different types and behave differently when incremented or dereferenced. For example, if 'arr' is an int array, then 'arr + 1' advances by one int, while '&arr + 1' advances by the size of the entire array.",
        "hint": "Consider the types of these expressions and how pointer arithmetic works with each."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What does the following code do?\n```c\nint arr1[5] = {1, 2, 3, 4, 5};\nint arr2[5];\nmemcpy(arr2, arr1, sizeof(arr1));\n```",
        "options": ["Creates a symbolic link between arr1 and arr2", "Copies the contents of arr1 to arr2", "Sets all elements of arr2 to be equal to the first element of arr1", "Causes undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "Copies the contents of arr1 to arr2",
        "difficulty": "medium",
        "explanation": "The memcpy() function in C copies a block of memory from a source to a destination. In this code, memcpy(arr2, arr1, sizeof(arr1)) copies sizeof(arr1) bytes from arr1 to arr2. Since sizeof(arr1) gives the total size of arr1 in bytes (which is 5 integers * sizeof(int) bytes), this effectively copies all elements from arr1 to arr2. After this operation, arr2 will contain {1, 2, 3, 4, 5}, the same as arr1.",
        "hint": "memcpy performs a byte-by-byte copy from source to destination."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What will be the output of the following code?\n```c\n#include <stdio.h>\nint main() {\n  int arr[] = {0, 1, 2, 3, 4};\n  int *p = arr;\n  printf(\"%d\", *p++);\n  return 0;\n}\n```",
        "options": ["0", "1", "Address of arr[0]", "Garbage value"],
        "correctOptionIndex": 0,
        "correctOptionText": "0",
        "difficulty": "medium",
        "explanation": "In the expression '*p++', the post-increment operator '++' has lower precedence than the dereference operator '*', but since it's a post-increment, the value of p is used in the expression before it's incremented. So '*p++' first dereferences p to get the value at p (which is arr[0] = 0), then increments p to point to the next element. Therefore, the output is 0. After this statement, p points to arr[1], but this doesn't affect the output of the printf call.",
        "hint": "Consider the operator precedence and the difference between pre-increment and post-increment."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What does the sizeof operator return when applied to an array passed as a function parameter?",
        "options": ["The size of the array in bytes", "The number of elements in the array", "The size of a pointer in bytes", "The memory address of the array"],
        "correctOptionIndex": 2,
        "correctOptionText": "The size of a pointer in bytes",
        "difficulty": "hard",
        "explanation": "When an array is passed to a function in C, it 'decays' to a pointer to its first element. Inside the function, the parameter is effectively a pointer, not an array. Therefore, applying sizeof to this parameter gives the size of the pointer type (typically 4 bytes on 32-bit systems or 8 bytes on 64-bit systems), not the size of the original array. This is why functions that operate on arrays typically require the array size to be passed as a separate parameter.",
        "hint": "Consider what happens to an array when it's passed to a function in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "How can you create a dynamic 2D array in C?",
        "options": [
        "int arr[rows][cols]; // where rows and cols are variables",
        "int **arr = malloc(rows * cols * sizeof(int));",
        "int **arr = malloc(rows * sizeof(int*)); for(int i = 0; i < rows; i++) arr[i] = malloc(cols * sizeof(int));",
        "int arr[][] = new int[rows][cols];"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "int **arr = malloc(rows * sizeof(int*)); for(int i = 0; i < rows; i++) arr[i] = malloc(cols * sizeof(int));",
        "difficulty": "hard",
        "explanation": "To create a dynamic 2D array in C, you typically use a 'pointer to pointer' approach. First, you allocate an array of pointers (one for each row) with 'int **arr = malloc(rows * sizeof(int*))'. Then, for each row pointer, you allocate an array of integers with 'arr[i] = malloc(cols * sizeof(int))'. This creates a jagged array where each row can potentially have a different length. Option A uses VLAs, which may not be supported in all C versions. Option B allocates a single block but doesn't set up the proper 2D structure. Option D uses Java/C++ syntax not valid in C.",
        "hint": "Think about allocating memory for rows first, then for each column."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Arrays",
        "questionText": "What is the purpose of the 'restrict' keyword when used with array parameters in C99?",
        "options": [
          "It makes the array read-only",
          "It informs the compiler that the array cannot be resized",
          "It tells the compiler that the pointer does not alias with any other pointer",
          "It restricts the array to only contain positive values"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "It tells the compiler that the pointer does not alias with any other pointer",
        "difficulty": "hard",
        "explanation": "The 'restrict' keyword in C99 is a type qualifier used for pointers (including array parameters which decay to pointers). It is an optimization hint to the compiler, indicating that for the lifetime of the pointer, only it (or pointers directly derived from it) will access the data it points to. This allows the compiler to make aggressive optimizations like reordering loads/stores, knowing there's no aliasing. However, incorrect use (when aliasing actually exists) leads to undefined behavior.",
        "hint": "Think about compiler optimizations and memory access patterns for pointers."
      },      
        
    // Strings
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which standard library header file is required for using string functions in C?",
        "options": ["<string.h>", "<strings.h>", "<str.h>", "<stdlib.h>"],
        "correctOptionIndex": 0,
        "correctOptionText": "<string.h>",
        "difficulty": "easy",
        "explanation": "The <string.h> header file provides various string handling functions in C, such as strlen(), strcpy(), strcat(), and strcmp().",
        "hint": "This header file name contains the word 'string'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"Hello\";\nprintf(\"%d\", strlen(str));",
        "options": ["5", "6", "4", "Compilation error"],
        "correctOptionIndex": 0,
        "correctOptionText": "5",
        "difficulty": "easy",
        "explanation": "The strlen() function returns the length of a string, not including the null terminator. The string \"Hello\" contains 5 characters, so strlen(str) returns 5.",
        "hint": "Count the number of characters in \"Hello\" and remember that strlen() doesn't count the null terminator."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the correct way to declare a string variable in C?",
        "options": ["string str = \"Hello\";", "char str[] = \"Hello\";", "char* str = Hello;", "str = \"Hello\";"],
        "correctOptionIndex": 1,
        "correctOptionText": "char str[] = \"Hello\";",
        "difficulty": "easy",
        "explanation": "In C, strings are represented as arrays of characters. The declaration char str[] = \"Hello\"; creates a character array initialized with the string \"Hello\" and automatically adds a null terminator.",
        "hint": "C doesn't have a built-in string type - it uses character arrays."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which function is used to compare two strings in C?",
        "options": ["strcomp()", "stringcmp()", "strcmp()", "strcmpr()"],
        "correctOptionIndex": 2,
        "correctOptionText": "strcmp()",
        "difficulty": "easy",
        "explanation": "The strcmp() function compares two strings and returns 0 if they are equal, a negative value if the first string is lexicographically less than the second, or a positive value if the first string is lexicographically greater than the second.",
        "hint": "This function's name is an abbreviation of 'string compare'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar str1[20] = \"Hello\";\nchar str2[] = \" World\";\nstrcat(str1, str2);\nprintf(\"%s\", str1);",
        "options": ["Hello World", "Hello", "World", "HelloWorld"],
        "correctOptionIndex": 0,
        "correctOptionText": "Hello World",
        "difficulty": "easy",
        "explanation": "The strcat() function concatenates the second string to the first string. In this case, it appends \" World\" to \"Hello\", resulting in \"Hello World\".",
        "hint": "strcat() combines two strings by adding the second one to the end of the first."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What does the strcpy() function do in C?",
        "options": ["Compares two strings", "Copies one string to another", "Concatenates two strings", "Calculates the length of a string"],
        "correctOptionIndex": 1,
        "correctOptionText": "Copies one string to another",
        "difficulty": "easy",
        "explanation": "The strcpy() function copies the contents of the source string (including the null terminator) to the destination string. The syntax is strcpy(destination, source).",
        "hint": "The 'cpy' in the function name stands for 'copy'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"Hello\";\nstr[1] = 'a';\nprintf(\"%s\", str);",
        "options": ["Hello", "Hallo", "allo", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "Hallo",
        "difficulty": "easy",
        "explanation": "In C, strings are character arrays, so individual characters can be accessed and modified using array notation. The code changes the second character (index 1) from 'e' to 'a', resulting in \"Hallo\".",
        "hint": "Remember that array indices start at 0, so str[1] refers to the second character."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the difference between char *str = \"Hello\" and char str[] = \"Hello\"?",
        "options": ["No difference, they are the same", "The first creates a pointer to a string literal, the second creates a modifiable array", "The first is invalid syntax", "The second is a compile-time error"],
        "correctOptionIndex": 1,
        "correctOptionText": "The first creates a pointer to a string literal, the second creates a modifiable array",
        "difficulty": "medium",
        "explanation": "char *str = \"Hello\" creates a pointer that points to a string literal, which is stored in read-only memory and cannot be modified. char str[] = \"Hello\" creates an array initialized with the characters of the string, which can be modified.",
        "hint": "Think about where the string data is stored in each case and whether it can be modified."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will happen if we try to execute the following code?\n\nchar *str = \"Hello\";\nstr[0] = 'h';\nprintf(\"%s\", str);",
        "options": ["It will print \"hello\"", "It will print \"Hello\"", "Compilation error", "Runtime error or undefined behavior"],
        "correctOptionIndex": 3,
        "correctOptionText": "Runtime error or undefined behavior",
        "difficulty": "medium",
        "explanation": "The code attempts to modify a string literal, which is typically stored in read-only memory. This results in undefined behavior, often a runtime error like a segmentation fault. String literals should be treated as constants.",
        "hint": "Consider whether string literals can be modified in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which function can be used to find a substring within a string in C?",
        "options": ["strfind()", "substring()", "strstr()", "findstr()"],
        "correctOptionIndex": 2,
        "correctOptionText": "strstr()",
        "difficulty": "medium",
        "explanation": "The strstr() function searches for the first occurrence of a substring within a string. It returns a pointer to the beginning of the first occurrence of the substring, or NULL if the substring is not found.",
        "hint": "The function name combines 'str' (string) with 'str' again, suggesting it finds a string within a string."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar str[] = \"hello world\";\nchar *ptr = strchr(str, 'o');\nprintf(\"%s\", ptr);",
        "options": ["hello world", "o world", "o", "NULL"],
        "correctOptionIndex": 1,
        "correctOptionText": "o world",
        "difficulty": "medium",
        "explanation": "The strchr() function returns a pointer to the first occurrence of the specified character in the string. In this case, it finds 'o' in \"hello world\" and returns a pointer to that position. When printed as a string, it shows all characters from that position to the end of the string.",
        "hint": "strchr() returns a pointer to the specified character, not just the character itself."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the purpose of the strtok() function in C?",
        "options": ["To convert a string to a token", "To tokenize a string into substrings", "To compare two strings for equality", "To sort characters in a string"],
        "correctOptionIndex": 1,
        "correctOptionText": "To tokenize a string into substrings",
        "difficulty": "medium",
        "explanation": "The strtok() function breaks a string into a series of tokens based on a delimiter. It returns a pointer to the first token found in the string, and in subsequent calls with NULL as the first argument, it returns pointers to the remaining tokens.",
        "hint": "Think about what it means to 'tokenize' a string - breaking it into pieces."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "How do you safely copy a string in C to prevent buffer overflow?",
        "options": ["Use strcpy()", "Use strdup()", "Use strncpy()", "Use sprintf()"],
        "correctOptionIndex": 2,
        "correctOptionText": "Use strncpy()",
        "difficulty": "medium",
        "explanation": "The strncpy() function allows you to specify the maximum number of characters to copy, which helps prevent buffer overflow. The syntax is strncpy(dest, src, n), where n is the maximum number of characters to copy.",
        "hint": "Look for a function that limits the number of characters copied."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"123.45\";\nint a = atoi(str);\nprintf(\"%d\", a);",
        "options": ["123.45", "123", "12345", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "123",
        "difficulty": "medium",
        "explanation": "The atoi() function converts a string to an integer. It stops reading the string when it encounters a non-numeric character (in this case, the decimal point). So atoi(\"123.45\") returns 123.",
        "hint": "The atoi() function converts a string to an integer, not a floating-point number."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which function would you use to convert a numeric string to a floating-point value in C?",
        "options": ["atof()", "ftoa()", "strtof()", "stof()"],
        "correctOptionIndex": 0,
        "correctOptionText": "atof()",
        "difficulty": "medium",
        "explanation": "The atof() function converts a string to a double-precision floating-point number. For example, atof(\"123.45\") returns 123.45 as a double.",
        "hint": "The function name stands for 'ASCII to float'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"Hello\";\nprintf(\"%lu\", sizeof(str));",
        "options": ["5", "6", "4", "Depends on the system"],
        "correctOptionIndex": 1,
        "correctOptionText": "6",
        "difficulty": "medium",
        "explanation": "sizeof(str) returns the size of the character array in bytes. For \"Hello\", the array contains 5 characters plus a null terminator ('\\0'), so the total size is 6 bytes.",
        "hint": "Remember that strings in C end with a null terminator, which occupies one byte."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What does the following code print?\n\nchar str[] = \"Hello, World!\";\nprintf(\"%c\", *(str+7));",
        "options": ["H", "W", ",", "o"],
        "correctOptionIndex": 1,
        "correctOptionText": "W",
        "difficulty": "medium",
        "explanation": "The expression *(str+7) dereferences the pointer str+7, which points to the 8th character of the string (since indexing starts at 0). In \"Hello, World!\", the 8th character is 'W'.",
        "hint": "Count the characters in \"Hello, World!\" starting from 0, and find the character at position 7."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will the following code print?\n\nchar str[20] = \"Hello\";\nchar *p = str + strlen(str);\n*p = '!';\n*(p+1) = '\\0';\nprintf(\"%s\", str);",
        "options": ["Hello", "Hello!", "!", "Undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "Hello!",
        "difficulty": "hard",
        "explanation": "str + strlen(str) points to the null terminator of the string \"Hello\". The code replaces this null terminator with '!' and adds a new null terminator after it, effectively adding '!' to the end of the string. The result is \"Hello!\".",
        "hint": "Think about where the pointer p is positioned and what happens when you modify characters at and after that position."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which function would you use to copy a specified number of characters from one string to another, even if the source string contains null characters?",
        "options": ["strcpy()", "strncpy()", "memcpy()", "memmove()"],
        "correctOptionIndex": 2,
        "correctOptionText": "memcpy()",
        "difficulty": "hard",
        "explanation": "Unlike strcpy() and strncpy(), which stop at null characters, memcpy() copies a specified number of bytes regardless of their content. This makes it suitable for copying data that may contain null characters, as well as for copying portions of strings.",
        "hint": "Look for a function that treats the data as raw memory rather than as a null-terminated string."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"Hello, World!\";\nchar *token = strtok(str, \", \");\nwhile (token != NULL) {\n    printf(\"%s\\n\", token);\n    token = strtok(NULL, \", \");\n}",
        "options": ["Hello,\nWorld!", "Hello\nWorld!", "Hello,World!", "Hello, World!"],
        "correctOptionIndex": 1,
        "correctOptionText": "Hello\nWorld!",
        "difficulty": "hard",
        "explanation": "The strtok() function breaks the string into tokens based on the delimiters (in this case, comma and space). The first call returns \"Hello\", and the second call returns \"World!\". Each token is printed on a new line.",
        "hint": "strtok() separates the string at the delimiter characters, which are removed from the output."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar str[] = \"Hello\";\nchar *ptr = str;\nptr += 3;\nprintf(\"%s\", ptr);",
        "options": ["Hello", "llo", "lo", "o"],
        "correctOptionIndex": 2,
        "correctOptionText": "lo",
        "difficulty": "hard",
        "explanation": "The pointer ptr initially points to the beginning of the string \"Hello\". After incrementing it by 3 (ptr += 3), it points to the 4th character (index 3) of the string, which is 'l'. When printed as a string, it shows all characters from that position to the end of the string, which is \"lo\".",
        "hint": "Consider where the pointer is positioned after ptr += 3 and what happens when you print a string starting from that position."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What does the strspn() function do in C?",
        "options": ["Searches for a substring within a string", "Returns the length of the prefix of a string consisting only of characters from another string", "Splits a string into tokens", "Compares two strings for equality"],
        "correctOptionIndex": 1,
        "correctOptionText": "Returns the length of the prefix of a string consisting only of characters from another string",
        "difficulty": "hard",
        "explanation": "The strspn() function calculates the length of the initial segment of the first string that consists entirely of characters from the second string (the accept string). For example, strspn(\"abcdef\", \"abc\") returns 3, because the first three characters of \"abcdef\" are all found in \"abc\".",
        "hint": "Think about 'spanning' - how far can you go in the first string while only using characters from the second?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str1[10] = \"Hello\";\nchar str2[10] = \"World\";\nstrncat(str1, str2, 3);\nprintf(\"%s\", str1);",
        "options": ["HelloWorld", "HelloWor", "Hello", "HelloW"],
        "correctOptionIndex": 3,
        "correctOptionText": "HelloW",
        "difficulty": "hard",
        "explanation": "The strncat() function appends at most n characters from the source string to the destination string. In this case, it appends the first 3 characters of \"World\" (which are 'W', 'o', 'r') to \"Hello\", and then adds a null terminator. However, since only the first 3 characters are requested, only 'W' appears in the output 'HelloW'.",
        "hint": "strncat() appends at most n characters, but it also adds a null terminator, which counts as one of those characters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar str[] = \"12 34 56\";\nint a, b, c;\nsscanf(str, \"%d %d %d\", &a, &b, &c);\nprintf(\"%d\", a + b + c);",
        "options": ["123456", "102", "12", "Error"],
        "correctOptionIndex": 1,
        "correctOptionText": "102",
        "difficulty": "hard",
        "explanation": "The sscanf() function reads formatted input from a string. In this case, it reads three integers from the string \"12 34 56\" and stores them in a, b, and c. The values are 12, 34, and 56, respectively. The sum a + b + c is 12 + 34 + 56 = 102.",
        "hint": "sscanf() parses the string according to the format specifier, extracting the specified values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "How can you reverse a string in C without using library functions?",
        "options": ["It's not possible without library functions", "Use a for loop with two indices", "Use the reverse() function", "Use a while loop with a temporary variable"],
        "correctOptionIndex": 1,
        "correctOptionText": "Use a for loop with two indices",
        "difficulty": "hard",
        "explanation": "To reverse a string without library functions, you can use two indices - one starting from the beginning and one from the end. Swap the characters at these positions and move the indices toward each other until they meet in the middle. This effectively reverses the string in place.",
        "hint": "Think about how you would reverse a string manually - starting from both ends and swapping characters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What is the output of the following code?\n\nchar str[] = \"Hello\\0World\";\nprintf(\"%zu\\n%zu\", strlen(str), sizeof(str) - 1);",
        "options": ["5 11", "11 11", "5 5", "11 5"],
        "correctOptionIndex": 0,
        "correctOptionText": "5 11",
        "difficulty": "hard",
        "explanation": "strlen() returns the length of the string up to the first null character, which is 5 for \"Hello\\0World\". sizeof(str) - 1 returns the size of the array minus 1 for the final null terminator, which is 12 - 1 = 11. The array contains 'H', 'e', 'l', 'l', 'o', '\\0', 'W', 'o', 'r', 'l', 'd', '\\0'.",
        "hint": "strlen() stops at the first null character, while sizeof() gives the total size of the array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar *s1 = \"Hello\";\nchar *s2 = \"Hello\";\nprintf(\"%d\", s1 == s2);",
        "options": ["0", "1", "Undefined behavior", "Compilation error"],
        "correctOptionIndex": 1,
        "correctOptionText": "1",
        "difficulty": "hard",
        "explanation": "When string literals are used in a program, the compiler may optimize by storing identical string literals in the same memory location. In this case, both s1 and s2 may point to the same address, so s1 == s2 evaluates to 1 (true). However, this behavior is implementation-dependent - most modern compilers optimize this way, but it's not guaranteed by the C standard.",
        "hint": "Consider that the comparison is between pointers, not the string contents, and think about how compilers might optimize string literals."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Which function would you use to safely concatenate strings in C while controlling the total buffer size?",
        "options": ["strcat()", "strncat()", "strconcat()", "sprintf()"],
        "correctOptionIndex": 1,
        "correctOptionText": "strncat()",
        "difficulty": "hard",
        "explanation": "The strncat() function allows you to specify the maximum number of characters to append, which helps prevent buffer overflow. The syntax is strncat(dest, src, n), where n is the maximum number of characters to append.",
        "hint": "Look for a function that limits the number of characters appended."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "Given the following code, what is the value of result?\n\nchar str[] = \"52.1\";\ndouble val = atof(str);\nint result = (int)(val * 10);",
        "options": ["52", "521", "5", "520"],
        "correctOptionIndex": 1,
        "correctOptionText": "521",
        "difficulty": "hard",
        "explanation": "The atof() function converts the string \"52.1\" to the double value 52.1. Multiplying by 10 gives 521.0. Casting to int truncates the decimal part, resulting in 521.",
        "hint": "Follow the operations step by step: string conversion, multiplication, then integer casting."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Strings",
        "questionText": "What will be the output of the following code?\n\nchar buffer[20];\nint n = 42;\nint num_chars = sprintf(buffer, \"%d in hex is %x\", n, n);\nprintf(\"%d\", num_chars);",
        "options": ["2", "17", "15", "42"],
        "correctOptionIndex": 2,
        "correctOptionText": "15",
        "difficulty": "hard",
        "explanation": "The sprintf() function writes formatted output to a string buffer. It returns the number of characters written, not including the null terminator. The string \"%d in hex is %x\" with n = 42 produces \"42 in hex is 2a\", which is 15 characters long.",
        "hint": "Count the number of characters in the formatted string \"42 in hex is 2a\"."
    },
    // Pointers
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What does the operator '&' do in C?",
        "options": ["Performs logical AND", "Returns the address of a variable", "Performs bitwise AND", "Dereferences a pointer"],
        "correctOptionIndex": 1,
        "correctOptionText": "Returns the address of a variable",
        "difficulty": "easy",
        "explanation": "The ampersand operator '&' is the address-of operator in C. When used with a variable, it returns the memory address where that variable is stored.",
        "hint": "This operator is commonly used when initializing pointer variables."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What does the operator '*' do when used with a pointer variable?",
        "options": ["Performs multiplication", "Creates a pointer", "Dereferences a pointer", "Allocates memory"],
        "correctOptionIndex": 2,
        "correctOptionText": "Dereferences a pointer",
        "difficulty": "easy",
        "explanation": "The asterisk '*' when used with a pointer variable is called the dereference operator. It accesses the value stored at the memory address contained in the pointer.",
        "hint": "This operator allows you to access what the pointer is pointing to."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the correct way to declare a pointer to an integer in C?",
        "options": ["int ptr;", "pointer int ptr;", "int *ptr;", "int &ptr;"],
        "correctOptionIndex": 2,
        "correctOptionText": "int *ptr;",
        "difficulty": "easy",
        "explanation": "In C, a pointer is declared by placing an asterisk (*) between the data type and the variable name. 'int *ptr;' declares a pointer variable that can store the address of an integer variable.",
        "hint": "The asterisk indicates that the variable will store a memory address rather than a regular value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the value of a pointer that doesn't point to any valid memory location?",
        "options": ["0", "NULL", "void", "undefined"],
        "correctOptionIndex": 1,
        "correctOptionText": "NULL",
        "difficulty": "easy",
        "explanation": "NULL is a special value (usually defined as 0) that is used to indicate that a pointer does not point to any valid memory location. It's a good practice to initialize pointers to NULL when they are not immediately assigned a valid address.",
        "hint": "This special constant is defined in several standard headers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "Which of the following correctly assigns the address of variable 'a' to pointer 'ptr'?",
        "options": ["ptr = a;", "ptr = *a;", "ptr = &a;", "*ptr = a;"],
        "correctOptionIndex": 2,
        "correctOptionText": "ptr = &a;",
        "difficulty": "easy",
        "explanation": "To assign the address of a variable to a pointer, you use the address-of operator '&'. Thus, 'ptr = &a;' assigns the memory address of variable 'a' to the pointer 'ptr'.",
        "hint": "You need to use the operator that returns a memory address."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What happens when you try to dereference a NULL pointer?",
        "options": ["Nothing happens", "The program will continue execution normally", "It results in undefined behavior, often causing a segmentation fault", "It returns 0"],
        "correctOptionIndex": 2,
        "correctOptionText": "It results in undefined behavior, often causing a segmentation fault",
        "difficulty": "medium",
        "explanation": "Dereferencing a NULL pointer is an attempt to access memory at address 0, which is typically not accessible to user programs. This results in undefined behavior, commonly manifesting as a segmentation fault or program crash.",
        "hint": "Think about what happens when you try to access an invalid memory location."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the sizeof(ptr) if ptr is a pointer to a double on a 64-bit system?",
        "options": ["8 bytes", "4 bytes", "Depends on the value stored in ptr", "Same as sizeof(double)"],
        "correctOptionIndex": 0,
        "correctOptionText": "8 bytes",
        "difficulty": "medium",
        "explanation": "On a 64-bit system, all pointers typically have a size of 8 bytes (64 bits), regardless of the data type they point to. This is because the size of a pointer depends on the architecture, not the data type being pointed to.",
        "hint": "The size of a pointer depends on the system architecture, not the type it points to."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is a void pointer in C?",
        "options": ["A pointer that points to a void return type function", "A pointer that cannot be dereferenced", "A pointer with no value", "A generic pointer that can point to any data type"],
        "correctOptionIndex": 3,
        "correctOptionText": "A generic pointer that can point to any data type",
        "difficulty": "medium",
        "explanation": "A void pointer (void*) in C is a special type of pointer that can hold the address of any data type. It serves as a generic pointer type but must be cast to a specific type before dereferencing.",
        "hint": "This type of pointer provides maximum flexibility in terms of what it can point to."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is a dangling pointer?",
        "options": ["A pointer that is not initialized", "A pointer pointing to a memory location that has been freed", "A pointer with NULL value", "A pointer to a pointer"],
        "correctOptionIndex": 1,
        "correctOptionText": "A pointer pointing to a memory location that has been freed",
        "difficulty": "medium",
        "explanation": "A dangling pointer is a pointer that references a memory location that has been deleted (freed) or is out of scope. Accessing such memory leads to undefined behavior, as the memory might have been reallocated for other purposes.",
        "hint": "Think about what happens to a pointer when the memory it points to is deallocated."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the correct way to allocate memory for an integer array of size 'n' using pointers?",
        "options": ["int *arr = malloc(n);", "int *arr = malloc(n * sizeof(int));", "int *arr = new int[n];", "int *arr = calloc(n);"],
        "correctOptionIndex": 1,
        "correctOptionText": "int *arr = malloc(n * sizeof(int));",
        "difficulty": "medium",
        "explanation": "To allocate memory for an array of integers, you need to use malloc() with the total size in bytes. This is calculated by multiplying the number of elements 'n' by the size of each element (sizeof(int)). This ensures the correct amount of memory is allocated.",
        "hint": "Remember to account for the size of each array element."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What does the expression 'ptr++' do?",
        "options": ["Increments the memory address stored in ptr by 1 byte", "Increments the value pointed to by ptr", "Increments the memory address stored in ptr by the size of the data type it points to", "Causes a compilation error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Increments the memory address stored in ptr by the size of the data type it points to",
        "difficulty": "medium",
        "explanation": "When you increment a pointer using 'ptr++', it increases the memory address it holds by the size of the data type it points to. For example, if ptr is an int pointer and sizeof(int) is 4, then ptr++ will add 4 to the address value.",
        "hint": "Pointer arithmetic is scaled by the size of the underlying data type."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "Which of the following correctly declares a pointer to a function that takes an int and returns a float?",
        "options": ["int (*ptr)(float);", "float (*ptr)(int);", "int *ptr(float);", "float *ptr(int);"],
        "correctOptionIndex": 1,
        "correctOptionText": "float (*ptr)(int);",
        "difficulty": "hard",
        "explanation": "The syntax 'float (*ptr)(int);' declares a pointer named 'ptr' to a function that takes an int parameter and returns a float. The parentheses around *ptr are necessary to indicate that ptr is a pointer to a function, not a function that returns a pointer.",
        "hint": "Pay attention to the placement of parentheses and the order of return type and parameter types."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "Consider the code: 'int *p, *q; p = (int*)malloc(sizeof(int)); *p = 10; q = p; free(p);'. What happens if you try to access *q after this code?",
        "options": ["*q will still be 10", "*q will be 0", "*q will be NULL", "Undefined behavior - q is now a dangling pointer"],
        "correctOptionIndex": 3,
        "correctOptionText": "Undefined behavior - q is now a dangling pointer",
        "difficulty": "hard",
        "explanation": "After free(p), the memory pointed to by p is deallocated. Since q points to the same memory location, q becomes a dangling pointer. Attempting to dereference q with *q leads to undefined behavior, which might appear to work sometimes but is not reliable and can cause program crashes.",
        "hint": "Think about what happens when one pointer's memory is freed but another pointer still references that location."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the difference between malloc() and calloc() in C?",
        "options": ["malloc() allocates contiguous memory, calloc() allocates fragmented memory", "malloc() can allocate memory for arrays, calloc() cannot", "malloc() does not initialize the allocated memory, calloc() initializes it to zero", "There is no difference except in the function syntax"],
        "correctOptionIndex": 2,
        "correctOptionText": "malloc() does not initialize the allocated memory, calloc() initializes it to zero",
        "difficulty": "medium",
        "explanation": "Both malloc() and calloc() allocate memory on the heap, but malloc() leaves the memory uninitialized (containing whatever values were there before), while calloc() initializes all allocated memory to zero. Additionally, calloc() takes two parameters (number of elements and size of each), while malloc() takes one (total size).",
        "hint": "Think about the state of the memory right after allocation with each function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is a memory leak in C?",
        "options": ["When a program uses more memory than the system has available", "When dynamically allocated memory is not freed before the program terminates", "When a pointer points to an invalid memory location", "When memory is corrupted due to buffer overflow"],
        "correctOptionIndex": 1,
        "correctOptionText": "When dynamically allocated memory is not freed before the program terminates",
        "difficulty": "medium",
        "explanation": "A memory leak occurs when a program allocates memory dynamically (using malloc, calloc, etc.) but fails to free that memory when it's no longer needed. This leads to wasted memory resources that cannot be reclaimed until the program terminates, potentially causing the program to run out of memory over time.",
        "hint": "Think about what happens when you keep allocating memory but never release it."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the correct way to free memory allocated for a 2D array created using malloc()?",
        "options": ["free(arr);", "free(arr[0]); free(arr);", "for(i=0; i<rows; i++) free(arr[i]); free(arr);", "free(*arr);"],
        "correctOptionIndex": 2,
        "correctOptionText": "for(i=0; i<rows; i++) free(arr[i]); free(arr);",
        "difficulty": "hard",
        "explanation": "When a 2D array is dynamically allocated using separate malloc() calls (one for the array of pointers and one for each row), you must free each row first, then free the array of pointers. Failing to free each individual row first results in memory leaks.",
        "hint": "Consider how many separate malloc() calls were made during allocation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the result of the following code? int a = 10; int *p = &a; int **q = &p; printf(\"%d\", **q);",
        "options": ["Error", "Address of a", "Address of p", "10"],
        "correctOptionIndex": 3,
        "correctOptionText": "10",
        "difficulty": "medium",
        "explanation": "In this code: 'p' is a pointer to 'a', and 'q' is a pointer to pointer 'p'. So *p gives the value of a (10), and **q dereferences q twice: first to get p, then to get the value p points to (which is a's value, 10).",
        "hint": "Follow the chain of dereferencing step by step."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "Which of the following is a valid use of the const keyword with pointers?",
        "options": ["const int* p;", "int const* p;", "int* const p;", "All of the above"],
        "correctOptionIndex": 3,
        "correctOptionText": "All of the above",
        "difficulty": "hard",
        "explanation": "All three declarations are valid but mean different things: 'const int* p;' and 'int const* p;' both declare a pointer to a constant integer (the value pointed to cannot be changed), while 'int* const p;' declares a constant pointer to an integer (the pointer itself cannot be redirected).",
        "hint": "Consider what exactly is being made constant in each case."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the difference between a NULL pointer and a void pointer?",
        "options": ["They are the same thing", "A NULL pointer has a value of 0, while a void pointer can point to any data type", "A NULL pointer is used in arrays, void pointer is used in functions", "A NULL pointer points to memory address 0, void pointer is uninitialized"],
        "correctOptionIndex": 1,
        "correctOptionText": "A NULL pointer has a value of 0, while a void pointer can point to any data type",
        "difficulty": "medium",
        "explanation": "A NULL pointer is a pointer that is assigned the value NULL (typically 0), indicating it doesn't point to any valid memory. A void pointer (void*) is a pointer type that can hold the address of any data type, serving as a generic pointer type. Both concepts are separate: a void pointer can be NULL, and pointers of any type can be NULL.",
        "hint": "One refers to a value a pointer can have, the other to a type of pointer."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What will be the output of the following code? int arr[5] = {1, 2, 3, 4, 5}; int *ptr = arr; printf(\"%d %d\", *ptr, *(ptr+2));",
        "options": ["1 2", "1 3", "0 2", "5 3"],
        "correctOptionIndex": 1,
        "correctOptionText": "1 3",
        "difficulty": "medium",
        "explanation": "In this code, ptr points to the first element of arr, so *ptr gives the first element's value (1). The expression *(ptr+2) accesses the element 2 positions ahead, which is the third element (index 2) with value 3.",
        "hint": "Remember that array names act as pointers to their first elements."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the purpose of realloc() function in C?",
        "options": ["To allocate memory the first time", "To free previously allocated memory", "To change the size of previously allocated memory", "To initialize memory with zeros"],
        "correctOptionIndex": 2,
        "correctOptionText": "To change the size of previously allocated memory",
        "difficulty": "medium",
        "explanation": "The realloc() function is used to resize a memory block previously allocated with malloc(), calloc(), or realloc(). It tries to expand or shrink the existing memory block if possible, or allocates a new block, copies the old data, and frees the old block if necessary.",
        "hint": "This function is useful when you need more or less memory than originally allocated."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the difference between arr and &arr when arr is an array name?",
        "options": ["They are exactly the same", "arr gives the address of the first element, &arr gives the address of the entire array", "arr is a value, &arr is a pointer", "There is no difference in values but they have different types"],
        "correctOptionIndex": 3,
        "correctOptionText": "There is no difference in values but they have different types",
        "difficulty": "hard",
        "explanation": "When arr is an array, both arr and &arr yield the same address value, but they have different types: arr decays to a pointer to the first element (type int* for an int array), while &arr is a pointer to the entire array (type int(*)[n] for an int array of size n). This distinction affects pointer arithmetic operations.",
        "hint": "Consider how the compiler interprets the array name in different contexts."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "In C, what is the behavior of the post-increment operator in an expression like *ptr++?",
        "options": ["First dereference ptr, then increment the value it points to", "First dereference ptr, then increment ptr itself", "First increment ptr, then dereference the new address", "This expression causes a syntax error"],
        "correctOptionIndex": 1,
        "correctOptionText": "First dereference ptr, then increment ptr itself",
        "difficulty": "hard",
        "explanation": "The expression *ptr++ is parsed as *(ptr++) due to operator precedence. The post-increment operator (++) has higher precedence than the dereference operator (*), but since it's post-increment, the value of ptr is used before incrementing. So it first dereferences the current address in ptr, then increments ptr to point to the next memory location.",
        "hint": "Consider the precedence and associativity of the * and ++ operators."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What happens in the following code? int *ptr = (int *)malloc(sizeof(int)); free(ptr); free(ptr);",
        "options": ["Nothing, it's perfectly valid code", "Memory leak", "Undefined behavior - double free error", "Compilation error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Undefined behavior - double free error",
        "difficulty": "medium",
        "explanation": "Freeing the same memory block twice (double free) results in undefined behavior. It might cause your program to crash, corrupt the heap, or seem to work correctly in some cases. Most modern systems will detect this error and terminate the program with a message like 'double free detected'.",
        "hint": "Think about what happens when you try to release a resource that has already been released."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is a wild pointer in C?",
        "options": ["A pointer that is initialized with NULL", "A pointer that points to a deleted variable", "A pointer that has not been initialized", "A pointer to a void type"],
        "correctOptionIndex": 2,
        "correctOptionText": "A pointer that has not been initialized",
        "difficulty": "medium",
        "explanation": "A wild pointer is an uninitialized pointer that contains a garbage value and points to some arbitrary memory location. Using such a pointer can lead to undefined behavior, including program crashes and security vulnerabilities. It's good practice to initialize pointers to NULL if they don't immediately point to valid memory.",
        "hint": "Think about the state of a pointer variable right after it's declared but before any assignment."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What does the following declaration mean? const char * const ptr;",
        "options": ["ptr is a modifiable pointer to a constant character", "ptr is a constant pointer to a modifiable character", "ptr is a constant pointer to a constant character", "None of the above"],
        "correctOptionIndex": 2,
        "correctOptionText": "ptr is a constant pointer to a constant character",
        "difficulty": "hard",
        "explanation": "The declaration 'const char * const ptr;' has two const keywords. The first 'const' (const char) makes the character that ptr points to constant (cannot be modified). The second 'const' (const ptr) makes the pointer itself constant (cannot be reassigned to point elsewhere). So ptr is a constant pointer to a constant character.",
        "hint": "Read the declaration from right to left, noting what each const applies to."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "Which of the following is the correct way to declare a pointer to an array of 10 integers?",
        "options": ["int (*ptr)[10];", "int *ptr[10];", "int ptr[10];", "int *ptr(10);"],
        "correctOptionIndex": 0,
        "correctOptionText": "int (*ptr)[10];",
        "difficulty": "hard",
        "explanation": "The declaration 'int (*ptr)[10];' defines 'ptr' as a pointer to an array of 10 integers. The parentheses are crucial here: without them, 'int *ptr[10];' would instead declare an array of 10 pointers to integers, which is a very different type.",
        "hint": "Pay careful attention to the placement of parentheses and its effect on the interpretation of the declaration."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What's the output of this code? void f(int x, int *py, int **ppz) { **ppz += 1; *py += 2; x += 3; } int main() { int c, *b, **a; c = 4; b = &c; a = &b; f(c, b, a); printf(\"%d\", c); return 0; }",
        "options": ["4", "5", "6", "7"],
        "correctOptionIndex": 2,
        "correctOptionText": "6",
        "difficulty": "hard",
        "explanation": "In function f(), **ppz += 1 increments c by 1 (since ppz points to b, which points to c), making c = 5. Then *py += 2 increments c by 2 more (since py points to c), making c = 7. The x += 3 only modifies the local parameter x. However, in printf, we're printing the value of c which is now 7.",
        "hint": "Trace the execution carefully, noting which variables are affected by each operation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is the key difference between passing an array by value and passing a pointer to an array in a function parameter?",
        "options": ["There is no difference", "Arrays cannot be passed by value in C", "Passing by value copies the entire array, passing a pointer only copies the address", "Passing a pointer allows modification of the original array"],
        "correctOptionIndex": 1,
        "correctOptionText": "Arrays cannot be passed by value in C",
        "difficulty": "medium",
        "explanation": "In C, arrays cannot be passed by value to functions. When you appear to pass an array as a parameter, it actually decays into a pointer to its first element. This is why array parameters are always modified by the called function - you're actually passing a pointer to the original array, not a copy of it.",
        "hint": "Think about the fundamental behavior of arrays when used in function calls."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Pointers",
        "questionText": "What is pointer arithmetic in C?",
        "options": ["Using mathematical operations like +, -, *, / with pointers", "Performing calculations on memory addresses", "Adding or subtracting integers from pointers to navigate through memory", "All arithmetic operations that involve pointers"],
        "correctOptionIndex": 2,
        "correctOptionText": "Adding or subtracting integers from pointers to navigate through memory",
        "difficulty": "easy",
        "explanation": "Pointer arithmetic in C refers to operations that allow adding or subtracting integers from pointers to navigate through memory. The key aspect is that when you add 1 to a pointer, it actually increments the address by the size of the data type the pointer points to, allowing easy navigation through arrays and data structures.",
        "hint": "This feature makes accessing sequential elements in memory convenient."
    },

    // Structures & Unions
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the correct way to declare a structure in C?",
        "options": ["struct { int a; float b; };", "structure Person { int age; char name[50]; };", "struct Person { int age; char name[50]; };", "typedef { int age; char name[50]; } Person;"],
        "correctOptionIndex": 2,
        "correctOptionText": "struct Person { int age; char name[50]; };",
        "difficulty": "easy",
        "explanation": "In C, a structure is declared using the 'struct' keyword followed by an optional tag name (Person in this case) and the member variables enclosed in curly braces. This syntax correctly declares a structure named Person with two members: an int and a character array.",
        "hint": "The keyword 'struct' is required when declaring a structure."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "How do you access a member of a structure using a structure variable?",
        "options": ["var->member", "var::member", "var.member", "var[member]"],
        "correctOptionIndex": 2,
        "correctOptionText": "var.member",
        "difficulty": "easy",
        "explanation": "To access a member of a structure using a structure variable, you use the dot (.) operator. For example, if 'student' is a structure variable and 'age' is a member, you would access it as 'student.age'.",
        "hint": "The dot operator is used with structure variables to access members."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "How do you access a member of a structure using a pointer to a structure?",
        "options": ["ptr.member", "ptr::member", "(*ptr).member", "All of the above"],
        "correctOptionIndex": 2,
        "correctOptionText": "(*ptr).member",
        "difficulty": "easy",
        "explanation": "When using a pointer to a structure, you first need to dereference the pointer using (*ptr) and then use the dot operator to access the member. So, if 'ptr' is a pointer to a structure and 'age' is a member, you would access it as '(*ptr).age'.",
        "hint": "You need to dereference the pointer first before using the dot operator."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which operator is commonly used as a shorthand for accessing structure members through a pointer?",
        "options": ["->", ".", "*", "&"],
        "correctOptionIndex": 0,
        "correctOptionText": "->",
        "difficulty": "easy",
        "explanation": "The arrow operator (->) is a shorthand for dereferencing a pointer and accessing a structure member. If 'ptr' is a pointer to a structure and 'age' is a member, 'ptr->age' is equivalent to '(*ptr).age' but is more concise and readable.",
        "hint": "This operator combines dereferencing and member access in a single operation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the main difference between a structure and a union in C?",
        "options": ["Structures can contain functions, unions cannot", "Structures can be nested, unions cannot", "In a structure, all members share the same memory location; in a union, each member has its own memory location", "In a structure, each member has its own memory location; in a union, all members share the same memory location"],
        "correctOptionIndex": 3,
        "correctOptionText": "In a structure, each member has its own memory location; in a union, all members share the same memory location",
        "difficulty": "medium",
        "explanation": "The fundamental difference between structures and unions is in memory allocation. In a structure, each member has its own distinct memory location, so the size of the structure is (at least) the sum of its members' sizes. In a union, all members share the same memory location, so the size of the union is the size of its largest member.",
        "hint": "Think about how memory is allocated for each type."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following correctly declares a union in C?",
        "options": ["union { int i; float f; };", "typedef union { int i; float f; } Number;", "union Number { int i; float f; };", "All of the above"],
        "correctOptionIndex": 3,
        "correctOptionText": "All of the above",
        "difficulty": "medium",
        "explanation": "All the given options are valid ways to declare a union in C. The first declares an anonymous union, the second declares a union and creates a typedef for it, and the third declares a named union. Each declares a union that can hold either an integer or a float at any given time.",
        "hint": "Unions can be declared similarly to structures, with several valid syntaxes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the size of the following union? union Data { int i; float f; char str[20]; };",
        "options": ["4 bytes", "8 bytes", "20 bytes", "25 bytes"],
        "correctOptionIndex": 2,
        "correctOptionText": "20 bytes",
        "difficulty": "medium",
        "explanation": "The size of a union is determined by its largest member. In this union, the members are: int (typically 4 bytes), float (typically 4 bytes), and char[20] (20 bytes). Since the character array is the largest, the union size will be 20 bytes.",
        "hint": "A union's size is determined by the size of its largest member to ensure all members can fit in the shared space."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the purpose of using a union in C?",
        "options": ["To create inheritance relationships between data types", "To save memory by using the same memory location for different variables at different times", "To organize related data of the same type", "To create thread-safe data structures"],
        "correctOptionIndex": 1,
        "correctOptionText": "To save memory by using the same memory location for different variables at different times",
        "difficulty": "medium",
        "explanation": "The primary purpose of unions is memory efficiency. A union allows different variables to share the same memory location, which is useful when you need to store different types of data but never need to use them simultaneously. This saves memory compared to using a structure, where each member has its own memory location.",
        "hint": "Think about the memory allocation behavior of unions and when this would be beneficial."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What happens if you assign a value to one member of a union and then access another member?",
        "options": ["Compilation error", "Runtime error", "You get undefined behavior", "You get a reinterpreted view of the same memory"],
        "correctOptionIndex": 3,
        "correctOptionText": "You get a reinterpreted view of the same memory",
        "difficulty": "medium",
        "explanation": "When you assign a value to one member of a union and then access another member, you're viewing the same memory location as a different data type. This provides a reinterpreted view of the same bits. This can be intentionally used for type punning but should be done with caution as it may lead to unexpected results due to differences in representation.",
        "hint": "Consider what it means for all members to share the same memory space."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is structure padding in C?",
        "options": ["Extra memory added to ensure structure members are properly aligned", "A technique to compress structure data", "Unused memory at the end of a structure", "A way to initialize structure members to zero"],
        "correctOptionIndex": 0,
        "correctOptionText": "Extra memory added to ensure structure members are properly aligned",
        "difficulty": "medium",
        "explanation": "Structure padding is the insertion of unused bytes of memory between structure members or at the end of the structure by the compiler. This is done to ensure that each member is properly aligned according to its memory alignment requirements, which helps in efficient memory access by the CPU.",
        "hint": "This is related to memory alignment requirements of different data types."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following correctly creates a typedef for a structure in C?",
        "options": ["typedef { int x, y; } Point;", "typedef struct { int x, y; } Point;", "typedef Point struct { int x, y; };", "struct typedef Point { int x, y; };"],
        "correctOptionIndex": 1,
        "correctOptionText": "typedef struct { int x, y; } Point;",
        "difficulty": "medium",
        "explanation": "The correct way to create a typedef for a structure is to use the 'typedef' keyword followed by the structure definition and then the alias name. In this case, 'typedef struct { int x, y; } Point;' creates a new type 'Point' that represents the anonymous structure with integer members x and y.",
        "hint": "The typedef keyword is used to create an alias for a type, and comes before the type being aliased."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "How can you initialize a structure variable at the time of declaration in C?",
        "options": ["struct Point p = (10, 20);", "struct Point p = {10, 20};", "struct Point p = Point(10, 20);", "struct Point p(10, 20);"],
        "correctOptionIndex": 1,
        "correctOptionText": "struct Point p = {10, 20};",
        "difficulty": "easy",
        "explanation": "In C, you can initialize a structure variable at the time of declaration using a brace-enclosed list of initializers. The values are assigned to the members in the order they appear in the structure definition. So, 'struct Point p = {10, 20};' initializes p.x to 10 and p.y to 20.",
        "hint": "This uses an initializer list enclosed in braces."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is a self-referential structure in C?",
        "options": ["A structure that contains a member of its own type", "A structure that contains a pointer to its own type", "A structure that can be automatically initialized", "A structure with private members"],
        "correctOptionIndex": 1,
        "correctOptionText": "A structure that contains a pointer to its own type",
        "difficulty": "hard",
        "explanation": "A self-referential structure is a structure that contains a pointer to its own type as a member. This is common in data structures like linked lists and trees. For example: 'struct Node { int data; struct Node* next; };' defines a self-referential structure where each node can point to another node of the same type.",
        "hint": "Think about how linked lists and trees are implemented in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the correct way to pass a structure to a function in C?",
        "options": ["By value only", "By reference only", "Either by value or by passing a pointer to the structure", "Structures cannot be passed to functions"],
        "correctOptionIndex": 2,
        "correctOptionText": "Either by value or by passing a pointer to the structure",
        "difficulty": "medium",
        "explanation": "In C, structures can be passed to functions either by value (which makes a copy of the entire structure) or by passing a pointer to the structure (which allows the function to modify the original structure). The choice depends on whether you need to modify the original structure and considerations about efficiency with large structures.",
        "hint": "Consider the different ways parameters can be passed in C functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following is true about nested structures in C?",
        "options": ["Nested structures are not allowed in C", "A structure can contain a member that is of another structure type", "A structure can be nested only within a union", "Nested structures require special memory allocation"],
        "correctOptionIndex": 1,
        "correctOptionText": "A structure can contain a member that is of another structure type",
        "difficulty": "easy",
        "explanation": "C allows nested structures, which means a structure can contain a member that is of another structure type. This is useful for organizing related data hierarchically. For example, a 'Person' structure might contain an 'Address' structure as one of its members.",
        "hint": "This feature allows for hierarchical organization of data."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What happens when you assign one structure variable to another in C?",
        "options": ["Only the reference is copied", "The assignment is not allowed", "A shallow copy is performed", "A deep copy (memberwise copy) is performed"],
        "correctOptionIndex": 3,
        "correctOptionText": "A deep copy (memberwise copy) is performed",
        "difficulty": "medium",
        "explanation": "When one structure variable is assigned to another in C (e.g., struct1 = struct2), a memberwise copy (deep copy) is performed. This means the values of all members in the source structure are copied to the corresponding members in the destination structure. However, note that for pointer members, only the pointer value is copied, not the data it points to.",
        "hint": "Think about how the assignment operator works with structures."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following is NOT a valid way to declare an array of structures?",
        "options": ["struct Point points[10];", "struct Point { int x; int y; } points[10];", "struct Point *points = malloc(10 * sizeof(struct Point));", "struct Point points = new Point[10];"],
        "correctOptionIndex": 3,
        "correctOptionText": "struct Point points = new Point[10];",
        "difficulty": "medium",
        "explanation": "The syntax 'struct Point points = new Point[10];' is not valid in C. It uses the 'new' operator, which is a C++ concept, not C. The other options are valid: declaring an array of structures directly, declaring and defining a structure type with an array in one statement, and dynamically allocating an array of structures using malloc().",
        "hint": "C doesn't have the 'new' operator; it uses functions like malloc() for dynamic allocation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is a bit field in C structures?",
        "options": ["A way to specify the exact memory layout of a structure", "A collection of bits that don't need to conform to byte boundaries", "A binary representation of structure data", "A method to encrypt structure data"],
        "correctOptionIndex": 1,
        "correctOptionText": "A collection of bits that don't need to conform to byte boundaries",
        "difficulty": "hard",
        "explanation": "Bit fields in C structures allow you to specify the number of bits a member occupies, instead of the default size of its type. This is useful for saving memory when you know a value requires fewer bits than the full type provides. For example: 'struct Flags { unsigned int flag1 : 1; unsigned int flag2 : 1; };' defines two 1-bit flags that together might occupy just a single byte.",
        "hint": "This feature allows for more efficient memory usage for certain types of data."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What does the '#pragma pack' directive do in relation to structures?",
        "options": ["It optimizes the structure for faster access", "It encrypts the structure data", "It controls the alignment and padding of structure members", "It declares a structure as thread-safe"],
        "correctOptionIndex": 2,
        "correctOptionText": "It controls the alignment and padding of structure members",
        "difficulty": "hard",
        "explanation": "The '#pragma pack' directive is a compiler-specific directive that controls the alignment and padding of structure members. It allows you to specify a maximum alignment value, which can be used to reduce the amount of padding the compiler adds. This is sometimes necessary for structures that need to match a specific memory layout, such as when interfacing with hardware or external data formats.",
        "hint": "This directive affects how the compiler allocates memory for structure members."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the purpose of using 'typedef' with structures in C?",
        "options": ["To make the structure occupy less memory", "To create a simpler name for the structure type", "To make the structure members private", "To enable inheritance between structures"],
        "correctOptionIndex": 1,
        "correctOptionText": "To create a simpler name for the structure type",
        "difficulty": "easy",
        "explanation": "The primary purpose of using 'typedef' with structures in C is to create a simpler alias for the structure type. Without typedef, you would need to use 'struct Tag' every time you declare a variable of that structure type. With typedef, you can define a new type name that doesn't require the 'struct' keyword, making your code cleaner and more readable.",
        "hint": "This is mainly about syntax convenience and code readability."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following correctly declares a structure with bit fields?",
        "options": ["struct Bits { int a:1; int b:2; };", "struct Bits { bits int a:1; bits int b:2; };", "struct Bits { bitfield int a:1; bitfield int b:2; };", "struct Bits { int a bits:1; int b bits:2; };"],
        "correctOptionIndex": 0,
        "correctOptionText": "struct Bits { int a:1; int b:2; };",
        "difficulty": "hard",
        "explanation": "The correct syntax for declaring bit fields in a structure is to specify the type of the member followed by a colon and the number of bits it should occupy. In this example, 'int a:1;' declares a 1-bit field named 'a', and 'int b:2;' declares a 2-bit field named 'b'.",
        "hint": "The colon after the member name is followed by the number of bits."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the main advantage of using a union over a structure for certain applications?",
        "options": ["Unions are more type-safe", "Unions provide better encapsulation", "Unions use memory more efficiently in certain scenarios", "Unions allow for inheritance"],
        "correctOptionIndex": 2,
        "correctOptionText": "Unions use memory more efficiently in certain scenarios",
        "difficulty": "medium",
        "explanation": "The main advantage of using a union over a structure is memory efficiency in scenarios where you need to store different types of data, but only one at a time. Since all members of a union share the same memory space, a union uses only as much memory as its largest member, whereas a structure would require enough memory for all members combined.",
        "hint": "Consider the memory allocation characteristics of unions versus structures."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is a common use case for a union in C?",
        "options": ["To create object-oriented hierarchies", "To implement polymorphism", "To create type-safe containers", "To create a variant data type that can hold different types of values"],
        "correctOptionIndex": 3,
        "correctOptionText": "To create a variant data type that can hold different types of values",
        "difficulty": "medium",
        "explanation": "A common use case for unions in C is to create variant data types that can hold values of different types at different times. This is useful when you need a variable that can represent different kinds of data depending on the context, but you only need to store one type at a time. This approach is often combined with an enumeration or flag to track which type is currently stored.",
        "hint": "Think about scenarios where a variable might need to represent different data types in different contexts."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is an anonymous union in C?",
        "options": ["A union with no members", "A union with no name that is declared inside a structure", "A union that cannot be accessed", "A union that is automatically type-cast"],
        "correctOptionIndex": 1,
        "correctOptionText": "A union with no name that is declared inside a structure",
        "difficulty": "hard",
        "explanation": "An anonymous union is a union that has no name and is declared inside a structure. The members of the anonymous union are directly accessible as if they were members of the containing structure. This is useful for creating variant records where some fields are mutually exclusive. For example: 'struct S { int type; union { int i; float f; }; };' allows 's.i' and 's.f' to be used directly.",
        "hint": "This feature allows for more concise access to union members in certain contexts."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What will be the output of the following code? struct S { int i; char c; } s; printf(\"%lu\", sizeof(s));",
        "options": ["4", "5", "8", "Depends on the compiler and platform"],
        "correctOptionIndex": 3,
        "correctOptionText": "Depends on the compiler and platform",
        "difficulty": "medium",
        "explanation": "The size of a structure in C depends on the compiler and platform, specifically due to padding and alignment requirements. While the structure contains an int (typically 4 bytes) and a char (1 byte), the compiler might add padding after the char for alignment purposes. On many systems, this structure might be 8 bytes due to alignment to a 4-byte boundary, but it could vary.",
        "hint": "Consider memory alignment requirements and how they affect structure size."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following is true about comparing structures in C?",
        "options": ["Structures can be compared using the == operator", "Structures can be compared using the strcmp() function", "Structures cannot be directly compared; you must compare their members individually", "Structures can only be compared if they are the same type"],
        "correctOptionIndex": 2,
        "correctOptionText": "Structures cannot be directly compared; you must compare their members individually",
        "difficulty": "medium",
        "explanation": "In C, structures cannot be directly compared using operators like == or !=. To compare structures, you must compare their individual members using a field-by-field comparison. This is because C does not provide built-in operators for comparing composite types like structures.",
        "hint": "Consider what operations are directly supported on structure variables in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is a flexible array member in a C structure?",
        "options": ["A member that can change its type at runtime", "An array member with no specified size at the end of a structure", "An array that can grow or shrink dynamically", "A pointer to dynamically allocated memory"],
        "correctOptionIndex": 1,
        "correctOptionText": "An array member with no specified size at the end of a structure",
        "difficulty": "hard",
        "explanation": "A flexible array member is a feature introduced in C99 that allows for an array member with unspecified size to be declared as the last member of a structure. This is denoted by writing the array with empty brackets, like 'int data[];'. The actual size is determined when allocating memory for the structure, allowing for variable-sized structures. This is useful for implementing structures with variable-length data.",
        "hint": "This feature was introduced in C99 and is commonly used for variable-length records."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What happens if you try to compare two unions with the == operator in C?",
        "options": ["It compares the current active members of both unions", "It compares all possible members of both unions", "It results in a compilation error", "It performs a byte-by-byte comparison of the unions"],
        "correctOptionIndex": 2,
        "correctOptionText": "It results in a compilation error",
        "difficulty": "medium",
        "explanation": "In C, just like with structures, you cannot directly compare unions using operators like == or !=. The == operator is not defined for union types in C. Attempting to do so will result in a compilation error. To compare unions, you would need to know which member is active and then compare those specific members individually.",
        "hint": "Consider the limitations of built-in operators when dealing with composite types in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the purpose of the 'offsetof()' macro in relation to structures?",
        "options": ["To calculate the total size of a structure", "To find the byte offset of a member within a structure", "To allocate memory for a structure", "To align a structure to a memory boundary"],
        "correctOptionIndex": 1,
        "correctOptionText": "To find the byte offset of a member within a structure",
        "difficulty": "hard",
        "explanation": "The 'offsetof()' macro, defined in <stddef.h>, calculates the byte offset of a member within a structure. It returns the number of bytes from the beginning of the structure to the specified member. This is useful for low-level memory manipulation, serialization, and working with memory-mapped structures. For example, 'offsetof(struct S, member)' gives the offset of 'member' in 'struct S'.",
        "hint": "This macro is useful when you need to know the exact memory layout of a structure."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "Which of the following is a valid use of designated initializers for structures in C99?",
        "options": ["struct Point p = {.x = 10, .y = 20};", "struct Point p = {x: 10, y: 20};", "struct Point p = {\"x\" = 10, \"y\" = 20};", "struct Point p = {x => 10, y => 20};"],
        "correctOptionIndex": 0,
        "correctOptionText": "struct Point p = {.x = 10, .y = 20};",
        "difficulty": "medium",
        "explanation": "Designated initializers, introduced in C99, allow you to initialize specific members of a structure by name, regardless of their order. The correct syntax uses a period followed by the member name, then an equals sign and the value. So, 'struct Point p = {.x = 10, .y = 20};' initializes the 'x' member to 10 and the 'y' member to 20.",
        "hint": "This feature was introduced in C99 to make structure initialization more flexible and readable."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the value of sizeof(union { char c; int i; float f; })?",
        "options": ["1 byte", "4 bytes", "The sum of sizeof(char), sizeof(int), and sizeof(float)", "The maximum of sizeof(char), sizeof(int), and sizeof(float)"],
        "correctOptionIndex": 3,
        "correctOptionText": "The maximum of sizeof(char), sizeof(int), and sizeof(float)",
        "difficulty": "medium",
        "explanation": "The size of a union is the size of its largest member, possibly with padding for alignment. In this case, char is 1 byte, int is typically 4 bytes, and float is typically 4 bytes. So the union's size would be 4 bytes (assuming float and int are the same size). This allows the union to accommodate any of its potential members in the same memory space.",
        "hint": "A union must be large enough to hold any of its members."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Structures & Unions",
        "questionText": "What is the most appropriate scenario to use a union instead of a structure?",
        "options": ["When you need to store multiple values simultaneously", "When you need to store a single value that could be of different types at different times", "When you need to pass complex data to a function", "When you need to create a linked list"],
        "correctOptionIndex": 1,
        "correctOptionText": "When you need to store a single value that could be of different types at different times",
        "difficulty": "medium",
        "explanation": "The most appropriate scenario to use a union is when you need to store a single value that could be of different types at different times, but never simultaneously. This is because a union stores different data types in the same memory location, allowing only one to be active at a time. This is useful for variant types or when memory optimization is important.",
        "hint": "Consider the fundamental characteristic of unions: shared memory space for multiple possible representations."
    },

    // Memory Management
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which function is used to allocate memory on the heap in C?",
        "options": ["new()", "malloc()", "alloc()", "create()"],
        "correctOptionIndex": 1,
        "correctOptionText": "malloc()",
        "difficulty": "easy",
        "explanation": "The malloc() function in C is used to allocate a specified number of bytes on the heap (dynamic memory). It returns a void pointer to the allocated memory, which can be cast to the desired type.",
        "hint": "This function's name comes from 'memory allocation'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What header file must be included to use memory allocation functions in C?",
        "options": ["<memory.h>", "<stdlib.h>", "<malloc.h>", "<heap.h>"],
        "correctOptionIndex": 1,
        "correctOptionText": "<stdlib.h>",
        "difficulty": "easy",
        "explanation": "The <stdlib.h> header file contains the declarations for memory allocation functions like malloc(), calloc(), realloc(), and free() in standard C.",
        "hint": "This is the standard library header file in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is returned by malloc() if memory allocation fails?",
        "options": ["0", "NULL", "-1", "An exception is thrown"],
        "correctOptionIndex": 1,
        "correctOptionText": "NULL",
        "difficulty": "easy",
        "explanation": "When malloc() fails to allocate the requested memory, it returns NULL. It's important to check this return value to handle memory allocation failures gracefully.",
        "hint": "This is a special pointer value indicating that no memory was allocated."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which function allocates memory and initializes it to zero?",
        "options": ["malloc()", "calloc()", "realloc()", "zalloc()"],
        "correctOptionIndex": 1,
        "correctOptionText": "calloc()",
        "difficulty": "easy",
        "explanation": "The calloc() function allocates memory for an array of elements, initializes all bytes to zero, and returns a pointer to the allocated memory. It takes two arguments: the number of elements and the size of each element.",
        "hint": "The name comes from 'clear allocation'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which function is used to release dynamically allocated memory in C?",
        "options": ["delete()", "release()", "free()", "dealloc()"],
        "correctOptionIndex": 2,
        "correctOptionText": "free()",
        "difficulty": "easy",
        "explanation": "The free() function is used to deallocate memory that was previously allocated by malloc(), calloc(), or realloc(). It takes a pointer to the allocated memory as its argument.",
        "hint": "This function returns memory to the system."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What happens if you call free() on a pointer that was already freed?",
        "options": ["Nothing", "Memory leak", "Undefined behavior", "Runtime error with detailed message"],
        "correctOptionIndex": 2,
        "correctOptionText": "Undefined behavior",
        "difficulty": "medium",
        "explanation": "Calling free() on an already freed pointer (double free) results in undefined behavior. This can lead to program crashes, corruption of memory management data structures, or other unpredictable issues.",
        "hint": "The C standard doesn't specify what should happen in this case."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the difference between malloc() and calloc() regarding initialization?",
        "options": ["malloc() initializes memory to zero, calloc() doesn't", "calloc() initializes memory to zero, malloc() doesn't", "Both initialize memory to zero", "Neither initializes memory"],
        "correctOptionIndex": 1,
        "correctOptionText": "calloc() initializes memory to zero, malloc() doesn't",
        "difficulty": "medium",
        "explanation": "calloc() initializes all allocated bytes to zero, while malloc() does not initialize the allocated memory, leaving it with whatever values were previously in that memory location.",
        "hint": "One function provides 'clean' memory, the other just provides memory."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which function is used to change the size of a previously allocated memory block?",
        "options": ["resize()", "realloc()", "remalloc()", "reallocate()"],
        "correctOptionIndex": 1,
        "correctOptionText": "realloc()",
        "difficulty": "medium",
        "explanation": "The realloc() function changes the size of a previously allocated memory block. It may move the memory block to a new location if necessary, in which case it copies the old data to the new location.",
        "hint": "The name is short for 'reallocate'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the correct way to allocate memory for an array of 10 integers using malloc()?",
        "options": ["int *arr = malloc(10);", "int *arr = malloc(10 * sizeof(int));", "int *arr = malloc(sizeof(int[10]));", "Both B and C are correct"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both B and C are correct",
        "difficulty": "medium",
        "explanation": "Both 'malloc(10 * sizeof(int))' and 'malloc(sizeof(int[10]))' correctly allocate enough memory for 10 integers. The first approach multiplies the size of one integer by 10, while the second gets the size of an array of 10 integers directly.",
        "hint": "Consider the total amount of memory needed for the array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is a memory leak in C?",
        "options": ["When memory is allocated but never freed", "When a program uses too much memory", "When a program crashes due to memory corruption", "When memory is freed twice"],
        "correctOptionIndex": 0,
        "correctOptionText": "When memory is allocated but never freed",
        "difficulty": "medium",
        "explanation": "A memory leak occurs when a program allocates memory dynamically but loses all references to that memory without freeing it. This leads to memory that remains allocated but can't be used or freed, gradually consuming system resources.",
        "hint": "Think about what happens to allocated memory that's no longer accessible."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Where is dynamically allocated memory stored in C?",
        "options": ["Stack", "Heap", "Register", "Static memory"],
        "correctOptionIndex": 1,
        "correctOptionText": "Heap",
        "difficulty": "medium",
        "explanation": "Dynamically allocated memory (using malloc(), calloc(), etc.) is stored in the heap, which is a region of memory used for dynamic memory allocation. Unlike stack memory, heap memory is not automatically deallocated when a function returns.",
        "hint": "This memory region is managed by malloc and free functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What problem can occur if you access memory after it has been freed?",
        "options": ["Memory leak", "Buffer overflow", "Use-after-free vulnerability", "Memory fragmentation"],
        "correctOptionIndex": 2,
        "correctOptionText": "Use-after-free vulnerability",
        "difficulty": "medium",
        "explanation": "Accessing memory after it has been freed (use-after-free) leads to undefined behavior and can cause program crashes or security vulnerabilities. The memory might be reallocated for another purpose, causing data corruption or exploitation.",
        "hint": "This is a common security vulnerability in C programs."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the correct parameter to free() when deallocating a dynamically allocated array?",
        "options": ["The address of the first element", "The address of the last element", "The entire array", "A pointer to the allocated memory"],
        "correctOptionIndex": 3,
        "correctOptionText": "A pointer to the allocated memory",
        "difficulty": "medium",
        "explanation": "When freeing a dynamically allocated array, you should pass the original pointer returned by malloc()/calloc()/realloc() to free(). This is typically the address of the first element of the array, but conceptually you're freeing the entire allocated block.",
        "hint": "You need to pass the same pointer that was returned by the allocation function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is a dangling pointer in C?",
        "options": ["A pointer that points to NULL", "A pointer that hasn't been initialized", "A pointer that points to memory that has been freed", "A pointer that points to an invalid memory address"],
        "correctOptionIndex": 2,
        "correctOptionText": "A pointer that points to memory that has been freed",
        "difficulty": "medium",
        "explanation": "A dangling pointer is a pointer that references memory that has been deallocated (freed). Using a dangling pointer (dereferencing it) results in undefined behavior, as the memory it points to may have been reallocated for another purpose.",
        "hint": "The memory it points to no longer belongs to the program."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the purpose of setting a pointer to NULL after freeing it?",
        "options": ["To improve performance", "To prevent use-after-free errors", "To help the garbage collector", "To indicate the pointer is on the stack"],
        "correctOptionIndex": 1,
        "correctOptionText": "To prevent use-after-free errors",
        "difficulty": "medium",
        "explanation": "Setting a pointer to NULL after freeing it helps prevent use-after-free errors. If you accidentally try to use the pointer later, dereferencing a NULL pointer will cause a more predictable crash rather than undefined behavior, making the bug easier to diagnose.",
        "hint": "This creates a more detectable error if the pointer is used again."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What does the calloc() function require as arguments?",
        "options": ["Total size in bytes", "Pointer to allocated memory and new size", "Number of elements and size of each element", "Initial value and total size"],
        "correctOptionIndex": 2,
        "correctOptionText": "Number of elements and size of each element",
        "difficulty": "medium",
        "explanation": "The calloc() function takes two arguments: the number of elements to allocate and the size of each element in bytes. It returns a pointer to the allocated memory, which is initialized to zero.",
        "hint": "Think about what information is needed to allocate an array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which of the following is NOT a valid memory allocation function in standard C?",
        "options": ["malloc()", "calloc()", "realloc()", "alloc()"],
        "correctOptionIndex": 3,
        "correctOptionText": "alloc()",
        "difficulty": "easy",
        "explanation": "alloc() is not a standard C memory allocation function. The standard C memory allocation functions are malloc(), calloc(), and realloc(), which are all declared in the <stdlib.h> header file.",
        "hint": "Consider which functions are defined in the C standard library."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What happens when realloc() is called with a NULL pointer as its first argument?",
        "options": ["It returns NULL", "It behaves like malloc()", "It causes a segmentation fault", "It frees all previously allocated memory"],
        "correctOptionIndex": 1,
        "correctOptionText": "It behaves like malloc()",
        "difficulty": "medium",
        "explanation": "When realloc() is called with a NULL pointer as its first argument, it behaves exactly like malloc(), allocating new memory of the specified size and returning a pointer to it.",
        "hint": "This is a special case defined in the C standard."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What does the valgrind tool primarily help to detect in C programs?",
        "options": ["Syntax errors", "Memory leaks and other memory errors", "Performance bottlenecks", "Logical errors in algorithms"],
        "correctOptionIndex": 1,
        "correctOptionText": "Memory leaks and other memory errors",
        "difficulty": "medium",
        "explanation": "Valgrind is a programming tool for memory debugging, memory leak detection, and profiling. It's particularly useful for detecting memory leaks, use of uninitialized memory, double-free errors, and other memory-related issues in C programs.",
        "hint": "This tool helps find problems in how a program handles its memory."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What happens when realloc() is called with a size of 0?",
        "options": ["The pointer becomes NULL", "The memory is freed and NULL is returned", "It acts like free() but returns a non-NULL pointer", "Undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "The memory is freed and NULL is returned",
        "difficulty": "hard",
        "explanation": "According to the C standard, when realloc() is called with a size of 0, the memory pointed to by the first argument is freed, and either NULL or a pointer suitable for passing to free() is returned. In practice, most implementations return NULL.",
        "hint": "This is equivalent to freeing the memory with an additional return value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is memory fragmentation in the context of dynamic memory allocation?",
        "options": ["When a program uses too much memory", "When memory is scattered in small, non-contiguous blocks", "When pointers become dangling", "When memory leaks occur"],
        "correctOptionIndex": 1,
        "correctOptionText": "When memory is scattered in small, non-contiguous blocks",
        "difficulty": "hard",
        "explanation": "Memory fragmentation occurs when free memory is split into many small, non-contiguous blocks. This can happen after repeated allocations and deallocations of different sizes. It can lead to situations where there's enough total free memory, but not enough contiguous memory to satisfy a specific allocation request.",
        "hint": "Think about what happens to the heap after many allocations and deallocations of different sizes."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is a buffer overflow in C programming?",
        "options": ["When a program allocates too much memory", "When a program writes data beyond the end of an allocated buffer", "When a buffer is not properly initialized", "When a buffer is freed twice"],
        "correctOptionIndex": 1,
        "correctOptionText": "When a program writes data beyond the end of an allocated buffer",
        "difficulty": "medium",
        "explanation": "A buffer overflow occurs when a program writes data beyond the boundaries of an allocated buffer, overwriting adjacent memory. This can lead to program crashes, data corruption, or security vulnerabilities that might allow arbitrary code execution.",
        "hint": "This is a common security vulnerability where data 'spills over' its intended container."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What potential issues can arise when using realloc() to resize a memory block?",
        "options": ["The data in the original block might be lost", "It always creates memory fragmentation", "The original pointer becomes invalid if the block is moved", "realloc() is guaranteed to preserve the data at all times"],
        "correctOptionIndex": 2,
        "correctOptionText": "The original pointer becomes invalid if the block is moved",
        "difficulty": "hard",
        "explanation": "When realloc() is used to resize a memory block, if it needs to move the block to a new location (typically when enlarging it), the original pointer becomes invalid. Using the original pointer after a successful realloc() call can lead to undefined behavior if the memory block was moved.",
        "hint": "Consider what happens to the old pointer when memory needs to be relocated."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the main difference between memory allocated on the stack and memory allocated on the heap?",
        "options": ["Stack memory is faster but limited in size, heap memory is slower but larger", "Stack memory is automatically managed, heap memory must be explicitly freed", "Stack memory is global, heap memory is local to functions", "Stack memory is only for primitive types, heap memory is for complex types"],
        "correctOptionIndex": 1,
        "correctOptionText": "Stack memory is automatically managed, heap memory must be explicitly freed",
        "difficulty": "medium",
        "explanation": "The main difference is in lifetime management: stack memory is automatically allocated and deallocated as functions are called and return, while heap memory must be explicitly allocated (with malloc(), calloc(), etc.) and deallocated (with free()). Failing to free heap memory results in memory leaks.",
        "hint": "Think about how long each type of memory persists and who is responsible for cleaning it up."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What happens when calling free() on a NULL pointer in C?",
        "options": ["Segmentation fault", "Memory corruption", "Nothing (it's safely ignored)", "Undefined behavior"],
        "correctOptionIndex": 2,
        "correctOptionText": "Nothing (it's safely ignored)",
        "difficulty": "medium",
        "explanation": "According to the C standard, calling free() with a NULL pointer argument is explicitly defined to do nothing. This is a special case that allows for simplified error handling in code that manages dynamic memory.",
        "hint": "This behavior is specifically defined in the C standard to make certain patterns of code safer."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "Which of the following is a sign of a memory leak in a long-running C program?",
        "options": ["The program crashes with a segmentation fault", "The program's memory usage steadily increases over time", "The program becomes slower due to CPU throttling", "The program displays incorrect results"],
        "correctOptionIndex": 1,
        "correctOptionText": "The program's memory usage steadily increases over time",
        "difficulty": "medium",
        "explanation": "A classic sign of a memory leak is steadily increasing memory usage over time. Since memory is allocated but never freed, the program consumes more and more memory, eventually potentially exhausting the available system memory.",
        "hint": "Think about what happens when memory is repeatedly allocated but never released."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What technique involves allocating a large block of memory once and managing it within the program rather than calling malloc() frequently?",
        "options": ["Memory pooling", "Garbage collection", "Reference counting", "Virtual memory"],
        "correctOptionIndex": 0,
        "correctOptionText": "Memory pooling",
        "difficulty": "hard",
        "explanation": "Memory pooling (also called memory pools, buffer pools, or object pools) is a technique where a large block of memory is allocated once and then managed by the program to satisfy smaller allocation requests. This can improve performance by reducing the overhead of frequent system calls to malloc() and free().",
        "hint": "This technique reduces fragmentation and the overhead of system calls for memory management."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the proper way to allocate a 2D array of integers with 3 rows and 4 columns using malloc()?",
        "options": [
        "int **arr = malloc(3 * 4 * sizeof(int));",
        "int **arr = malloc(3 * sizeof(int*)); for(int i=0; i<3; i++) arr[i] = malloc(4 * sizeof(int));",
        "int *arr = malloc(3 * 4 * sizeof(int));",
        "int arr[3][4] = malloc(sizeof(int[3][4]));"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "int **arr = malloc(3 * sizeof(int*)); for(int i=0; i<3; i++) arr[i] = malloc(4 * sizeof(int));",
        "difficulty": "hard",
        "explanation": "To allocate a true 2D array dynamically, you need to allocate an array of pointers first (for the rows), then allocate each row separately. This creates a jagged array where each row can be accessed using the syntax arr[i][j].",
        "hint": "Consider the memory layout of a 2D array and how to allocate each dimension."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What is the purpose of the 'restrict' keyword when used with pointers in C99?",
        "options": [
        "It prevents the pointer from being modified",
        "It indicates that the pointer is the only means of accessing a memory object",
        "It restricts the pointer to point only to stack memory",
        "It makes the pointer read-only"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "It indicates that the pointer is the only means of accessing a memory object",
        "difficulty": "hard",
        "explanation": "The 'restrict' keyword, introduced in C99, is a type qualifier that can be applied to pointers. It indicates to the compiler that the pointer is the only means of accessing a particular object, allowing the compiler to perform optimizations that would not be possible if the object could be accessed through other pointers.",
        "hint": "This keyword is used to help the compiler optimize code by making assumptions about pointer aliasing."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Memory Management",
        "questionText": "What does the C function aligned_alloc() do?",
        "options": [
        "Allocates memory with a specific alignment requirement",
        "Aligns existing memory to cache lines",
        "Allocates memory and aligns it to page boundaries",
        "Aligns all global variables in a program"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "Allocates memory with a specific alignment requirement",
        "difficulty": "hard",
        "explanation": "The aligned_alloc() function, introduced in C11, allocates memory with a specified alignment. The allocated memory address will be a multiple of the alignment value, which must be a power of 2 and a multiple of sizeof(void*). This is useful for hardware-specific optimizations or when using SIMD instructions that require aligned memory.",
        "hint": "This function is useful when memory needs to be aligned to specific boundaries for hardware efficiency."
    },

    // File Handling
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to open a file in C?",
        "options": ["open()", "fopen()", "fileopen()", "readfile()"],
        "correctOptionIndex": 1,
        "correctOptionText": "fopen()",
        "difficulty": "easy",
        "explanation": "The fopen() function is used to open a file in C. It takes two arguments: the filename and the mode (such as 'r' for read, 'w' for write, etc.). It returns a FILE pointer that is used for further operations on the file.",
        "hint": "This function is declared in the stdio.h header file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What header file must be included to use file handling functions in C?",
        "options": ["<file.h>", "<fileio.h>", "<stdio.h>", "<stdlib.h>"],
        "correctOptionIndex": 2,
        "correctOptionText": "<stdio.h>",
        "difficulty": "easy",
        "explanation": "The <stdio.h> (standard input/output) header file must be included to use file handling functions in C. It contains declarations for functions like fopen(), fclose(), fread(), fwrite(), etc.",
        "hint": "This is the standard input/output header file in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which mode opens a file for writing, creating it if it doesn't exist or truncating it if it does?",
        "options": ["'r'", "'w'", "'a'", "'r+'"],
        "correctOptionIndex": 1,
        "correctOptionText": "'w'",
        "difficulty": "easy",
        "explanation": "The 'w' mode opens a file for writing. If the file doesn't exist, it is created. If it exists, its contents are truncated (erased), and the file is treated as a new empty file.",
        "hint": "This mode is for creating a new file or overwriting an existing one."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to close a file in C?",
        "options": ["close()", "fclose()", "fileclose()", "end()"],
        "correctOptionIndex": 1,
        "correctOptionText": "fclose()",
        "difficulty": "easy",
        "explanation": "The fclose() function is used to close a file that was opened with fopen(). It takes a FILE pointer as its argument. Closing files is important to ensure that all buffers are flushed and system resources are freed.",
        "hint": "This function complements the file opening function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What does fopen() return if it fails to open a file?",
        "options": ["0", "-1", "NULL", "An error code"],
        "correctOptionIndex": 2,
        "correctOptionText": "NULL",
        "difficulty": "easy",
        "explanation": "If fopen() fails to open a file, it returns NULL. This can happen for various reasons, such as the file not existing (for read mode), insufficient permissions, or reaching the system's limit on open files.",
        "hint": "This is a special pointer value indicating failure."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to read a single character from a file?",
        "options": ["getc()", "fgetc()", "readc()", "Both A and B"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both A and B",
        "difficulty": "medium",
        "explanation": "Both getc() and fgetc() can be used to read a single character from a file. They are functionally equivalent, but getc() is often implemented as a macro, while fgetc() is a function. Both take a FILE pointer as an argument and return the character read or EOF if end-of-file or an error occurs.",
        "hint": "These are two different ways to achieve the same result."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to write a single character to a file?",
        "options": ["putc()", "fputc()", "writec()", "Both A and B"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both A and B",
        "difficulty": "medium",
        "explanation": "Both putc() and fputc() can be used to write a single character to a file. Similar to the reading functions, putc() is often implemented as a macro, while fputc() is a function. Both take the character to write and a FILE pointer as arguments.",
        "hint": "These are complementary to the character reading functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function reads a line from a file into a string?",
        "options": ["fgets()", "fscanf()", "readline()", "getline()"],
        "correctOptionIndex": 0,
        "correctOptionText": "fgets()",
        "difficulty": "medium",
        "explanation": "The fgets() function reads a line from a file into a string. It takes three arguments: a character array (the buffer), the maximum number of characters to read (including the null terminator), and a FILE pointer. It stops reading after a newline character or when the buffer is full.",
        "hint": "This function is safer than gets() because it allows specifying a maximum length."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which mode opens a file for appending, creating it if it doesn't exist?",
        "options": ["'r'", "'w'", "'a'", "'r+'"],
        "correctOptionIndex": 2,
        "correctOptionText": "'a'",
        "difficulty": "easy",
        "explanation": "The 'a' mode opens a file for appending. If the file doesn't exist, it is created. All writes will add data to the end of the file, preserving existing content. The file pointer is positioned at the end of the file.",
        "hint": "This mode is for adding new data to the end of an existing file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is the difference between text mode and binary mode when opening a file?",
        "options": [
        "Text mode is faster than binary mode",
        "Text mode performs translations on newline characters, binary mode doesn't",
        "Text mode is for ASCII files, binary mode is for Unicode files",
        "Text mode is for small files, binary mode is for large files"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Text mode performs translations on newline characters, binary mode doesn't",
        "difficulty": "medium",
        "explanation": "In text mode, certain character translations occur, particularly for newline characters. On Windows, '\\n' is translated to '\\r\\n' when writing and '\\r\\n' is translated to '\\n' when reading. In binary mode, no such translations occur, and the data is read or written exactly as it is.",
        "hint": "This difference is particularly important on Windows systems."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "How do you open a file in binary mode?",
        "options": [
        "Specify 'binary' as a third parameter to fopen()",
        "Add 'b' to the mode string (e.g., 'rb', 'wb')",
        "Use a different function like bopen()",
        "All files are opened in binary mode by default"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Add 'b' to the mode string (e.g., 'rb', 'wb')",
        "difficulty": "medium",
        "explanation": "To open a file in binary mode, you add 'b' to the mode string when calling fopen(). For example, 'rb' opens a file for reading in binary mode, 'wb' for writing in binary mode, and 'ab' for appending in binary mode.",
        "hint": "It's a modifier added to the standard mode characters."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to read formatted input from a file?",
        "options": ["fgets()", "fscanf()", "fread()", "scanf()"],
        "correctOptionIndex": 1,
        "correctOptionText": "fscanf()",
        "difficulty": "medium",
        "explanation": "The fscanf() function reads formatted input from a file. It works like scanf() but takes a FILE pointer as its first argument. It can read various data types according to format specifiers and returns the number of items successfully read.",
        "hint": "This is the file version of the scanf() function used for standard input."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to write formatted output to a file?",
        "options": ["fputs()", "fprintf()", "fwrite()", "printf()"],
        "correctOptionIndex": 1,
        "correctOptionText": "fprintf()",
        "difficulty": "medium",
        "explanation": "The fprintf() function writes formatted output to a file. It works like printf() but takes a FILE pointer as its first argument. It can write various data types according to format specifiers and returns the number of characters written.",
        "hint": "This is the file version of the printf() function used for standard output."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to read a block of binary data from a file?",
        "options": ["fgets()", "fscanf()", "fread()", "getc()"],
        "correctOptionIndex": 2,
        "correctOptionText": "fread()",
        "difficulty": "medium",
        "explanation": "The fread() function reads a block of binary data from a file. It takes four arguments: a buffer to store the data, the size of each element to read, the number of elements to read, and a FILE pointer. It returns the number of elements successfully read.",
        "hint": "This function is typically used with files opened in binary mode."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function is used to write a block of binary data to a file?",
        "options": ["fputs()", "fprintf()", "fwrite()", "putc()"],
        "correctOptionIndex": 2,
        "correctOptionText": "fwrite()",
        "difficulty": "medium",
        "explanation": "The fwrite() function writes a block of binary data to a file. It takes four arguments: a buffer containing the data, the size of each element to write, the number of elements to write, and a FILE pointer. It returns the number of elements successfully written.",
        "hint": "This function is the counterpart to fread() for writing binary data."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What does the mode 'r+' do when opening a file with fopen()?",
        "options": [
        "Opens for reading only",
        "Opens for reading and writing, starting at the beginning",
        "Opens for reading and writing, starting at the end",
        "Opens for reading and appending"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Opens for reading and writing, starting at the beginning",
        "difficulty": "medium",
        "explanation": "The 'r+' mode opens a file for both reading and writing, with the file pointer positioned at the beginning of the file. The file must exist, or fopen() will return NULL. Unlike 'w+', this mode does not truncate the file.",
        "hint": "This is a read mode with added write capability."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What happens when trying to read beyond the end of a file?",
        "options": [
        "The program crashes",
        "An error code is returned",
        "EOF is returned",
        "Reading wraps around to the beginning of the file"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "EOF is returned",
        "difficulty": "medium",
        "explanation": "When attempting to read beyond the end of a file using functions like fgetc(), getc(), or fread(), the EOF (End of File) indicator is returned. EOF is a negative integer constant (typically -1) defined in stdio.h. For functions that read strings, NULL may be returned instead.",
        "hint": "This is how programs detect when they've reached the end of a file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What does the fseek() function do?",
        "options": [
        "Searches for a string in a file",
        "Sets the file position indicator for a stream",
        "Checks if a file exists",
        "Finds the size of a file"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Sets the file position indicator for a stream",
        "difficulty": "medium",
        "explanation": "The fseek() function sets the file position indicator for a stream. It takes three arguments: a FILE pointer, an offset (number of bytes to move), and a position (SEEK_SET for beginning of file, SEEK_CUR for current position, or SEEK_END for end of file).",
        "hint": "This function allows random access within a file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function tells the current position of the file pointer?",
        "options": ["ftell()", "fpos()", "fseek()", "fgetpos()"],
        "correctOptionIndex": 0,
        "correctOptionText": "ftell()",
        "difficulty": "medium",
        "explanation": "The ftell() function returns the current value of the file position indicator for a stream. It takes a FILE pointer as its argument and returns a long integer representing the current position, or -1L on error.",
        "hint": "This function lets you 'tell' where you are in the file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What function is used to rewind a file back to the beginning?",
        "options": ["frewind()", "rewind()", "fseek(fp, 0, SEEK_SET)", "Both B and C"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both B and C",
        "difficulty": "medium",
        "explanation": "Both rewind(fp) and fseek(fp, 0, SEEK_SET) can be used to move the file position indicator back to the beginning of the file. rewind() is a specialized function for this purpose, while fseek() is more general and can move to any position.",
        "hint": "There are multiple ways to achieve this common operation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is the purpose of the 'a+' mode when opening a file?",
        "options": [
        "Opens for reading only",
        "Opens for writing only, truncating the file",
        "Opens for appending only",
        "Opens for reading and appending"
        ],
        "correctOptionIndex": 3,
        "correctOptionText": "Opens for reading and appending",
        "difficulty": "medium",
        "explanation": "The 'a+' mode opens a file for both reading and appending. It creates the file if it doesn't exist. Reading can be done anywhere in the file, but writing can only be done at the end (appending). The file pointer is initially positioned at the end of the file.",
        "hint": "This mode combines the ability to read the whole file with the ability to add new data to the end."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What function would you use to check if the end of a file has been reached?",
        "options": ["feof()", "iseof()", "eof()", "checkeof()"],
        "correctOptionIndex": 0,
        "correctOptionText": "feof()",
        "difficulty": "medium",
        "explanation": "The feof() function tests the end-of-file indicator for a stream. It takes a FILE pointer as its argument and returns a non-zero value if the end-of-file indicator is set, zero otherwise. Note that feof() only returns true after attempting to read past the end of the file.",
        "hint": "This function checks a specific status flag in the FILE structure."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is the difference between fgetc() and getc()?",
        "options": [
        "fgetc() reads from files, getc() reads from standard input",
        "fgetc() is a function, getc() is typically a macro",
        "fgetc() returns a character, getc() returns an integer",
        "fgetc() is buffered, getc() reads directly from the file"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "fgetc() is a function, getc() is typically a macro",
        "difficulty": "hard",
        "explanation": "The main difference is that fgetc() is always a function, while getc() is often implemented as a macro (though it may also be a function). Functionally, they behave the same way, but there are subtle differences: macros may evaluate their arguments multiple times, and functions provide better type checking.",
        "hint": "This is an implementation detail that affects how they're compiled."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is a common way to read a file line by line in C?",
        "options": [
        "Using a while loop with fgets()",
        "Using the readlines() function",
        "Using the flines() function",
        "Using fscanf() with the %l specifier"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "Using a while loop with fgets()",
        "difficulty": "medium",
        "explanation": "A common way to read a file line by line in C is using a while loop with fgets(). The pattern is: `while (fgets(buffer, size, file) != NULL) { /* process line */ }`. This reads lines until the end of the file is reached.",
        "hint": "This pattern uses a standard library function in a loop until it returns NULL."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What type of files does the 'b' mode modifier (as in 'rb', 'wb') specifically affect?",
        "options": [
        "All files",
        "Only files on Windows systems",
        "Only files larger than 4GB",
        "Only files with binary data"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "Only files on Windows systems",
        "difficulty": "hard",
        "explanation": "The 'b' mode modifier primarily affects files on Windows systems, where text and binary modes are different. In text mode on Windows, '\\r\\n' sequences are translated to '\\n' when reading, and '\\n' is translated to '\\r\\n' when writing. On UNIX-like systems, text and binary modes are typically identical.",
        "hint": "This is related to different line ending conventions on different operating systems."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "If a program opens a file but doesn't close it before terminating, what typically happens?",
        "options": [
        "The file is corrupted",
        "The file remains locked forever",
        "The operating system closes the file automatically",
        "The file is deleted"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "The operating system closes the file automatically",
        "difficulty": "medium",
        "explanation": "If a program opens a file but doesn't explicitly close it before terminating, the operating system will automatically close the file and release any associated resources. However, it's still good practice to close files explicitly to ensure that buffered data is written to disk and to free resources promptly.",
        "hint": "Modern operating systems clean up resources when processes terminate."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "Which function can be used to flush the output buffer of a file stream?",
        "options": ["fflush()", "flush()", "fsync()", "fbuffer()"],
        "correctOptionIndex": 0,
        "correctOptionText": "fflush()",
        "difficulty": "medium",
        "explanation": "The fflush() function is used to flush the output buffer of a file stream, forcing any buffered data to be written to the underlying file. It takes a FILE pointer as its argument. This is useful when you need to ensure that all data has been physically written before continuing.",
        "hint": "This function ensures that buffered output is immediately written to the file."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is the result of attempting to read from a file opened only for writing (e.g., with 'w' mode)?",
        "options": [
        "It works normally",
        "It always returns EOF",
        "Undefined behavior",
        "Compile-time error"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Undefined behavior",
        "difficulty": "hard",
        "explanation": "Attempting to read from a file that was opened only for writing results in undefined behavior. The C standard does not specify what should happen, and different implementations might handle it differently. It could crash, return unexpected data, or have other unpredictable effects.",
        "hint": "The file access mode restricts valid operations on the file stream."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is a binary file in the context of C programming?",
        "options": [
        "A file containing only 0s and 1s",
        "A file containing executable code",
        "A file where data is stored in its binary representation without text formatting",
        "A file that can only be read by computers, not humans"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "A file where data is stored in its binary representation without text formatting",
        "difficulty": "medium",
        "explanation": "In C programming, a binary file is one where data is stored in its native binary representation, exactly as it exists in memory, without any conversion to text. This is in contrast to a text file, where data is stored as human-readable text and may undergo conversions (e.g., for newlines) during I/O operations.",
        "hint": "This type of file preserves the exact byte patterns of data structures."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "When using fwrite() to write a struct to a file, what potential issue must you be aware of?",
        "options": [
        "It can only write primitive types, not structs",
        "It will corrupt the file system",
        "Padding and alignment may make the binary data non-portable",
        "The struct will be converted to text format"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Padding and alignment may make the binary data non-portable",
        "difficulty": "hard",
        "explanation": "When writing structs directly to a file with fwrite(), you must be aware that padding and alignment between structure members can vary between different compilers, architectures, and compiler settings. This means the binary data might not be portable between different systems or even different compilations of the same program.",
        "hint": "This is related to how compilers lay out structures in memory."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "File Handling",
        "questionText": "What is the typical way to recover from a file error in C?",
        "options": [
        "Using try-catch blocks",
        "Using exception handling",
        "Checking return values and error flags like ferror()",
        "Using the file_error_handler() function"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Checking return values and error flags like ferror()",
        "difficulty": "hard",
        "explanation": "In C, error handling for file operations typically involves checking return values from functions and using error-checking functions like ferror() to detect errors. Unlike some other languages, C does not have built-in exception handling, so errors must be explicitly checked and handled after each operation that could fail.",
        "hint": "C uses a procedural approach to error handling rather than exceptions."
    },

    // Preprocessor Directives
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the correct syntax to include a user-defined header file in C?",
        "options": ["#include \"filename.h\"", "#include <filename.h>", "#import \"filename.h\"", "#define filename.h"],
        "correctOptionIndex": 0,
        "correctOptionText": "#include \"filename.h\"",
        "difficulty": "easy",
        "explanation": "In C, we use #include \"filename.h\" to include user-defined header files. The double quotes tell the preprocessor to look in the current directory first, then in the standard locations.",
        "hint": "User-defined header files use a different syntax than standard library headers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "Which preprocessor directive is used to define a macro in C?",
        "options": ["#macro", "#define", "#include", "#ifdef"],
        "correctOptionIndex": 1,
        "correctOptionText": "#define",
        "difficulty": "easy",
        "explanation": "The #define directive is used to define macros in C. Macros are preprocessor directives that allow you to define constants or function-like constructs that are processed before compilation.",
        "hint": "This directive allows you to create symbolic constants without using variables."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the output of the following code?\n#define SQUARE(x) x*x\nint main() {\n    printf(\"%d\", SQUARE(5+2));\n    return 0;\n}",
        "options": ["49", "19", "14", "5+2*5+2"],
        "correctOptionIndex": 1,
        "correctOptionText": "19",
        "difficulty": "medium",
        "explanation": "The macro SQUARE(x) expands to x*x. When SQUARE(5+2) is used, it expands to 5+2*5+2, which evaluates to 5+10+2 = 17 according to operator precedence. The correct way to define this macro would be #define SQUARE(x) ((x)*(x)).",
        "hint": "Consider how macros perform simple text substitution without respecting operator precedence."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "Which directive is used to prevent a header file from being included multiple times?",
        "options": ["#pragma once", "#ifndef and #define", "#noinclude", "Both A and B are correct"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both A and B are correct",
        "difficulty": "medium",
        "explanation": "Both #pragma once and the combination of #ifndef, #define, and #endif can be used to prevent multiple inclusion of header files. The former is compiler-specific but simpler, while the latter is the traditional standards-compliant approach.",
        "hint": "There are two common methods to solve this problem - one is a single directive, and the other uses multiple directives together."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What does the following preprocessor directive do?\n#error \"Compilation stopped\"",
        "options": ["Displays a warning message", "Forces the compiler to stop compilation with an error message", "Logs an error to a file", "Creates a runtime error"],
        "correctOptionIndex": 1,
        "correctOptionText": "Forces the compiler to stop compilation with an error message",
        "difficulty": "medium",
        "explanation": "The #error directive forces the compiler to stop compilation and display the specified error message. It's often used in conditional compilation blocks to prevent compilation when certain conditions are not met.",
        "hint": "This directive is used when you want to deliberately stop the compilation process."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the #ifdef directive in C?",
        "options": ["To define a new macro", "To check if a macro is defined", "To include a header file", "To declare an interface"],
        "correctOptionIndex": 1,
        "correctOptionText": "To check if a macro is defined",
        "difficulty": "easy",
        "explanation": "The #ifdef directive checks if a particular macro has been defined. If the macro is defined, the code following the directive until the corresponding #endif is included for compilation.",
        "hint": "This directive is part of conditional compilation in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What will be the output of the following code?\n#define MAX 100\n#undef MAX\n#define MAX 200\nint main() {\n    printf(\"%d\", MAX);\n    return 0;\n}",
        "options": ["100", "200", "Compilation error", "0"],
        "correctOptionIndex": 1,
        "correctOptionText": "200",
        "difficulty": "medium",
        "explanation": "The #undef directive undefines a previously defined macro. In this case, MAX is first defined as 100, then undefined with #undef, and finally redefined as 200. Therefore, the output will be 200.",
        "hint": "Consider the effects of undefining and redefining a macro."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the correct way to create a parameterized macro for finding the maximum of two values?",
        "options": ["#define MAX(a,b) a>b?a:b", "#define MAX(a,b) ((a)>(b)?(a):(b))", "#define MAX(a,b) if(a>b) return a; else return b;", "#define MAX(a,b) a>b"],
        "correctOptionIndex": 1,
        "correctOptionText": "#define MAX(a,b) ((a)>(b)?(a):(b))",
        "difficulty": "medium",
        "explanation": "The correct way to define a MAX macro is #define MAX(a,b) ((a)>(b)?(a):(b)). This uses parentheses around each parameter and the entire expression to avoid issues with operator precedence when the macro is expanded.",
        "hint": "Proper macros use parentheses to protect against operator precedence issues."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "Which preprocessor directive can be used to print the line number where it appears in the source code?",
        "options": ["#line", "#debug", "#trace", "__LINE__"],
        "correctOptionIndex": 3,
        "correctOptionText": "__LINE__",
        "difficulty": "medium",
        "explanation": "__LINE__ is a predefined macro that expands to the current line number in the source code file as an integer constant. It's often used for debugging purposes.",
        "hint": "This is a predefined macro, not a directive, that helps with debugging."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the #pragma directive in C?",
        "options": ["To define constants", "To include header files", "To provide additional information to the compiler", "To create conditional compilation blocks"],
        "correctOptionIndex": 2,
        "correctOptionText": "To provide additional information to the compiler",
        "difficulty": "medium",
        "explanation": "The #pragma directive is used to provide additional, compiler-specific information to the compiler. It can be used for various purposes such as optimization, warning suppression, or alignment control, depending on the compiler.",
        "hint": "This directive allows for compiler-specific instructions that aren't part of the standard C language."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the effect of the following code?\n#define PRINT(x) printf(\"%d\\n\", x)\nint main() {\n    int a = 5;\n    PRINT(a++);\n    PRINT(a);\n    return 0;\n}",
        "options": ["5, 6", "6, 6", "5, 5", "6, 7"],
        "correctOptionIndex": 0,
        "correctOptionText": "5, 6",
        "difficulty": "medium",
        "explanation": "The macro PRINT(x) expands to printf(\"%d\\n\", x). When PRINT(a++) is called, it expands to printf(\"%d\\n\", a++), which first prints the value of a (5) and then increments it to 6. The second PRINT(a) then prints the new value of a, which is 6.",
        "hint": "Remember how the post-increment operator works - it uses the current value first, then increments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the ## operator in macro definitions?",
        "options": ["Logical AND", "String concatenation", "Token concatenation", "Arithmetic multiplication"],
        "correctOptionIndex": 2,
        "correctOptionText": "Token concatenation",
        "difficulty": "hard",
        "explanation": "The ## operator in C preprocessor macros is used for token concatenation. It allows you to combine two tokens into a single token during macro expansion.",
        "hint": "This operator allows you to create new identifiers by combining parts in a macro."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What does the following code do?\n#define CONCATENATE(x, y) x##y\nint main() {\n    int value12 = 100;\n    printf(\"%d\", CONCATENATE(value, 12));\n    return 0;\n}",
        "options": ["Prints \"value12\"", "Prints \"value 12\"", "Prints 100", "Causes a compilation error"],
        "correctOptionIndex": 2,
        "correctOptionText": "Prints 100",
        "difficulty": "hard",
        "explanation": "The ## operator concatenates the tokens 'value' and '12' to form 'value12', which is the name of the variable. Therefore, CONCATENATE(value, 12) expands to value12, which has the value 100.",
        "hint": "The ## operator joins tokens together to form new identifiers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the # operator in macro definitions?",
        "options": ["Commenting", "String literal conversion (stringification)", "Conditional compilation", "Mathematical operation"],
        "correctOptionIndex": 1,
        "correctOptionText": "String literal conversion (stringification)",
        "difficulty": "hard",
        "explanation": "The # operator in C preprocessor macros is used for stringification. It converts a macro parameter into a string literal by adding double quotes around it during macro expansion.",
        "hint": "This operator is used when you want to convert a macro parameter to a string."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the output of the following code?\n#define STRINGIFY(x) #x\nint main() {\n    printf(\"%s\", STRINGIFY(Hello World));\n    return 0;\n}",
        "options": ["Hello", "\"Hello\"", "Hello World", "\"Hello World\""],
        "correctOptionIndex": 2,
        "correctOptionText": "Hello World",
        "difficulty": "hard",
        "explanation": "The # operator in STRINGIFY(x) converts its argument to a string literal. STRINGIFY(Hello World) expands to \"Hello World\", and printf(\"%s\", \"Hello World\") prints Hello World without the quotes.",
        "hint": "The # operator adds quotes around the entire argument, but printf with %s removes the quotes when displaying."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the #elif directive in C?",
        "options": ["To define an alternative macro", "To include an alternative header file", "To provide an 'else if' condition in conditional compilation", "To check if a macro is not defined"],
        "correctOptionIndex": 2,
        "correctOptionText": "To provide an 'else if' condition in conditional compilation",
        "difficulty": "medium",
        "explanation": "The #elif directive stands for 'else if' and is used in conditional compilation blocks. It allows for checking multiple conditions in a sequence, similar to an else-if statement in regular C code.",
        "hint": "This directive extends the functionality of #if and #ifdef directives."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "Which predefined macro in C expands to the name of the current source file as a string literal?",
        "options": ["__FILE__", "__FUNCTION__", "__LINE__", "__DATE__"],
        "correctOptionIndex": 0,
        "correctOptionText": "__FILE__",
        "difficulty": "medium",
        "explanation": "__FILE__ is a predefined macro that expands to the name of the current source file as a string literal. It's often used for debugging and logging purposes.",
        "hint": "This macro is useful when you want to know which file an error occurred in."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What will be the output of the following code?\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\nint main() {\n    int x = 5, y = 10;\n    printf(\"%d\", MIN(x++, y++));\n    printf(\", %d %d\", x, y);\n    return 0;\n}",
        "options": ["5, 6 11", "5, 7 11", "10, 6 11", "10, 7 11"],
        "correctOptionIndex": 1,
        "correctOptionText": "5, 7 11",
        "difficulty": "hard",
        "explanation": "The macro MIN(x++, y++) expands to ((x++) < (y++) ? (x++) : (y++)). When evaluated, x++ < y++ is true, so x++ is returned, which is 5. However, x is incremented twice (once in the comparison and once in the return value), and y is incremented once (in the comparison). Therefore, x becomes 7 and y becomes 11.",
        "hint": "Be careful with side effects in macro parameters - they may be evaluated multiple times!"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the __cplusplus predefined macro?",
        "options": ["To check if the compiler supports C++", "To include C++ libraries", "To define C++ compatible functions", "To switch between C and C++ syntax"],
        "correctOptionIndex": 0,
        "correctOptionText": "To check if the compiler supports C++",
        "difficulty": "medium",
        "explanation": "The __cplusplus predefined macro is defined when compiling C++ code. It can be used in header files to detect whether the code is being compiled as C or C++, allowing for conditional compilation based on the language.",
        "hint": "This macro helps create header files that work with both C and C++ compilers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the difference between #include <file.h> and #include \"file.h\"?",
        "options": ["No difference", "The first looks in system directories only, the second looks in the current directory first", "The first is for C++ files, the second for C files", "The first is for header files, the second for source files"],
        "correctOptionIndex": 1,
        "correctOptionText": "The first looks in system directories only, the second looks in the current directory first",
        "difficulty": "easy",
        "explanation": "When using #include <file.h>, the preprocessor looks for the file in the system include directories. When using #include \"file.h\", it first looks in the current directory (or the directory of the source file), and then in the system include directories.",
        "hint": "The difference is in the search path used by the preprocessor."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What will be the output of the following code?\n#define MULTIPLY(a, b) a * b\nint main() {\n    printf(\"%d\", MULTIPLY(2 + 3, 4 + 5));\n    return 0;\n}",
        "options": ["45", "23", "19", "Error"],
        "correctOptionIndex": 2,
        "correctOptionText": "19",
        "difficulty": "medium",
        "explanation": "The macro MULTIPLY(a, b) expands to a * b. When MULTIPLY(2 + 3, 4 + 5) is used, it expands to 2 + 3 * 4 + 5. Due to operator precedence, this evaluates to 2 + 12 + 5 = 19. The correct way to define this macro would be #define MULTIPLY(a, b) ((a) * (b)).",
        "hint": "Consider how macros perform simple text substitution and how operator precedence affects the result."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the #undef directive in C?",
        "options": ["To undefine a previously defined macro", "To check if a macro is not defined", "To remove a header file inclusion", "To disable a function declaration"],
        "correctOptionIndex": 0,
        "correctOptionText": "To undefine a previously defined macro",
        "difficulty": "easy",
        "explanation": "The #undef directive is used to undefine (remove) a previously defined macro. After a macro is undefined, it can be redefined with a new value if needed.",
        "hint": "This directive essentially 'forgets' a macro definition."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is conditional compilation in C?",
        "options": ["Compiling code based on the operating system", "Compiling code based on defined macros or conditions", "Compiling code only if it passes compilation checks", "Compiling different versions of the same function"],
        "correctOptionIndex": 1,
        "correctOptionText": "Compiling code based on defined macros or conditions",
        "difficulty": "easy",
        "explanation": "Conditional compilation in C allows certain portions of code to be included or excluded during compilation based on defined macros or conditions. It's achieved using directives like #if, #ifdef, #ifndef, #else, #elif, and #endif.",
        "hint": "This technique lets you include or exclude code based on compile-time conditions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What does the following code segment do?\n#if defined(_WIN32)\n    printf(\"Windows\");\n#elif defined(__APPLE__)\n    printf(\"macOS\");\n#elif defined(__linux__)\n    printf(\"Linux\");\n#else\n    printf(\"Unknown\");\n#endif",
        "options": ["Prints all operating systems", "Causes a compilation error", "Prints the operating system the code is compiled on", "Prints nothing"],
        "correctOptionIndex": 2,
        "correctOptionText": "Prints the operating system the code is compiled on",
        "difficulty": "medium",
        "explanation": "This code uses conditional compilation to print different messages based on which platform the code is being compiled for. It checks predefined macros that are specific to different operating systems (_WIN32 for Windows, __APPLE__ for macOS, __linux__ for Linux).",
        "hint": "This is a common pattern for writing platform-specific code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the purpose of the #line directive in C?",
        "options": ["To add line breaks in the output", "To change the line numbering as seen by compiler messages", "To count lines of code", "To skip lines during compilation"],
        "correctOptionIndex": 1,
        "correctOptionText": "To change the line numbering as seen by compiler messages",
        "difficulty": "hard",
        "explanation": "The #line directive is used to change the line number and file name used in compiler messages. It can be useful when working with code generators or preprocessors that modify the original source code structure.",
        "hint": "This directive affects how errors and warnings are reported by the compiler."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the output of the following code?\n#define VAR 100\nint main() {\n    int VAR = 200;\n    printf(\"%d\", VAR);\n    return 0;\n}",
        "options": ["100", "200", "300", "Compilation error"],
        "correctOptionIndex": 1,
        "correctOptionText": "200",
        "difficulty": "medium",
        "explanation": "In this code, the macro VAR is defined as 100, but then a local variable with the same name VAR is declared and initialized to 200. Since local variables take precedence over macros in their scope, the printf statement prints the value of the local variable, which is 200.",
        "hint": "Consider the scope rules and how variable names are resolved relative to macro names."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What will happen if you use the following code?\n#define MAX 100\n#if MAX > 200\n    #define RESULT \"Greater\"\n#else\n    #define RESULT \"Lesser or Equal\"\n#endif\nint main() {\n    printf(\"%s\", RESULT);\n    return 0;\n}",
        "options": ["Prints \"Greater\"", "Prints \"Lesser or Equal\"", "Compilation error", "Runtime error"],
        "correctOptionIndex": 1,
        "correctOptionText": "Prints \"Lesser or Equal\"",
        "difficulty": "medium",
        "explanation": "This code uses conditional compilation. Since MAX is defined as 100, the condition MAX > 200 is false, so the code in the #else block is compiled, defining RESULT as \"Lesser or Equal\". The printf statement then prints this value.",
        "hint": "The preprocessor evaluates the condition and includes only one of the blocks."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the effect of the following preprocessor directives?\n#ifndef DEBUG\n    #define DEBUG 0\n#endif",
        "options": ["Sets DEBUG to 0 in all cases", "Defines DEBUG only if it wasn't already defined", "Causes a compilation error if DEBUG is already defined", "Has no effect"],
        "correctOptionIndex": 1,
        "correctOptionText": "Defines DEBUG only if it wasn't already defined",
        "difficulty": "medium",
        "explanation": "This is a common pattern to provide default values for macros. If DEBUG is not defined (#ifndef DEBUG), it defines it with a value of 0. If DEBUG is already defined, this code has no effect. This allows a programmer to override the default value by defining DEBUG before this code is processed.",
        "hint": "This is often used to set default configuration values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "Which of the following is NOT a valid preprocessor directive in C?",
        "options": ["#define", "#include", "#import", "#while"],
        "correctOptionIndex": 3,
        "correctOptionText": "#while",
        "difficulty": "easy",
        "explanation": "#while is not a valid preprocessor directive in standard C. Valid directives include #define, #include, #ifdef, #ifndef, #if, #else, #elif, #endif, #undef, #error, #pragma, and #line.",
        "hint": "One of these resembles a C control structure that is not supported by the preprocessor."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What does the __STDC__ predefined macro indicate?",
        "options": ["The version of the C standard library being used", "That the compiler conforms to the ANSI C standard", "That the code is being compiled as C, not C++", "The target processor architecture"],
        "correctOptionIndex": 1,
        "correctOptionText": "That the compiler conforms to the ANSI C standard",
        "difficulty": "hard",
        "explanation": "The __STDC__ predefined macro is defined with the value 1 when the compiler conforms to the ANSI C standard. It can be used to detect whether the compiler supports standard C features.",
        "hint": "This macro is related to compiler standards compliance."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Preprocessor Directives",
        "questionText": "What is the result of the following code?\n#define CUBE(x) (x*x*x)\nint main() {\n    int i = 2;\n    printf(\"%d\", CUBE(i++));\n    printf(\", %d\", i);\n    return 0;\n}",
        "options": ["8, 3", "8, 5", "12, 5", "27, 5"],
        "correctOptionIndex": 1,
        "correctOptionText": "8, 5",
        "difficulty": "hard",
        "explanation": "The macro CUBE(x) expands to (x*x*x). When CUBE(i++) is used, it expands to (i++*i++*i++). This means i is incremented three times. The first i++ evaluates to 2, the second to 3, and the third to 4. The product is 2*3*4 = 24, but due to side effects and undefined behavior in C, the result is compiler-dependent. With most compilers, the result would be 8 (2*2*2), and i would become 5 after three increments.",
        "hint": "Be careful with side effects in macro parameters - the parameter may be evaluated multiple times!"
    },

    // Command Line Arguments
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "How many parameters does the main function receive when accepting command line arguments in C?",
        "options": ["One", "Two", "Three", "Four"],
        "correctOptionIndex": 2,
        "correctOptionText": "Three",
        "difficulty": "easy",
        "explanation": "In C, the main function accepts three parameters when handling command line arguments: int main(int argc, char *argv[], char *envp[]). The third parameter envp[] is for environment variables.",
        "hint": "Count the parameters in the function signature: int main(int argc, char *argv[], char *envp[])."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What does 'argc' represent in the main function?",
        "options": ["Argument count", "Argument character", "Argument controller", "Argument class"],
        "correctOptionIndex": 0,
        "correctOptionText": "Argument count",
        "difficulty": "easy",
        "explanation": "In the main function, 'argc' stands for 'argument count'. It represents the number of command line arguments passed to the program, including the program name itself.",
        "hint": "Think about what information this parameter provides about the arguments passed to the program."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the minimum value of argc in a C program?",
        "options": ["0", "1", "2", "Depends on the operating system"],
        "correctOptionIndex": 1,
        "correctOptionText": "1",
        "difficulty": "easy",
        "explanation": "The minimum value of argc is 1, which occurs when no command line arguments are provided. This is because argc includes the program name itself as the first argument.",
        "hint": "Consider what happens when you run a program without any additional arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What does argv[0] typically contain?",
        "options": ["First command line argument", "Program name or path", "Number of arguments", "NULL"],
        "correctOptionIndex": 1,
        "correctOptionText": "Program name or path",
        "difficulty": "easy",
        "explanation": "argv[0] typically contains the name of the program being executed or its path, depending on how the program was invoked.",
        "hint": "The zeroth element of argv always has a special meaning not related to user-supplied arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the data type of argv in the main function?",
        "options": ["int[]", "char[]", "char*[]", "int*[]"],
        "correctOptionIndex": 2,
        "correctOptionText": "char*[]",
        "difficulty": "easy",
        "explanation": "argv is an array of character pointers (char*[]). Each element points to a null-terminated string representing one argument.",
        "hint": "Consider what type would be suitable for storing multiple strings."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "How can you access the third command line argument in a C program?",
        "options": ["argv[2]", "argv[3]", "argc[2]", "argc[3]"],
        "correctOptionIndex": 0,
        "correctOptionText": "argv[2]",
        "difficulty": "easy",
        "explanation": "To access the third command line argument, you use argv[2]. This is because argv[0] is the program name, argv[1] is the first argument, and argv[2] is the second argument (third element overall).",
        "hint": "Remember that array indexing starts at 0 and that the program name occupies the first position."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the value of argv[argc]?",
        "options": ["The last command line argument", "Undefined behavior", "NULL", "A memory address"],
        "correctOptionIndex": 2,
        "correctOptionText": "NULL",
        "difficulty": "medium",
        "explanation": "The value of argv[argc] is guaranteed to be NULL. This acts as a sentinel value marking the end of the argument list.",
        "hint": "C standard specifies a special value at the end of the argv array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What function is commonly used to convert command line arguments from strings to integers?",
        "options": ["atoi()", "itoa()", "parseInt()", "strToInt()"],
        "correctOptionIndex": 0,
        "correctOptionText": "atoi()",
        "difficulty": "medium",
        "explanation": "The atoi() function (ASCII to integer) is commonly used to convert command line arguments from strings to integers. It's part of the standard library and found in <stdlib.h>.",
        "hint": "Look for a function name that suggests converting ASCII (text) to an integer value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which header file should be included to use the strtol() function for command line argument conversion?",
        "options": ["<string.h>", "<stdlib.h>", "<ctype.h>", "<stdio.h>"],
        "correctOptionIndex": 1,
        "correctOptionText": "<stdlib.h>",
        "difficulty": "medium",
        "explanation": "The strtol() function, which is often used for more robust conversion of command line arguments to long integers, is declared in the <stdlib.h> header file.",
        "hint": "This header contains many utility functions for C programming, particularly for conversions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What happens if you run a program with the command './program \"hello world\"'?",
        "options": ["argc would be 3", "argc would be 2", "argv[1] would contain 'hello world'", "argv[1] and argv[2] would contain 'hello' and 'world' respectively"],
        "correctOptionIndex": 2,
        "correctOptionText": "argv[1] would contain 'hello world'",
        "difficulty": "medium",
        "explanation": "When quotation marks are used in the command line, the text within is treated as a single argument. So argv[1] would contain the string 'hello world' and argc would be 2.",
        "hint": "Consider how quotation marks are processed by the command line shell."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is a safer alternative to atoi() for parsing numeric command line arguments?",
        "options": ["sscanf()", "strtol()", "parseInt()", "getnum()"],
        "correctOptionIndex": 1,
        "correctOptionText": "strtol()",
        "difficulty": "medium",
        "explanation": "strtol() is a safer alternative to atoi() because it provides error detection. It can detect invalid inputs and allows you to specify the base for the conversion.",
        "hint": "Look for a function that provides more control and error detection than atoi()."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What function would you use to parse a floating-point number from a command line argument?",
        "options": ["atoi()", "atof()", "strtof()", "Both B and C"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both B and C",
        "difficulty": "medium",
        "explanation": "Both atof() (ASCII to float) and strtof() (string to float) can be used to parse floating-point numbers from command line arguments. strtof() provides more error checking capabilities than atof().",
        "hint": "Consider which functions in the standard library convert strings to floating-point values."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which of the following is TRUE about command line arguments in C?",
        "options": ["They cannot contain spaces", "They are always case-sensitive", "They must be numeric", "They are passed as strings"],
        "correctOptionIndex": 3,
        "correctOptionText": "They are passed as strings",
        "difficulty": "medium",
        "explanation": "Command line arguments in C are always passed as strings (null-terminated character arrays) regardless of their intended use. It's the programmer's responsibility to parse them into other data types as needed.",
        "hint": "Think about the data type of argv[] elements and how you need to convert them for numeric operations."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the conventional meaning of argv[0] in a C program?",
        "options": ["The first user-supplied argument", "The program name or path", "The number of arguments", "A pointer to environment variables"],
        "correctOptionIndex": 1,
        "correctOptionText": "The program name or path",
        "difficulty": "medium",
        "explanation": "By convention, argv[0] contains the name of the program as it was invoked. Depending on how the program was called, it might be a simple name, a relative path, or an absolute path.",
        "hint": "This value is automatically populated even when no explicit arguments are provided by the user."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which of the following main function declarations is valid for handling command line arguments?",
        "options": ["int main(char *argv[])", "int main(int argc)", "int main(int argc, char *argv[])", "int main(int *argc, char argv[])"],
        "correctOptionIndex": 2,
        "correctOptionText": "int main(int argc, char *argv[])",
        "difficulty": "medium",
        "explanation": "The correct declaration is int main(int argc, char *argv[]). This provides both the argument count and an array of strings containing the arguments.",
        "hint": "You need both the number of arguments and access to the argument strings themselves."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the effect of using getopt() function with command line arguments?",
        "options": ["It helps parse flag options", "It converts arguments to integers", "It validates argument count", "It alphabetically sorts the arguments"],
        "correctOptionIndex": 0,
        "correctOptionText": "It helps parse flag options",
        "difficulty": "hard",
        "explanation": "The getopt() function is used to parse command line arguments that follow the POSIX convention for flag options (like -a, -b, or combined as -ab). It simplifies the handling of such options in C programs.",
        "hint": "Think about handling arguments in the form of '-f' or '--file' in your program."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which header file is needed to use the getopt() function?",
        "options": ["<stdlib.h>", "<stdio.h>", "<unistd.h>", "<getopt.h>"],
        "correctOptionIndex": 2,
        "correctOptionText": "<unistd.h>",
        "difficulty": "hard",
        "explanation": "The getopt() function is declared in <unistd.h> on UNIX-like systems. On some systems, it may also be available through <getopt.h>.",
        "hint": "This header is associated with POSIX operating system API functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the correct way to access environment variables in a C program?",
        "options": ["Through argc", "Through the first few elements of argv", "Through a third parameter to main, char *envp[]", "Through a global variable named environ"],
        "correctOptionIndex": 3,
        "correctOptionText": "Through a global variable named environ",
        "difficulty": "hard",
        "explanation": "While main can be declared with a third parameter for environment variables, the standard way to access them is through the external variable 'environ' (declared as extern char **environ), which is defined in <unistd.h>.",
        "hint": "There's a specific global variable that provides access to environment variables."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What does the following command line argument pattern mean: myprog -f filename?",
        "options": ["One argument with value '-f filename'", "Two arguments: '-f' and 'filename'", "A flag option -f with parameter filename", "A formatting error in command syntax"],
        "correctOptionIndex": 2,
        "correctOptionText": "A flag option -f with parameter filename",
        "difficulty": "medium",
        "explanation": "This pattern represents a flag option '-f' followed by its parameter 'filename'. This is a common convention where -f indicates a specific operation or setting (like specifying a file) and the value following it provides the details.",
        "hint": "Consider standard command line conventions where options with parameters are provided."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Given a program called with './program arg1 \"arg2 with spaces\" arg3', what would be the value of argc?",
        "options": ["3", "4", "5", "6"],
        "correctOptionIndex": 1,
        "correctOptionText": "4",
        "difficulty": "medium",
        "explanation": "argc would be 4. The arguments are: argv[0]='./program', argv[1]='arg1', argv[2]='arg2 with spaces', and argv[3]='arg3'. The quoted argument with spaces counts as a single argument.",
        "hint": "Count each distinct argument, treating quoted strings as single arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What's the purpose of the getopt_long() function?",
        "options": ["To parse long integers from arguments", "To handle long file names in arguments", "To parse both short and long option formats", "To increase the maximum number of allowed arguments"],
        "correctOptionIndex": 2,
        "correctOptionText": "To parse both short and long option formats",
        "difficulty": "hard",
        "explanation": "getopt_long() extends the functionality of getopt() to support both traditional single-character options (like -a) and GNU-style long options (like --all).",
        "hint": "Think about common command formats like '--help' versus '-h'."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which of the following correctly defines the prototype for main() that can access environment variables?",
        "options": ["int main()", "int main(int argc, char *argv[])", "int main(int argc, char *argv[], char *envp[])", "int main(int argc, char **argv, char **environ)"],
        "correctOptionIndex": 2,
        "correctOptionText": "int main(int argc, char *argv[], char *envp[])",
        "difficulty": "hard",
        "explanation": "The prototype int main(int argc, char *argv[], char *envp[]) allows direct access to environment variables through the envp parameter, which is an array of strings containing the environment variables.",
        "hint": "There's a specific third parameter that can be added to the main function for this purpose."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is the GNU standard for providing help information via command line?",
        "options": ["--h or -help", "--help", "-h", "Both B and C"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both B and C",
        "difficulty": "medium",
        "explanation": "The GNU standard recommends supporting both '--help' (long format) and '-h' (short format) options for displaying help information.",
        "hint": "Consider both the long and short conventions for option flags."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "When using strtol() to parse a command line argument, what does it return on error?",
        "options": ["NULL", "0", "-1", "It doesn't return an error value but sets errno"],
        "correctOptionIndex": 3,
        "correctOptionText": "It doesn't return an error value but sets errno",
        "difficulty": "hard",
        "explanation": "strtol() doesn't return a special error value. Instead, it sets the global variable errno to indicate errors like ERANGE (out of range) or EINVAL (invalid base). You need to check errno after calling strtol() to detect errors.",
        "hint": "Look for how C functions commonly report errors in the standard library."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What happens if a user provides fewer command line arguments than your program expects?",
        "options": ["The program automatically prompts for missing arguments", "The program crashes", "Unused argv entries are set to NULL", "It's the programmer's responsibility to handle this case"],
        "correctOptionIndex": 3,
        "correctOptionText": "It's the programmer's responsibility to handle this case",
        "difficulty": "medium",
        "explanation": "There's no automatic mechanism in C to handle missing arguments. The programmer must check the value of argc to ensure the required number of arguments were provided and implement appropriate error handling.",
        "hint": "Consider who needs to implement validation of command line arguments."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "Which of the following is a valid alternative to the standard main() function signature for command line arguments?",
        "options": ["int main(int count, char *args[])", "int main(int n, char *values[])", "int main(int c, char *v[])", "All of the above"],
        "correctOptionIndex": 3,
        "correctOptionText": "All of the above",
        "difficulty": "medium",
        "explanation": "The parameter names can be anything you choose. While argc and argv are conventional, you could use any valid identifier names like count/args, n/values, or c/v. The important aspects are the parameter types and order.",
        "hint": "Consider whether the parameter names affect the functionality of the main function."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What's the main advantage of using getopt_long() over manual parsing of command line arguments?",
        "options": ["It's faster", "It handles error checking automatically", "It supports both short and long option formats", "All of the above"],
        "correctOptionIndex": 3,
        "correctOptionText": "All of the above",
        "difficulty": "hard",
        "explanation": "getopt_long() offers several advantages: it's efficient, it performs automatic error checking, and it supports both traditional single-character options and GNU-style long options, making command line handling more robust and user-friendly.",
        "hint": "Consider the various benefits of using a specialized library function versus custom code."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "How can you access the first command line argument after the program name in main()?",
        "options": ["args[0]", "argv[0]", "argv[1]", "args[1]"],
        "correctOptionIndex": 2,
        "correctOptionText": "argv[1]",
        "difficulty": "easy",
        "explanation": "The first argument after the program name is accessed as argv[1]. argv[0] contains the program name itself, and the subsequent array elements contain the actual arguments provided by the user.",
        "hint": "Remember that the program name occupies the first position in the array."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What is a common method to test if enough arguments were provided to a C program?",
        "options": ["if (argc < required_args) { /* error */ }", "if (argv == NULL) { /* error */ }", "if (argv[1] == NULL) { /* error */ }", "if (argc == 0) { /* error */ }"],
        "correctOptionIndex": 0,
        "correctOptionText": "if (argc < required_args) { /* error */ }",
        "difficulty": "easy",
        "explanation": "The most common way to check if enough arguments were provided is to compare argc with the minimum number of required arguments. If argc is less than the required number, the program should handle the error appropriately.",
        "hint": "Which approach checks the actual count of arguments provided?"
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Command Line Arguments",
        "questionText": "What would be the output of printf(\"%s\", argv[1]); if the program is executed with './program -p password'?",
        "options": ["./program", "-p", "password", "undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "-p",
        "difficulty": "easy",
        "explanation": "In this case, argv[1] would contain the string \"-p\", which is the first argument after the program name. The program name itself is stored in argv[0].",
        "hint": "Think about the order of arguments in the argv array."
    },

    // Bit Manipulation
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression 5 & 3 in C?",
        "options": ["8", "1", "2", "15"],
        "correctOptionIndex": 1,
        "correctOptionText": "1",
        "difficulty": "easy",
        "explanation": "The bitwise AND (&) operator compares each bit of 5 (101 in binary) with the corresponding bit of 3 (011 in binary). If both bits are 1, the result bit is 1; otherwise, it's 0. So 101 & 011 = 001, which is 1 in decimal.",
        "hint": "Convert both numbers to binary and apply the bitwise AND operation bit by bit."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression 5 | 3 in C?",
        "options": ["8", "7", "2", "15"],
        "correctOptionIndex": 1,
        "correctOptionText": "7",
        "difficulty": "easy",
        "explanation": "The bitwise OR (|) operator compares each bit of 5 (101 in binary) with the corresponding bit of 3 (011 in binary). If either bit is 1, the result bit is 1; otherwise, it's 0. So 101 | 011 = 111, which is 7 in decimal.",
        "hint": "Convert both numbers to binary and apply the bitwise OR operation bit by bit."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression 5 ^ 3 in C?",
        "options": ["8", "6", "2", "15"],
        "correctOptionIndex": 1,
        "correctOptionText": "6",
        "difficulty": "easy",
        "explanation": "The bitwise XOR (^) operator compares each bit of 5 (101 in binary) with the corresponding bit of 3 (011 in binary). If the bits are different, the result bit is 1; if they are the same, it's 0. So 101 ^ 011 = 110, which is 6 in decimal.",
        "hint": "Convert both numbers to binary and apply the bitwise XOR operation bit by bit."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression ~5 in C (assuming 8-bit integers)?",
        "options": ["-5", "-6", "250", "252"],
        "correctOptionIndex": 2,
        "correctOptionText": "250",
        "difficulty": "medium",
        "explanation": "The bitwise NOT (~) operator inverts all bits. For an 8-bit representation, 5 is 00000101. Inverting all bits gives 11111010, which is 250 in decimal (if treated as an unsigned 8-bit integer).",
        "hint": "Invert each bit of the binary representation of 5, and interpret the result as an unsigned 8-bit value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "Which operator is used for bitwise left shift in C?",
        "options": ["<<", ">>", "<-", "->"],
        "correctOptionIndex": 0,
        "correctOptionText": "<<",
        "difficulty": "easy",
        "explanation": "The bitwise left shift operator in C is <<. It shifts the bits of the left operand to the left by the number of positions specified by the right operand.",
        "hint": "This operator resembles the direction of shifting bits to the left."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of 8 << 2 in C?",
        "options": ["4", "16", "32", "2"],
        "correctOptionIndex": 2,
        "correctOptionText": "32",
        "difficulty": "easy",
        "explanation": "The expression 8 << 2 shifts the bits of 8 (1000 in binary) to the left by 2 positions. This gives 100000 in binary, which is 32 in decimal. Left shifting by n positions is equivalent to multiplying by 2^n.",
        "hint": "Each left shift multiplies the value by 2. Think of what happens when you shift 8 left twice."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of 16 >> 2 in C?",
        "options": ["4", "8", "64", "32"],
        "correctOptionIndex": 0,
        "correctOptionText": "4",
        "difficulty": "easy",
        "explanation": "The expression 16 >> 2 shifts the bits of 16 (10000 in binary) to the right by 2 positions. This gives 100 in binary, which is 4 in decimal. Right shifting by n positions is equivalent to dividing by 2^n (for unsigned integers).",
        "hint": "Each right shift divides the value by 2. Think of what happens when you shift 16 right twice."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the most efficient way to check if an integer is a power of 2?",
        "options": ["n % 2 == 0", "(n & (n-1)) == 0", "n & 1 == 0", "(n | (n-1)) == 0"],
        "correctOptionIndex": 1,
        "correctOptionText": "(n & (n-1)) == 0",
        "difficulty": "medium",
        "explanation": "The expression (n & (n-1)) == 0 checks if n is a power of 2 (assuming n > 0). Powers of 2 have only one bit set in their binary representation. When we subtract 1 from a power of 2, all the bits to the right of that set bit become 1. The bitwise AND of these two numbers will be 0 only if n is a power of 2.",
        "hint": "Consider the binary representation of powers of 2 (1, 2, 4, 8, etc.) and what happens when you subtract 1 from them."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "How can you set the nth bit of an integer x in C?",
        "options": ["x | (1 << n)", "x & (1 << n)", "x ^ (1 << n)", "x & ~(1 << n)"],
        "correctOptionIndex": 0,
        "correctOptionText": "x | (1 << n)",
        "difficulty": "medium",
        "explanation": "To set the nth bit of an integer x, use the expression x | (1 << n). This creates a value with only the nth bit set to 1, and then OR-ing it with x ensures that the nth bit in the result is set, regardless of its original value.",
        "hint": "You need to create a mask with only the nth bit set and then combine it with x in a way that ensures the bit is turned on."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "How can you clear the nth bit of an integer x in C?",
        "options": ["x | (1 << n)", "x & (1 << n)", "x ^ (1 << n)", "x & ~(1 << n)"],
        "correctOptionIndex": 3,
        "correctOptionText": "x & ~(1 << n)",
        "difficulty": "medium",
        "explanation": "To clear the nth bit of an integer x, use the expression x & ~(1 << n). This creates a value with all bits set to 1 except the nth bit, and then AND-ing it with x ensures that the nth bit in the result is cleared, regardless of its original value.",
        "hint": "You need to create a mask with all bits set to 1 except the nth bit and then combine it with x in a way that ensures the bit is turned off."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "How can you toggle the nth bit of an integer x in C?",
        "options": ["x | (1 << n)", "x & (1 << n)", "x ^ (1 << n)", "x & ~(1 << n)"],
        "correctOptionIndex": 2,
        "correctOptionText": "x ^ (1 << n)",
        "difficulty": "medium",
        "explanation": "To toggle the nth bit of an integer x, use the expression x ^ (1 << n). This creates a value with only the nth bit set to 1, and then XOR-ing it with x ensures that the nth bit in the result is toggled (changed from 0 to 1 or from 1 to 0).",
        "hint": "You need an operation that changes the bit value regardless of whether it's 0 or 1."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "How can you check if the nth bit of an integer x is set in C?",
        "options": ["(x | (1 << n)) != 0", "(x & (1 << n)) != 0", "(x ^ (1 << n)) != 0", "(x & ~(1 << n)) != 0"],
        "correctOptionIndex": 1,
        "correctOptionText": "(x & (1 << n)) != 0",
        "difficulty": "medium",
        "explanation": "To check if the nth bit of an integer x is set, use the expression (x & (1 << n)) != 0. This creates a value with only the nth bit set to 1, and then AND-ing it with x will result in a non-zero value only if the nth bit in x is set.",
        "hint": "You need to isolate the nth bit and check if it's 1."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression 5 << -1 in C?",
        "options": ["2", "10", "Undefined behavior", "2.5"],
        "correctOptionIndex": 2,
        "correctOptionText": "Undefined behavior",
        "difficulty": "medium",
        "explanation": "Shifting by a negative amount in C is undefined behavior. The C standard does not specify what happens in this case, and the result can vary between compilers or even between different runs of the same program.",
        "hint": "Consider what the C standard says about the validity of shift amounts."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the difference between >> and >>> operators in C?",
        "options": [">> is arithmetic shift, >>> is logical shift", ">> shifts right, >>> shifts left", ">> is a binary operator, >>> is a unary operator", "There is no >>> operator in C"],
        "correctOptionIndex": 3,
        "correctOptionText": "There is no >>> operator in C",
        "difficulty": "medium",
        "explanation": "There is no >>> operator in the C language. The >>> operator exists in some other languages like Java and JavaScript and represents an unsigned right shift, but in C there is only >> which behavior depends on the operand's type (signed or unsigned).",
        "hint": "Think about the standard bitwise operators available in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What happens when you right shift a negative number in C?",
        "options": ["It always becomes positive", "The sign bit is preserved (arithmetic shift)", "The result is always 0", "It's undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "The sign bit is preserved (arithmetic shift)",
        "difficulty": "medium",
        "explanation": "When right-shifting a negative number in C, the behavior is implementation-defined, but most implementations perform an arithmetic right shift, which preserves the sign bit by filling in the vacated bits with the sign bit (1 for negative numbers).",
        "hint": "Consider what happens to the sign bit during right shift operations on signed integers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "How can you count the number of set bits (1s) in an integer using Brian Kernighan's algorithm?",
        "options": ["x & (x-1)", "while(x) { count++; x >>= 1; }", "while(x) { count++; x &= (x-1); }", "None of the above"],
        "correctOptionIndex": 2,
        "correctOptionText": "while(x) { count++; x &= (x-1); }",
        "difficulty": "hard",
        "explanation": "Brian Kernighan's algorithm counts set bits by iteratively clearing the rightmost set bit. The expression x &= (x-1) clears the rightmost set bit of x. We repeat this until x becomes 0, counting each step.",
        "hint": "This algorithm works by repeatedly removing the rightmost set bit and counting how many times this can be done."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the most efficient way to determine if two integers have opposite signs?",
        "options": ["(a < 0 && b >= 0) || (a >= 0 && b < 0)", "(a ^ b) < 0", "(a & b) < 0", "(a | b) < 0"],
        "correctOptionIndex": 1,
        "correctOptionText": "(a ^ b) < 0",
        "difficulty": "hard",
        "explanation": "The expression (a ^ b) < 0 checks if a and b have opposite signs by looking at the sign bit of their XOR. The sign bit in the result will be 1 (making the result negative) only if the sign bits of a and b differ.",
        "hint": "Think about how XOR behaves with the sign bits of two numbers with opposite signs."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "Which of the following can be used to swap two integers a and b without using a temporary variable?",
        "options": ["a = a + b; b = a - b; a = a - b;", "a = a ^ b; b = a ^ b; a = a ^ b;", "a = a * b; b = a / b; a = a / b;", "Both A and B"],
        "correctOptionIndex": 3,
        "correctOptionText": "Both A and B",
        "difficulty": "medium",
        "explanation": "Both methods can swap integers without a temporary variable. The XOR method uses bitwise operations: a = a ^ b; b = a ^ b; a = a ^ b;. The arithmetic method uses addition and subtraction: a = a + b; b = a - b; a = a - b;. Both work by encoding both values in a combined form, then extracting them differently.",
        "hint": "Consider which operations can be used to combine two values and then extract them in reverse order."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What will be the value of x after executing the code: int x = 5; x |= (1 << 2);?",
        "options": ["1", "5", "7", "9"],
        "correctOptionIndex": 2,
        "correctOptionText": "7",
        "difficulty": "medium",
        "explanation": "Starting with x = 5 (101 in binary), we set the bit at position 2 (0-indexed from right). (1 << 2) gives 100 in binary (4 in decimal). x |= (1 << 2) sets the bit at position 2, resulting in 111 in binary, which is 7 in decimal.",
        "hint": "Convert the initial value to binary, determine which bit is being set, and calculate the new value."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "Which of the following expressions will round up an unsigned integer x to the next power of 2?",
        "options": ["1 << (log2(x) + 1)", "x = x | (x >> 1); x = x | (x >> 2); x = x | (x >> 4); x = x | (x >> 8); x = x | (x >> 16); x++;", "x = (x & (x - 1)) ? (1 << (log2(x) + 1)) : x;", "None of the above"],
        "correctOptionIndex": 1,
        "correctOptionText": "x = x | (x >> 1); x = x | (x >> 2); x = x | (x >> 4); x = x | (x >> 8); x = x | (x >> 16); x++;",
        "difficulty": "hard",
        "explanation": "This algorithm first fills all bits to the right of the highest set bit, creating a value one less than the next power of 2, and then increments it. The series of bitwise OR and right shifts propagate the highest set bit to all lower positions.",
        "hint": "This technique first creates a number with all bits set up to the highest set bit, then adds 1 to get the next power of 2."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What does the expression ~0 represent in C (assuming 32-bit integers)?",
        "options": ["0", "1", "-1", "All bits set to 1 (0xFFFFFFFF)"],
        "correctOptionIndex": 3,
        "correctOptionText": "All bits set to 1 (0xFFFFFFFF)",
        "difficulty": "medium",
        "explanation": "The expression ~0 inverts all bits of 0 (00000...000), resulting in a value with all bits set to 1 (11111...111). For a 32-bit integer, this is 0xFFFFFFFF, which is -1 in two's complement representation for signed integers, but it's also all bits set to 1 as an unsigned value.",
        "hint": "Consider what happens when you apply the bitwise NOT operator to a value of zero."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the result of the expression (1 << 31) in C on a system with 32-bit integers?",
        "options": ["2147483648", "-2147483648", "0", "Undefined behavior"],
        "correctOptionIndex": 1,
        "correctOptionText": "-2147483648",
        "difficulty": "medium",
        "explanation": "On a system with 32-bit integers, (1 << 31) shifts a 1 into the sign bit position, creating the binary representation of -2147483648 (the minimum value for a 32-bit signed integer). This happens because the result is interpreted as a signed integer in two's complement representation.",
        "hint": "Consider what happens when the leftmost bit (the sign bit) is set in a signed integer."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the quickest way to determine if an integer is odd using bitwise operations?",
        "options": ["x % 2 != 0", "x & 1", "x | 1", "x ^ 1"],
        "correctOptionIndex": 1,
        "correctOptionText": "x & 1",
        "difficulty": "easy",
        "explanation": "The expression x & 1 checks if the least significant bit (LSB) of x is set. If the LSB is 1, the number is odd; if it's 0, the number is even. This works because all odd numbers end with 1 in binary.",
        "hint": "Look at the binary representation of odd and even numbers and focus on the rightmost bit."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the value of the expression (-1 >> 1) in C?",
        "options": ["0", "-1", "-2", "Implementation-dependent"],
        "correctOptionIndex": 1,
        "correctOptionText": "-1",
        "difficulty": "hard",
        "explanation": "In C, right-shifting a negative number is implementation-defined, but most implementations perform an arithmetic right shift. For -1 (all bits are 1), shifting right by 1 position still gives all 1s (because the sign bit is replicated), which is still -1.",
        "hint": "Consider the binary representation of -1 and how arithmetic right shift works on negative numbers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the bitwise operation to extract bits m to n (inclusive) from an integer x?",
        "options": ["(x >> m) & ((1 << (n - m + 1)) - 1)", "(x << m) & ((1 << (n - m + 1)) - 1)", "(x & (1 << n)) >> m", "None of the above"],
        "correctOptionIndex": 0,
        "correctOptionText": "(x >> m) & ((1 << (n - m + 1)) - 1)",
        "difficulty": "hard",
        "explanation": "To extract bits m to n from x, first right-shift x by m positions to bring the desired bits to the rightmost positions, then mask with a value having the rightmost (n-m+1) bits set. The mask is created by left-shifting 1 by (n-m+1) and subtracting 1.",
        "hint": "You need to both position the desired bits at the rightmost positions and isolate them with a mask."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "Which of the following can be used to rotate the bits of an unsigned integer x to the right by n positions?",
        "options": ["(x >> n) | (x << (32 - n))", "(x << n) | (x >> (32 - n))", "x >> n", "x << n"],
        "correctOptionIndex": 0,
        "correctOptionText": "(x >> n) | (x >> (32 - n))",
        "difficulty": "hard",
        "explanation": "A right rotate by n positions can be implemented as (x >> n) | (x << (32 - n)). This shifts the rightmost n bits off the right end and reintroduces them at the left end. Note: This assumes a 32-bit integer; the width should match the actual integer size.",
        "hint": "Rotation involves moving bits that fall off one end back to the other end, which requires two shifts and a combine operation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the most efficient way to clear all bits in an integer x except the rightmost 1 bit?",
        "options": ["x & 1", "x & -x", "x & (x-1)", "x & ~(x-1)"],
        "correctOptionIndex": 1,
        "correctOptionText": "x & -x",
        "difficulty": "hard",
        "explanation": "The expression x & -x isolates the rightmost 1 bit of x. In two's complement representation, -x is the bitwise complement of x plus 1. This creates a value with only the rightmost 1 bit of x set, and all other bits cleared.",
        "hint": "Consider how two's complement negation affects the bit pattern and how it can be used with AND to isolate specific bits."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the output of printf(\"%d\", 3^5); in C?",
        "options": ["15", "6", "243", "8"],
        "correctOptionIndex": 1,
        "correctOptionText": "6",
        "difficulty": "easy",
        "explanation": "In C, the ^ operator is bitwise XOR, not exponentiation. 3 in binary is 011, and 5 in binary is 101. Performing bitwise XOR: 011 ^ 101 = 110, which is 6 in decimal.",
        "hint": "In C, the caret symbol (^) represents bitwise XOR, not the power operation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "Which bitwise operation is used for masking (selecting only specific bits from a value)?",
        "options": ["Bitwise AND (&)", "Bitwise OR (|)", "Bitwise XOR (^)", "Bitwise NOT (~)"],
        "correctOptionIndex": 0,
        "correctOptionText": "Bitwise AND (&)",
        "difficulty": "easy",
        "explanation": "Bitwise AND (&) is commonly used for masking. By ANDing a value with a mask (a value with 1s in the positions we want to keep and 0s elsewhere), we can extract only the bits we're interested in.",
        "hint": "Think about which operation will keep bits only where both the original value and the mask have 1s."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "What is the purpose of the following C macro? #define BIT_SET(x, pos) ((x) |= (1UL << (pos)))",
        "options": ["To check if a bit is set", "To set a bit at a specific position", "To clear a bit at a specific position", "To toggle a bit at a specific position"],
        "correctOptionIndex": 1,
        "correctOptionText": "To set a bit at a specific position",
        "difficulty": "medium",
        "explanation": "This macro sets the bit at position 'pos' in variable 'x'. It creates a value with only the bit at position 'pos' set to 1 (using 1UL << (pos)), and then uses the |= operator to OR this with x, which ensures that the bit at position 'pos' is set to 1.",
        "hint": "Look at the operations performed by the macro and determine what happens to the bit at the specified position."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Bit Manipulation",
        "questionText": "In a flags variable used for bit flags, what does the statement 'flags &= ~mask;' do?",
        "options": ["Sets the bits specified by mask", "Toggles the bits specified by mask", "Clears the bits specified by mask", "Checks if any bits in mask are set"],
        "correctOptionIndex": 2,
        "correctOptionText": "Clears the bits specified by mask",
        "difficulty": "medium",
        "explanation": "The statement 'flags &= ~mask;' clears the bits specified by mask in the flags variable. The ~ operator inverts all bits in mask, creating a value with 0s where mask has 1s. ANDing flags with this value keeps all original bits except those specified by mask, which are cleared.",
        "hint": "Consider what happens when you AND a value with a mask that has 0s in specific positions."
    },

    // Advanced C Concepts
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is a function pointer in C?",
        "options": [
        "A pointer that points to another pointer",
        "A pointer that points to a memory location where a function is stored",
        "A function that returns a pointer",
        "A special type of NULL pointer"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "A pointer that points to a memory location where a function is stored",
        "difficulty": "easy",
        "explanation": "A function pointer is a variable that stores the address of a function. It can be used to call a function indirectly, enabling techniques like callbacks and dynamic function selection at runtime.",
        "hint": "Think about what makes function pointers different from regular pointers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the correct syntax for declaring a function pointer that points to a function taking an int and returning void?",
        "options": [
        "void (*ptr)(int);",
        "void *ptr(int);",
        "(*ptr)(int) void;",
        "int (*ptr)(void);"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "void (*ptr)(int);",
        "difficulty": "medium",
        "explanation": "The syntax 'void (*ptr)(int);' declares a function pointer named 'ptr' that points to a function which takes an int parameter and returns void. The parentheses around *ptr are necessary to indicate that ptr is a pointer to a function, not a function returning a pointer.",
        "hint": "Consider the return type (before the pointer name) and the parameter types (after the pointer name)."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will be the output of the following code?\n\n```c\n#include <stdio.h>\nvoid fun1() { printf(\"A\"); }\nvoid fun2() { printf(\"B\"); }\nint main() {\n    void (*fptr)();\n    fptr = fun1;\n    fptr();\n    fptr = fun2;\n    fptr();\n    return 0;\n}\n```",
        "options": [
        "AB",
        "BA",
        "AA",
        "BB"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "AB",
        "difficulty": "easy",
        "explanation": "The code first assigns the address of fun1 to the function pointer 'fptr', then calls fun1 via the pointer, printing 'A'. Next, it assigns the address of fun2 to 'fptr' and calls fun2 via the pointer, printing 'B'. Thus, the output is 'AB'.",
        "hint": "Follow the assignment and function calls through the pointer step by step."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of the 'volatile' keyword in C?",
        "options": [
        "To make a variable thread-safe",
        "To indicate that a variable's value can be changed by external factors",
        "To prevent a variable from being optimized by the compiler",
        "Both B and C"
        ],
        "correctOptionIndex": 3,
        "correctOptionText": "Both B and C",
        "difficulty": "medium",
        "explanation": "The 'volatile' keyword in C serves two main purposes: it tells the compiler that a variable's value might be changed by factors outside of the program's control (like hardware), and it prevents the compiler from optimizing operations on the variable, ensuring that every access to the variable is performed as written in the code.",
        "hint": "Think about how 'volatile' affects both the compiler's understanding of a variable and its optimization decisions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will the following recursive function return when called with n=5?\n\n```c\nint f(int n) {\n    if (n <= 1)\n        return 1;\n    return n * f(n-1);\n}\n```",
        "options": [
        "5",
        "15",
        "120",
        "720"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "120",
        "difficulty": "easy",
        "explanation": "This function calculates the factorial of n. For n=5, it computes 5 * 4 * 3 * 2 * 1 = 120. The recursion stops when n reaches 1, at which point the function returns 1.",
        "hint": "Trace through the recursive calls for small values of n and see if you can identify the mathematical operation being performed."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "Which of the following is NOT a drawback of recursion in C?",
        "options": [
        "Increased memory usage due to stack frames",
        "Potential for stack overflow with deep recursion",
        "Often less efficient than iterative solutions",
        "Inability to express certain algorithms"
        ],
        "correctOptionIndex": 3,
        "correctOptionText": "Inability to express certain algorithms",
        "difficulty": "medium",
        "explanation": "Recursion in C has several drawbacks including higher memory usage, risk of stack overflow, and often lower efficiency compared to iterative solutions. However, recursion is actually more expressive than iteration for certain algorithms (like tree traversals), and any recursive algorithm can be expressed recursively.",
        "hint": "Consider which option contradicts a key advantage of recursion."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is tail recursion in C?",
        "options": [
        "A recursive function that calls itself at the end of its execution",
        "A recursive function where the recursive call is not part of a larger expression",
        "A recursive function that uses the return value of the recursive call",
        "A recursive function where the compiler can optimize the recursion into iteration"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "A recursive function where the recursive call is not part of a larger expression",
        "difficulty": "hard",
        "explanation": "Tail recursion occurs when a recursive call is the last operation in a function and its result is not part of a larger expression. This allows compilers to optimize the recursion into iteration, avoiding stack overflow issues. Simply calling itself at the end isn't sufficient; the recursive call must be the final operation whose result is directly returned.",
        "hint": "Consider the defining characteristic that enables compilers to optimize tail recursive functions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What does the following code print?\n\n```c\n#include <stdio.h>\nint main() {\n    int i = 10;\n    void *ptr = &i;\n    printf(\"%d\\n\", *(int *)ptr);\n    return 0;\n}\n```",
        "options": [
        "10",
        "Address of i",
        "Compilation error",
        "Runtime error"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "10",
        "difficulty": "medium",
        "explanation": "The code creates a void pointer 'ptr' pointing to integer 'i'. Then it casts 'ptr' back to an int pointer using '(int *)ptr' and dereferences it using '*', retrieving the value of 'i', which is 10. The void pointer is a generic pointer that can hold the address of any data type but must be cast to the appropriate type before dereferencing.",
        "hint": "Think about how void pointers work with casting and dereferencing."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "Which C library function would you use to set a signal handler for handling interrupts?",
        "options": [
        "interrupt()",
        "handle()",
        "signal()",
        "catch()"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "signal()",
        "difficulty": "medium",
        "explanation": "The 'signal()' function from the <signal.h> library is used to set up a signal handler in C. It takes two parameters: the signal number to handle and a pointer to the handler function. For example, 'signal(SIGINT, handle_sigint);' would set up the handle_sigint function to be called when the program receives a SIGINT signal (typically generated by pressing Ctrl+C).",
        "hint": "This function is part of the standard C library and is specifically designed for registering signal handlers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the output of the following code?\n\n```c\n#include <stdio.h>\n#include <setjmp.h>\n\njmp_buf buf;\n\nvoid func() {\n    printf(\"2 \");\n    longjmp(buf, 1);\n    printf(\"This won't print\");\n}\n\nint main() {\n    if (setjmp(buf) == 0) {\n        printf(\"1 \");\n        func();\n    } else {\n        printf(\"3 \");\n    }\n    return 0;\n}\n```",
        "options": [
        "1 2 3",
        "1 2",
        "1 3",
        "2 3"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "1 2 3",
        "difficulty": "hard",
        "explanation": "This code demonstrates setjmp/longjmp for non-local jumps. Initially, setjmp(buf) returns 0, so '1' is printed and func() is called. Inside func(), '2' is printed, and longjmp(buf, 1) jumps back to where setjmp was called, but this time setjmp returns 1 (the value passed to longjmp). This makes the program enter the else branch, printing '3'. The string after longjmp is never printed.",
        "hint": "Follow the flow of execution, noting how setjmp returns different values on different occasions."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of 'restrict' keyword in C99?",
        "options": [
        "To make a variable immutable",
        "To indicate that a pointer is the only means of accessing a data object",
        "To restrict access to a variable from other functions",
        "To prevent memory leaks"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "To indicate that a pointer is the only means of accessing a data object",
        "difficulty": "hard",
        "explanation": "The 'restrict' keyword in C99 is an optimization hint to the compiler. It indicates that a pointer is the only means of accessing the data object it points to for the lifetime of that pointer. This allows the compiler to make optimizations it couldn't otherwise make, such as assuming that operations through that pointer won't affect memory accessed through other pointers.",
        "hint": "The keyword provides information to the compiler about pointer aliasing."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will the following code print?\n\n```c\n#include <stdio.h>\nint main() {\n    union {\n        int i;\n        float f;\n    } u;\n    u.f = 1.5;\n    printf(\"%d\\n\", u.i);\n    return 0;\n}\n```",
        "options": [
        "1",
        "1069547520",
        "2",
        "Undefined behavior"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "1069547520",
        "difficulty": "hard",
        "explanation": "The code assigns 1.5 to the float member of a union, then prints the int member. Since both members share the same memory location, this effectively prints the bit pattern of 1.5 interpreted as an int. For the IEEE 754 floating-point format, the binary representation of 1.5 when interpreted as an int typically gives 1069547520 (this may vary on some systems or with compiler settings).",
        "hint": "Consider how unions store their members in the same memory location and how floating-point values are represented in memory."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "Which of the following is a valid way to create a variadic function in C?",
        "options": [
        "void func(int count, int args...)",
        "void func(int count, ...)",
        "void func(..., int count)",
        "void func(int *args, int count)"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "void func(int count, ...)",
        "difficulty": "medium",
        "explanation": "In C, variadic functions are defined using an ellipsis (...) after at least one fixed parameter. The correct syntax is 'void func(int count, ...)' where 'count' is a fixed parameter and '...' indicates that the function can accept additional arguments. The fixed parameter is typically used to indicate how many variable arguments to expect.",
        "hint": "Look for the option that uses the ellipsis in the proper position according to C syntax rules."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of the va_list, va_start, va_arg, and va_end macros in C?",
        "options": [
        "To handle variable scope in functions",
        "To manage memory dynamically",
        "To work with variadic functions",
        "To implement exception handling"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "To work with variadic functions",
        "difficulty": "medium",
        "explanation": "These macros from <stdarg.h> are used to access the variable arguments in a variadic function. va_list declares a variable to store argument information, va_start initializes it, va_arg retrieves each argument, and va_end cleans up. They provide the mechanism to access arguments when the number and types aren't known at compile time.",
        "hint": "These macros are specifically designed to handle a particular type of function in C."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will happen when the following code is executed?\n\n```c\n#include <stdio.h>\nint main() {\n    int i = 10;\n    const int *ptr = &i;\n    *ptr = 20;\n    printf(\"%d\\n\", i);\n    return 0;\n}\n```",
        "options": [
        "It will print 20",
        "It will print 10",
        "Compilation error",
        "Runtime error"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Compilation error",
        "difficulty": "medium",
        "explanation": "The code will cause a compilation error because ptr is declared as a pointer to a constant integer (const int *). This means the value it points to cannot be modified through this pointer. The statement *ptr = 20 attempts to modify the value, which violates this constraint. The compiler will catch this error during compilation.",
        "hint": "Consider what 'const int *' means in terms of what operations are allowed on the pointer."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the difference between 'const int *p' and 'int * const p'?",
        "options": [
        "They are equivalent declarations",
        "'const int *p' means p cannot be modified, while 'int * const p' means the value pointed to by p cannot be modified",
        "'const int *p' means the value pointed to by p cannot be modified, while 'int * const p' means p cannot be modified",
        "Both declarations prevent both p and the value it points to from being modified"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "'const int *p' means the value pointed to by p cannot be modified, while 'int * const p' means p cannot be modified",
        "difficulty": "medium",
        "explanation": "In 'const int *p' (or 'int const *p'), the const applies to the int, meaning p can be changed to point elsewhere, but the value it points to cannot be modified through p. In 'int * const p', the const applies to the pointer itself, meaning p cannot be changed to point elsewhere, but the value it points to can be modified.",
        "hint": "Look at the position of 'const' relative to the type and the pointer symbol."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the correct way to create a function pointer array for functions that take no arguments and return an int?",
        "options": [
        "int (*fptr[])();",
        "int *fptr[]();",
        "int (*)() fptr[];",
        "int fptr[]();"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "int (*fptr[])();",
        "difficulty": "hard",
        "explanation": "The correct syntax for an array of function pointers is 'int (*fptr[])();'. This declares an array 'fptr' of pointers to functions that take no arguments and return an int. The parentheses around *fptr[] are necessary to indicate that fptr is an array of pointers to functions, not a function returning an array of pointers.",
        "hint": "Consider the order of operators and parentheses needed to correctly declare an array of function pointers."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will be the output of the following code?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};\n    int (*ptr)[3] = arr;\n    printf(\"%d %d\\n\", (*ptr)[1], *(*(ptr+1)+2));\n    return 0;\n}\n```",
        "options": [
        "1 3",
        "2 6",
        "4 6",
        "2 3"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "2 6",
        "difficulty": "hard",
        "explanation": "Here, ptr is a pointer to an array of 3 integers. Initially, it points to arr[0]. (*ptr)[1] accesses the second element of the first row, which is 2. ptr+1 advances ptr to point to arr[1], and *(*(ptr+1)+2) accesses the third element of the second row, which is 6. The notation is complex because ptr points to entire rows (arrays of 3 ints), not individual elements.",
        "hint": "Consider what ptr points to (an array of 3 ints) and how pointer arithmetic works in this context."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of '_Noreturn' function specifier introduced in C11?",
        "options": [
        "It specifies that a function returns no value (same as void)",
        "It specifies that a function doesn't return control to the calling function",
        "It specifies that a function cannot be called recursively",
        "It specifies that a function cannot be called more than once"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "It specifies that a function doesn't return control to the calling function",
        "difficulty": "hard",
        "explanation": "The '_Noreturn' function specifier (or its macro form 'noreturn' from <stdnoreturn.h>) indicates that a function will not return to its caller normally. This is used for functions that terminate the program (like exit(), abort()) or transfer control elsewhere (via longjmp()). It helps the compiler optimize code and provide better warnings.",
        "hint": "This specifier is used with functions that terminate execution or use non-local jumps."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is thread-local storage in C?",
        "options": [
        "A technique for storing thread identifiers",
        "A way to allocate memory for new threads",
        "Variables that have separate instances for each thread",
        "A method for threads to communicate with each other"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Variables that have separate instances for each thread",
        "difficulty": "hard",
        "explanation": "Thread-local storage (TLS) provides a mechanism for declaring variables that have a separate instance for each thread in a multi-threaded program. In C11, this is achieved using the '_Thread_local' storage class specifier (or its macro form 'thread_local' from <threads.h>). Each thread has its own copy of a thread-local variable, preventing data races when threads access the variable simultaneously.",
        "hint": "Think about how multi-threaded programs need to handle variables that should not be shared between threads."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the correct way to declare a thread-local variable in C11?",
        "options": [
        "thread int counter = 0;",
        "thread_local int counter = 0;",
        "_Thread_local int counter = 0;",
        "local_thread int counter = 0;"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "_Thread_local int counter = 0;",
        "difficulty": "medium",
        "explanation": "In C11, the correct way to declare a thread-local variable is using the '_Thread_local' storage class specifier. If the <threads.h> header is included, you can also use the more readable 'thread_local' macro which expands to '_Thread_local'. This creates a separate instance of the variable for each thread in a multi-threaded program.",
        "hint": "Look for the standard C11 keyword for thread-local storage."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the significance of the 'static' keyword when used inside a function in C?",
        "options": [
        "It makes the variable accessible throughout the file",
        "It restricts the variable's scope to the function",
        "It preserves the variable's value between function calls",
        "It allocates the variable on the heap instead of the stack"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "It preserves the variable's value between function calls",
        "difficulty": "easy",
        "explanation": "When 'static' is used for a local variable inside a function, it gives the variable static storage duration, meaning it is initialized only once when program execution begins and its value is preserved between function calls. The variable still has block scope (only accessible within the function), but it retains its value when the function exits and can be used in subsequent calls.",
        "hint": "Think about what happens to the variable's value when the function returns and is called again."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the output of this code?\n\n```c\n#include <stdio.h>\n\nint strange(int x) {\n    static int y = 0;\n    y += x;\n    return y;\n}\n\nint main() {\n    printf(\"%d \", strange(1));\n    printf(\"%d \", strange(2));\n    printf(\"%d\\n\", strange(3));\n    return 0;\n}\n```",
        "options": [
        "1 2 3",
        "1 3 6",
        "1 3 5",
        "1 1 1"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "1 3 6",
        "difficulty": "easy",
        "explanation": "The function 'strange' has a static local variable 'y' initialized to 0. Each call to strange adds the parameter 'x' to 'y' and returns the new value of 'y'. So the first call with x=1 returns 1, the second call with x=2 returns 3 (1+2), and the third call with x=3 returns 6 (1+2+3). The static variable retains its value between function calls.",
        "hint": "Consider how the static variable's value changes with each function call."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of the 'inline' function specifier in C?",
        "options": [
        "To make a function run faster by optimizing its code",
        "To suggest that the compiler replace the function call with the function's code",
        "To prevent a function from being called directly",
        "To specify that a function has no side effects"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "To suggest that the compiler replace the function call with the function's code",
        "difficulty": "medium",
        "explanation": "The 'inline' function specifier in C suggests to the compiler that it should replace calls to the function with the actual function code (inline expansion) rather than performing a normal function call. This can improve performance by eliminating the overhead of a function call, but it's only a suggestion—the compiler may choose to ignore it. Inlining is particularly useful for small, frequently called functions.",
        "hint": "Consider what happens to the function's code at the call site during compilation."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What will the following code print?\n\n```c\n#include <stdio.h>\n\n#define SQUARE(x) (x*x)\n\nint main() {\n    int result = SQUARE(3+2);\n    printf(\"%d\\n\", result);\n    return 0;\n}\n```",
        "options": [
        "25",
        "11",
        "13",
        "Compilation error"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "13",
        "difficulty": "medium",
        "explanation": "The macro SQUARE(x) expands to (x*x). When SQUARE(3+2) is used, it expands to (3+2*3+2) due to macro text substitution, not (3+2)*(3+2). Following operator precedence, this evaluates to (3+6+2) = 11, not 25. This demonstrates a common pitfall with macros: unexpected behavior due to operator precedence when arguments contain expressions.",
        "hint": "Macros perform text substitution. Consider how the expression expands and how operator precedence affects the result."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "How would you fix the SQUARE macro to handle expressions correctly?",
        "options": [
        "#define SQUARE(x) x*x",
        "#define SQUARE(x) ((x)*(x))",
        "#define SQUARE(x) (x*x)",
        "#define SQUARE(x) (x)*(x)"
        ],
        "correctOptionIndex": 1,
        "correctOptionText": "#define SQUARE(x) ((x)*(x))",
        "difficulty": "medium",
        "explanation": "The correct way to define the SQUARE macro is #define SQUARE(x) ((x)*(x)). This wraps both the entire expression and each instance of the parameter in parentheses. The outer parentheses ensure the entire result is treated as a single expression, while the inner parentheses around each x ensure that any expression passed as an argument is evaluated correctly before the multiplication.",
        "hint": "To handle expressions safely in macros, you need to use parentheses around both the entire expression and each parameter."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is the purpose of the 'extern' keyword in C?",
        "options": [
        "To declare a function or variable without defining it",
        "To make a variable accessible to other files",
        "To import definitions from external libraries",
        "To declare a variable that will be initialized by external code"
        ],
        "correctOptionIndex": 0,
        "correctOptionText": "To declare a function or variable without defining it",
        "difficulty": "medium",
        "explanation": "The 'extern' keyword in C is used to declare a variable or function that is defined elsewhere, typically in another source file. It tells the compiler that the variable or function exists, but the storage for a variable is not allocated and the function body is not provided in this file. This allows multiple files to share the same variables and functions.",
        "hint": "Think about how 'extern' affects the compiler's understanding of a symbol's definition location."
    },
    {
        "topic": "67d6b45a953bd3a26da2ad82",
        "module": "Advanced C Concepts",
        "questionText": "What is a likely outcome of this code?\n\n```c\n#include <stdio.h>\n\nint main() {\n    int *p = NULL;\n    *p = 10;\n    printf(\"%d\\n\", *p);\n    return 0;\n}\n```",
        "options": [
        "It will print 10",
        "It will print 0",
        "Segmentation fault or similar runtime error",
        "Compilation error"
        ],
        "correctOptionIndex": 2,
        "correctOptionText": "Segmentation fault or similar runtime error",
        "difficulty": "easy",
        "explanation": "This code attempts to dereference a NULL pointer (access the memory location it points to). NULL represents an invalid memory address (typically 0), and attempting to read from or write to this address causes a segmentation fault or similar runtime error on most systems. The program will crash before reaching the printf statement.",
        "hint": "Consider what happens when you try to access memory at address 0 in a typical operating system."
    },
    
  ];

export default CQuestions;